<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/杂记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/杂记/" itemprop="url">杂记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:48:12+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>css中两个类选择器之间没有空格形成多类选择器， 有空格形成后代选择器  。</strong></p>
<hr>
<p><strong>CSS hover，没有延迟</strong></p>
<hr>
<p><p-column styleclass="txt-center overline" field="stationName" header="配电站"><br>      <ng-template let-unit="" let-row="rowData" ptemplate="body"><br>      &lt;span <strong>title=”“</strong>&gt;<br>    </ng-template><br></p-column></p>
<hr>
<h2 id="css3修改滚动条样式"><a href="#css3修改滚动条样式" class="headerlink" title="css3修改滚动条样式"></a>css3修改滚动条样式</h2><p><strong>1.滚动条组成</strong></p>
<p>::-webkit-scrollbar 滚动条整体部分</p>
<p>::-webkit-scrollbar-thumb  滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）</p>
<p>::-webkit-scrollbar-track  滚动条的轨道（里面装有Thumb）</p>
<p>::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。</p>
<p>::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去）</p>
<p>::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</p>
<p>::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件</p>
<p><strong>2.简洁版demo</strong></p>
<p>/<em>定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸</em>/ </p>
<pre><code>::-webkit-scrollbar 
{ 
    width: 16px;     
    height: 16px;     
    background-color: #F5F5F5; 
} 
</code></pre><p>/<em>定义滚动条轨道 内阴影+圆角</em>/ </p>
<pre><code>::-webkit-scrollbar-track 
{ 
    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3); 
    border-radius: 10px; 
    background-color: #F5F5F5; 
} 
</code></pre><p>/<em>定义滑块 内阴影+圆角</em>/ </p>
<pre><code>::-webkit-scrollbar-thumb 
{ 
    border-radius: 10px; 
    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); 
    background-color: #555; 
} 
</code></pre><hr>
<h1 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h1><p>惰性求值（Lazy evaluation）是在需要时才进行求值的计算方式。惰性求值自然地在数据结构中包含递归，可以以简单的方式表示无限的概念，这种方式有利于程序的模块化。</p>
<p>Haskell语言以采用惰性求值而广为人熟知。Scheme也部分采用了惰性求值。</p>
<hr>
<p><strong>0.1 + 0.2 - 0.3</strong></p>
<p>// 5.551115123125783e-17</p>
<p>0.1 + 0.2 === 0.3 // false</p>
<hr>
<h2 id="Array-prototype-slice-call-方法详解"><a href="#Array-prototype-slice-call-方法详解" class="headerlink" title="Array.prototype.slice.call()方法详解"></a>Array.prototype.slice.call()方法详解</h2><p>多次用到 Array.prototype.slice.call(arguments, 1)，不就是等于 arguments.slice(1) 吗？像前者那样写具体的好处是什么？这个很多js新手最疑惑的地方。那为什么呢？</p>
<p>因为arguments并不是真正的数组对象，只是与数组类似而已，所以它并没有slice这个方法，而Array.prototype.slice.call(arguments, 1)可以理解成是让arguments转换成一个数组对象，让arguments具有slice()方法。要是直接写arguments.slice(1)会报错。</p>
<p>typeof arguments===”object” //而不是 “Array”</p>
<hr>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>
<hr>
<p>在JavaScript中，如果你在一个函数体内又用到了function关键字，那么你将会生成一个闭包(Closure)。</p>
<p>闭包含有当前作用域内的所有变量接入。</p>
<p>每一次对外部函数的调用都会产生一个独立的包含本地变量的闭包。</p>
<p><strong>闭包到底什么用</strong></p>
<p>可以在函数外部读取函数内部的变量<br>可以将这些变量的值在内存中持久化</p>
<hr>
<h1 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h1><p>IIFE（立即调用函数表达式）是一个在定义时就会立即执行的JavaScript函数。</p>
<p>这是一个被称为<strong>自执行匿名函数</strong>的设计模式，主要包含两部分。第一部分是包围在<strong>圆括号运算符</strong>（）里的一个匿名函数，这个匿名函数拥有独立的词法作用域，这不仅避免了外界访问此IIFE中的变量，而且又不会污染全局作用域。</p>
<p>第二部分再使用()创建了一个立即执行函数表达式，JavaScript引擎到此将直接执行函数。</p>
<hr>
<p>箭头函数导致this总是指向函数定义生效时所在的对象</p>
<hr>
<p>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行</p>
<hr>
<p>Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<hr>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<hr>
<p>创建XMLHttpRequest对象的语法：</p>
<p>xmlhttp = new XMLHttpRequest();</p>
<p>老版本的Internet Explorer（IE5和IE6）使用ActiveX对象：</p>
<p>xmlhttp = new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<hr>
<p>echarts: itemStyle属性要加normal属性</p>
<hr>
<h1 id=""><a href="#" class="headerlink" title=""></a><ng-container></ng-container></h1><p>使用<ng-container>把一些兄弟元素归为一组</ng-container></p>
<p>Angular的<ng-container>是一个分组元素，但它不会污染样式或元素布局，因为Angular压根不会把它放进DOM中。</ng-container></p>
<p><ng-container>是一个由Angular解析器负责识别处理的语法元素。它不是一个指令、组件、类或接口，更像是JavaScript中if块中的花括号。</ng-container></p>
<p>没有这些花括号，JavaScript只会执行第一句，而你原本的意图是把其中的所有语句都视为一体来根据条件执行。而<ng-container>满足了Angular模板中类似的需求。</ng-container></p>
<hr>
<p><a href="https://www.chungold.com/" target="_blank" rel="noopener">https://www.chungold.com/</a></p>
<p>账号 <a href="mailto:hon_ghuan1688@126.com" target="_blank" rel="noopener">hon_ghuan1688@126.com</a></p>
<p>密码  zhnyfw@001</p>
<hr>
<p>background-clip 属性<br>background-clip属性指定背景绘制区域</p>
<p>语法<br>background-clip:</p>
<pre><code>border-box // 背景到border
padding-box // 背景到padding
content-box // 背景到content
</code></pre><hr>
<p>background-origin属性</p>
<p>background-origin属性指定background-position属性应该是相对位置</p>
<hr>
<p>background-size</p>
<p>第二个值，不写默认为auto</p>
<hr>
<p>background:linear-gradient(angle …);</p>
<p>角度说明</p>
<p>0deg将创建一个从上到下的渐变，90deg将创建一个从左到右的渐变。</p>
<hr>
<p>Internet Explorer 渐变</p>
<pre><code>语法    
filter:progid:DXImageTransform.Microsoft.gradient
(startColorstr=&apos;startColor&apos;, 
endColorstr=&apos;endColor&apos;,GradientType(类型)=(0,1,2));
</code></pre><hr>
<p>常见的闭包：</p>
<pre><code>function wait(message) {
    setTimeout(function timer() {
        console.log(message);
    }, 1000);
}
wait(&apos;Hello closure&apos;);
</code></pre><p>只要使用了回调函数，实际上就是在使用闭包！</p>
<hr>
<p>模块有两个主要特征：</p>
<p>1.为创建内部作用域而调用了一个包装函数；</p>
<p>2.包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p>
<hr>
<p>CommonJS // module.exports  require 同步</p>
<p>cmd  // define (module.exports) require 异步</p>
<hr>
<pre><code>&lt;script&gt;标签
CommonJS
AMD(Asynchronous Module Definition)
CMD(Common Module Definition)
UMD(Universal Module Definition)
ES6模块
</code></pre><hr>
<pre><code>var request;
if (window.XMLHttpRequest) {
    request = new XMLHttpRequest();
} else {
    request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
}
</code></pre><p>通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。</p>
<hr>
<p>字符串方法</p>
<p>ES7提案</p>
<p>要安装补丁库</p>
<pre><code>npm install babel-polyfill --save-dev
</code></pre><hr>
<p>es6标签模板</p>
<p>常用场景：防止XS攻击</p>
<p>多语言转换</p>
<pre><code>{
    let user={
        name: &apos;list&apos;,
        info: &apos;hello world&apos;
    };
    console.log(abc`i am ${user.name},${user.info}`);
    function abc(s,v1,v2){
        console.log(s,v1,v2);
        return s+v1+v2
    }
}
</code></pre><hr>
<p>ES6遍历字符串</p>
<p>let of</p>
<p>可以遍历字节大于两位的字符串</p>
<p>padStart</p>
<p>padEnd</p>
<p>可以用来在1前后加零</p>
<hr>
<pre><code>Array.from([1,3,5],function(item){return item*2});

function(item){return item*2} 相当于map映射
</code></pre><hr>
<p>includes对比find和findIndex对NaN处理不会报错</p>
<p>并且能找NaN</p>
<pre><code>[1,2,NaN].includes(NaN) ===&gt; true
</code></pre><hr>
<pre><code>{
    let x=&apos;test&apos;;
    function test2(x,y=x){
        console.log(&apos;作用域&apos;，x,y);
        //  kill kill
    }
    test2(&apos;kill&apos;);
}
</code></pre><hr>
<p>es6尾调用：函数的最后是不是一个函数</p>
<pre><code>function tail(x){
    console.log(&apos;tail&apos;,x);
}
function fx(x){
    return tail(x)
}
fx(123)
</code></pre><p>嵌套函数，依赖函数使用尾调用</p>
<hr>
<p><strong>es6属性表达式</strong></p>
<p>key值因为另一个变量而变化</p>
<pre><code>{
    let a=&apos;b&apos;;
    let es5_obj={
        a:&apos;c&apos;,
        b:&apos;c&apos;
    };

    let es6_obj={
        [a]:&apos;c&apos;
    }

    console.log(es5_obj,es6_obj);
}
</code></pre><hr>
<p>es对象</p>
<pre><code>Object.assign()属于浅拷贝

只拷贝自身对象的属性

不拷贝继承的属性和对象中不可枚举的属性
</code></pre><hr>
<p>es Symbol用法</p>
<pre><code>{
    let a1=Symbol.for(&apos;abc&apos;);
    let obj={
        [a1]:&apos;123&apos;,
        &apos;abc&apos;:345,
        &apos;c&apos;:456
    }
}
</code></pre><p>但for ..in..和let …of…拿不到Symbol值的</p>
<p>要用</p>
<pre><code>Object.getOwnPropertySymbols(obj).forEach(function(item){
    console.log(obj[item]);
})
</code></pre><p>两边都取到</p>
<pre><code>Reflect.ownKeys(obj).forEach(function(item){
    console.log(&apos;ownkeys&apos;,item,obj[item]);
})
</code></pre><hr>
<p>ES6Map</p>
<pre><code>Map是对Object的补充，key值可以是任意类型
</code></pre><hr>
<p>ES6Set</p>
<p>去重效果</p>
<pre><code>let arr=[1,2,3,1,&apos;2&apos;];
let list2=new Set(arr);

console.log(&apos;unique&apos;,list2);
</code></pre><p>但是Set在去重时不会转换数据类型。</p>
<hr>
<p>一、</p>
<pre><code>weakSet和Set支持的数据类型不一样

weakSet的元素只能是对象
</code></pre><p>二、</p>
<pre><code>weakSet的对象是弱引用

===》就是在其他地方有没有被引用过，不会跟垃圾回收机制挂钩上

weakSet添加了一个值只是对象的引用，不会整个值拷过来，是不是垃
圾回收掉，不会去检测
</code></pre><p>三、</p>
<pre><code>不能遍历
</code></pre><hr>
<p>es6 Map</p>
<pre><code>{
    let map = new Map();
    let arr=[&apos;123&apos;];

    map.set(arr,456);

    console.log(&apos;map&apos;,map,map.get(arr));
}

{
    let map = new Map([[&apos;a&apos;,123],[&apos;b&apos;,456]]);
    console.log(&apos;map args&apos;,map);
}
</code></pre><hr>
<h2 id="数组结构横向对比，增，查，改，删"><a href="#数组结构横向对比，增，查，改，删" class="headerlink" title="数组结构横向对比，增，查，改，删"></a>数组结构横向对比，增，查，改，删</h2><pre><code>{
    let map=new Map();
    let array=[];
    // 增
    map.set(&apos;t&apos;,1);
    array.push({t:1});

    console.info(&apos;map-array&apos;,map.array);

    // 查
    let map_exist=map.has(&apos;t&apos;);
    let array_ezist=array.find(item=&gt;item.t);
    console.info(&apos;map-array&apos;,map_exist,array_exist);

    //改
    map.set(&apos;t&apos;,2);
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;);
    console.info(&apos;map-array-modify&apos;,map,array);

    //删
    map.delete(&apos;t&apos;);
    let index = array.findIndex(item=&gt;item.t);
    array.splice(index,1);
}
</code></pre><hr>
<p><strong>Set和array的对比</strong></p>
<pre><code>{
    let set = new Set();
    let array=[];

    // 增
    set.add({t:1});
    array.push({t:1});

    console.log(&apos;set-array&apos;,set,array);

    // 查
    let set_exist=set.has({t:1}); 这里的{t:1}与增加时的不一样
    array同上

    // 改
    set.forEach(item=&gt;item.t?item.t=2:&apos;&apos;);
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;);

    // 删
    set.forEach(item=&gt;item.t?set.delete(item):&apos;&apos;);
    array同上
}
</code></pre><hr>
<h2 id="map-set-object对比"><a href="#map-set-object对比" class="headerlink" title="map,set,object对比"></a>map,set,object对比</h2><pre><code>{
    let item={t:1};
    let map = new Map();
    let set = new Set();
    let obj = {};

    // 增
    map.set(&apos;t&apos;,1);
    set.add(item);
    obj[&apos;t&apos;]=1;

    console.info(&apos;map-set-obj&apos;,obj,map,set);

    //查

    console.log({
        map_exist:map.has(&apos;t&apos;),
        set_exist:set.has(item),
        obj_exist: &apos;t&apos; in obj
    })

    // 改
    map.set(&apos;t&apos;,2);
    item.t=2;
    obj[&apos;t&apos;]=2;

    //删除
    map.delete(&apos;t&apos;);
    set.delete(item);
    delete obj[&apos;t&apos;];

}
</code></pre><hr>
<p>Proxy可以认为是代理或拦截</p>
<pre><code>{
    let obj={
        time:&apos;2017-03-11&apos;;
        name:&apos;net&apos;,
        _r:123
    };

    let monitor=new Proxy(obj,{
        // 拦截对象属性的读取
        get(target,key){
            return target[key].replace(&apos;2017&apos;,&apos;2018&apos;)
        }
        // 拦截对象设置属性
        set(target,key,value){
            if(key===&apos;name&apos;){
                return target[key]=value;
            } else {
                return target[key];
            }
        }
        // 拦截key in object操作
        has(target,key){
            if(key===&apos;name&apos;){
                return target[key]
            } else {
                return false;
            }
        }
        // 拦截delete
        deleteProperty(target,key){
            if(key.indexOf(&apos;_&apos;)&gt;-1){
                delete target[key];
                return true;
            }else {
                return target[key]
            }
        }
        // 拦截Object.keys,Object.getOwnPropertySymbols,
        Object.getOwnPropertyNames

        ownKeys(target){
            return Object.keys(target).filter
            (item=&gt;item!=&apos;time&apos;)
        }
    });

    console.log(&apos;get&apos;,monitor.time); // 2018

    monitor.time=&apos;2018&apos;;
    monitor.name=&apos;mukewang&apos;;
    console.log(&apos;set&apos;,monitor.time,mointor);
    // set 2018-03-11
       Proxy{time: &quot;2017-03-11&quot;, name: &quot;mukewang&quot;, _r: 123}

    console.log(&apos;has&apos;, &apos;name&apos; in monitor,&apos;time&apos; in 
    monitor);
    // has true false

    delete monitor.time;
    console.log(&apos;delete&apos;,monitor);
    // delete
       Proxy{time: &quot;2017-03-11&quot;, name: &quot;mukewang&quot;, _r: 123}

    delete monitor._r;
    console.log(&apos;delete&apos;,monitor);
    // delete
       Proxy{time: &quot;2017-03-11&quot;, name: &quot;mukewang&quot;}

    console.log(&apos;ownKeys&apos;,Object.keys(monitor));
    // ownKeys[&quot;name&quot;,&quot;_r&quot;]

}
</code></pre><hr>
<p>Reflect用途</p>
<pre><code>obj同上
Reflect.get(obj,&apos;time&apos;);

Reflect.set(obj,&apos;name&apos;,&apos;mukewang&apos;);

Reflect.has(obj,&apos;name&apos;);
</code></pre><hr>
<p>Proxy和Reflect一起的实例用途</p>
<pre><code>{
    function validator(target,validator){
        return new Proxy(target,{
            _validator:validator,
            set(target,key,value,proxy){
                if(target.hasOwnProperty(key)){
                    let va=this._validator[key];
                    if(!!va(value)){
                        return Reflect.set
                        (target,key,value,proxy)
                    }else{
                        throw Error(`不能设置${key}到
                        ${value}`)
                    }
                }else{
                    throw Error(`${key} 不存在`)
                }
            }
        })
    }

    const personValidators={
        name(val){
            return typeof val===&apos;string&apos;
        },
        age(val){
            return typeof val===&apos;number&apos; &amp;&amp; val&gt;18
        }
    }

    class Person{
        constructor(name,age){
            this.name=name;
            this.age=age;
            return validator(this,personValidators)
        }
    }

    const person=new Person(&apos;lilei&apos;,30);

    console.log(person);
    // Proxy {name: &quot;lilei&quot;, age: 30}

    person.name=48;
    // 报错 不能设置name到48
}
</code></pre><p>// 应用==》校验可以加在personValidators中</p>
<hr>
<p>在类的继承中如果用super传递参数super函数放在函数的第一行</p>
<p>静态方法通过类去调用而不是通过类的实例去调用</p>
<hr>
<pre><code>{
    let ajax=function(callback){
        相当于执行完ajax执行callback
        即callback相当于回调
    };
}

{
    // 基本定义
    let ajax = function(callback) {
        console.log(&apos;执行&apos;);
        setTimeout(function() {
            callback &amp;&amp; callback.call()
        }, 1000);
    };
    ajax(function() {
        console.log(&apos;timeout1&apos;);
    })
}
</code></pre><hr>
<p>iterator在数组中的应用</p>
<pre><code>{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  let map=arr[Symbol.iterator]();
  console.log(map.next());
  console.log(map.next());
  console.log(map.next());
}

{value: &quot;hello&quot;, done: false}
{value: &quot;world&quot;, done: false}
{value: undefined, done: true}
</code></pre><p>Object没有iterator接口，因为它的数据是我们填充的，不知道里面的数据需要怎么遍历</p>
<pre><code>{
    let obj = {
        start: [1, 3, 2],
        end: [7, 9, 8],
        [Symbol.iterator]() {
            let self = this;
            let index = 0;
            let arr = self.start.concat(self.end);
            let len = arr.length;
            return {
                next() {
                    if (index &lt; len) {
                        return {
                            value: arr[index++],
                            done: false
                        }
                    } else {
                        return {
                            value: arr[index++],
                            done: true
                        }
                    }
                }
            }
        }
    }
    for (const key of obj) {
        console.log(key);
        // 1 3 4  7 9 8
    }
}
</code></pre><p>注意一、</p>
<pre><code>不管什么样的数据结构，可能简单或复杂
自定义部署要按照以上步骤

要返回next()方法
</code></pre><hr>
<p>Generator函数和iterator接口的关系</p>
<p>任意一个对象或接口都是部署在Symbol.iterator属性上的</p>
<p>generator就是一个遍历器生成函数</p>
<p>状态机</p>
<pre><code>{
    let state = function*() {
        while (1) {
            yield &apos;A&apos;;
            yield &apos;B&apos;;
            yield &apos;C&apos;;
        }
    }
    let status = state();
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());    
    // 循环打印
}
</code></pre><p>async和await是generator的语法糖</p>
<pre><code>{
    let state = async function() {
        while (1) {
            await &apos;A&apos;;
            await &apos;B&apos;;
            await &apos;C&apos;;
        }
    }
    let status = state();
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());
}
</code></pre><p>实例抽奖</p>
<pre><code>{
    let draw = function(count) {
        // 具体抽奖逻辑
        console.log(`剩余${count}次`)
    }

    let residue = function*(count) {
        while (count &gt; 0) {
            count--;
            yield draw(count);
        }
    }

    let star = residue(5);
    let btn = document.createElement(&apos;button&apos;);
    btn.id = &apos;start&apos;;
    btn.textContent = &apos;抽奖&apos;;
    document.body.appendChild(btn);
    document.getElementById(&apos;start&apos;).addEventListener
    (&apos;click&apos;, function() {
        star.next();
    }, false)
}
</code></pre><p>// 关于长轮询(服务端的某一个状态不断变化，需要定时取状态，因为HTTP是无状态的连接)</p>
<p>怎么取到状态一个是长轮询，另一个是websocket但websocket浏览器兼容性不好</p>
<p>长轮询就是通过定时器不断的访问一个接口</p>
<pre><code>{
    // 长轮询
    let ajax = function*() {
        yield new Promise(function(resolve, reject) {
            // 模拟http请求
            setTimeout(function() {
                resolve({ code: 0 })
            }, 200)
        })
    }

    let pull = function() {
        let generator = ajax();
        let step = generator.next();
        step.value.then(function(d) {
            if (d.code != 0) {
                setTimeout(function() {
                    console.log(&apos;wait&apos;);
                    pull()
                }, 1000);
            } else {
                console.log(d);
            }
        })
    }

    pull();
}
</code></pre><hr>
<p>修饰器三点</p>
<ol>
<li>修饰器是一个函数</li>
<li>修改行为</li>
<li>修改类的行为</li>
</ol>
<p>实例-广告插点</p>
<pre><code>{
    let log = (type) =&gt; {
        return function(target, name, descriptor) {
            let src_method = descriptor.value;
            descriptor.value = (...arg) =&gt; {
                src_method.apply(target, arg);
                console.log(`log ${type}`);
            }
        }
    }

    class AD {
        @log(&apos;show&apos;)
        show() {
            console.log(&apos;ad is show&apos;);
        }
        @log(&apos;click&apos;)
        click() {
            console.log(&apos;ad is click&apos;);
        }
    }

    let ad = new AD();
    ad.show();
    ad.click();
}
</code></pre><hr>
<p>箭头函数的this指向是定义时的指向，而不是运行时的指向</p>
<p>闭包是函数和声明该函数的词法环境的组合。<br><strong>这个环境包含了这个闭包创建时所能访问的所有局部变量。</strong></p>
<hr>
<p>hasOwnProperty 是 JavaScript 中处理属性并且不会遍历原型链的方法之一。(另一种方法: Object.keys())</p>
<p>注意：检查属性是否undefined还不够。该属性可能存在，但其值恰好设置为undefined。</p>
<hr>
<p>当你执行：</p>
<pre><code>var o = new Foo();
</code></pre><p>JavaScript实际上执行的是：</p>
<pre><code>var o = new Object();
o._proto_ = Foo.prototype;
Foo.call(o);
</code></pre><p>当你执行：</p>
<pre><code>o.someProp;
</code></pre><p>===&gt;</p>
<pre><code>Object.getPrototypeOf(o).someProp
Object.getPrototypeOf(Object.getPrototypeOf(o)).someprop
</code></pre><hr>
<p>call()方法调用一个函数，其具有一个指定的this值和分别地提供的参数（参数的列表）</p>
<p>返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。</p>
<hr>
<p>§401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</p>
<p>§403 Forbidden - [*] 表示用户得到授权（与 401 错误相对），但是访问是被<br>禁止的。</p>
<hr>
<p>使用es6注意事项</p>
<p>使用严格模式，注意作用域</p>
<p>使用类与对象，结合模块化构建中大型项目</p>
<p>使用Promise替换传统的回调函数</p>
<p>使用箭头函数要注意this的指向</p>
<p>学会使用Generator完成异步操作应用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/学习Javascript闭包-Closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/学习Javascript闭包-Closure/" itemprop="url">学习Javascript闭包(Closure)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:46:53+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习Javascript闭包（Closure）"><a href="#学习Javascript闭包（Closure）" class="headerlink" title="学习Javascript闭包（Closure）"></a>学习Javascript闭包（Closure）</h1><p>闭包（closure）是JavaScript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<h2 id="一、变量的作用域"><a href="#一、变量的作用域" class="headerlink" title="一、变量的作用域"></a>一、变量的作用域</h2><p>要理解闭包，首先必须理解JavaScript特许的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>JavaScript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<pre><code>var n = 999;
function f1() {
    alert(n);
}

f1(); // 999
</code></pre><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<pre><code>function f1() {
    var n = 999;
}

alert(n); // error
</code></pre><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<h2 id="二、如何从外部读取局部变量？"><a href="#二、如何从外部读取局部变量？" class="headerlink" title="二、如何从外部读取局部变量？"></a>二、如何从外部读取局部变量？</h2><p>处于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<pre><code>function f1() {
    var n =999;
    function f2() {
        alert(n); // 999
    }
}
</code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<pre><code>function f1(){
    var n =999;
    function f2(){
        alert(n);
    }
    return f2;
}

var result=f1();
result(); // 999
</code></pre><h2 id="三、闭包的概念"><a href="#三、闭包的概念" class="headerlink" title="三、闭包的概念"></a>三、闭包的概念</h2><p>上一节代码中的f2函数，就是闭包。</p>
<p>各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="四、闭包的用途"><a href="#四、闭包的用途" class="headerlink" title="四、闭包的用途"></a>四、闭包的用途</h2><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解这句话呢？请看下面的代码。</p>
<pre><code>function f1(){
    var n =999;
    nAdd=function(){n+=1}
    function f2(){
        alert(n);
    }
    return f2;
}
var result = f1();
result(); // 999
nAdd();
result(); // 1000
</code></pre><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000.这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function）,而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h2 id="五、使用闭包的注意点"><a href="#五、使用闭包的注意点" class="headerlink" title="五、使用闭包的注意点"></a>五、使用闭包的注意点</h2><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h2 id="六、思考题"><a href="#六、思考题" class="headerlink" title="六、思考题"></a>六、思考题</h2><p>如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。</p>
<p>代码片段一。</p>
<pre><code>var name = &quot;The Window&quot;;
var object = {
    name: &quot;My Object&quot;,
    getNameFunc:function(){
        return function(){
            return this.name;
        };
    }
};

alert(object.getNameFunc()());
</code></pre><p>代码片段二。</p>
<pre><code>var name = &apos;The Window&apos;;
var object = {
    name: &apos;My Object&apos;,
    getNameFunc:function(){
        var that = this;
        return function(){
            return that.name;
        };
    }
};
alert(object.getNameFunc()());
</code></pre><p>JavaScript 本质上是原型的，除了null和之外，几乎所有语言undefined都是objects。当试图访问某个属性时object，解释器会尝试通过查找该属性的存在来解决它object。如果它找不到属性，它将继续查找原型链，这是一个继承的对象链，直到它找到属性，或遍历到链的末尾。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/同步和异步请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/同步和异步请求/" itemprop="url">同步和异步请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:46:20+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="同步和异步请求"><a href="#同步和异步请求" class="headerlink" title="同步和异步请求"></a><strong>同步和异步请求</strong></h1><p>XMLHttpRequest支持同步和异步通信。但是，一般来说，由于性能原因，异步请求应优先于同步请求。</p>
<p>同步请求阻止代码的执行，这会导致屏幕上出现“冻结”和无响应的用户体验。</p>
<p><strong>异步请求</strong></p>
<p>如果你在扩展中使用XMLHttpRequest。则你应该使用异步模式的请求。使用异步模式的话，当数据完全请求回来以后，会执行一个指定的回调函数，在执行请求的同时浏览器会正常的执行其他事务的处理。</p>
<p><strong>同步请求</strong></p>
<p>同步XHR通常会导致网络挂起。但开发人员通常不会注意到这个问题，因为在网络状况不佳或服务器响应速度慢的情况下，挂起只会显示同步XHR现在处于启用状态。建议开发人员远离这个API。</p>
<p>同步XHR不允许所有新的XHR功能（如timeout或abort）。这样做会调用InvalidAccessError。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/前端跨域的几种解决方式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/前端跨域的几种解决方式总结/" itemprop="url">前端跨域的几种解决方式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:45:41+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>JavaScript的同源策略，是由Netscape提出的一个著名的安全策略，为了阻止A站的JS去操作别的网站的数据。你想啊，你现在打开了浏览器，在一个tab窗口中打开了银行网站，在另外一个tab窗口中打开了一个恶意网站，而那个恶意网站挂了一个专门修改银行信息的JavaScript，当你访问这个恶意网站并且执行它JavaScript时，你的银行页面就会被这个JavaScript修改（比如说获取你的卡号和密码，又或者是转账到黑客的账户上等等），后果会非常严重！而同源策略就为了防止这种事情发生，它规定了A网站下的JS文件只能操作A网站下的数据，不能去操作B网站的数据。</p>
<p>为了方便理解，我们把这个词拆分成同源和策略这2个词吧。</p>
<p>所谓同源指的就是资源是来自同一个源的。如果两个页面拥有相同的协议，端口号，和主机（包括子域名和主域名），那么这两个页面就属于同一个源。</p>
<p>所谓策略指的是可以做什么事情。同一个源下的JS可以操作同一个源下的数据。</p>
<p>举个例子来看看你理解了没有吧，看下面这个链接，协议是http协议，主机是store.company.com，端口号一般默认的都是80了。然后和下面的这个表中的各个URL进行比较，判断一下那些是同源的，那些是不同源。</p>
<h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ol>
<li><a href="http://store.company.com/dir2/other.html" target="_blank" rel="noopener">http://store.company.com/dir2/other.html</a></li>
<li><a href="http://store.company.com/dir/inner/another.html" target="_blank" rel="noopener">http://store.company.com/dir/inner/another.html</a></li>
<li><a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a></li>
<li><a href="http://store.company.com:81/dir/etc.html" target="_blank" rel="noopener">http://store.company.com:81/dir/etc.html</a></li>
<li><a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a></li>
</ol>
<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>跨域</p>
<pre><code>跨域
</code></pre><ul>
<li>一个域名地址的组成：</li>
</ul>
<p><a href="http://www.abc.com:8080/scripts/jquery.js" target="_blank" rel="noopener">http://www.abc.com:8080/scripts/jquery.js</a></p>
<p>  <code>http://</code>      <code>协议</code> </p>
<p>  <code>www</code>  <code>子域名</code> </p>
<p>  <code>.</code>  </p>
<p>  <code>abc.com</code> <code>主域名</code> </p>
<p>  <code>:</code>  </p>
<p>  <code>8080</code> <code>端口号</code>  </p>
<p>  <code>/</code> </p>
<p>  <code>scripts/jquery.js</code>  <code>请求资源地</code></p>
<ul>
<li><p>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。</p>
</li>
<li><p>不同域之间相互请求资源，就算作“跨域”</p>
<p>比如：<a href="http://www.abc.com/index.html" target="_blank" rel="noopener">http://www.abc.com/index.html</a> 请求 <a href="http://www.efg.com/service.php" target="_blank" rel="noopener">http://www.efg.com/service.php</a></p>
</li>
</ul>
<p>跨域的解决方案</p>
<p><strong>方案1 - JSONP</strong></p>
<p>JSONP是JSON with padding的简写。JSONP由两部分组成：回调函数和数据。</p>
<p>回调函数是客户端和服务端约定好一个函数名，一般在请求中指定。</p>
<p>数据是传入回调函数中的JSON数据。</p>
<p>JSONP是通过动态的</p>
<p>callback({“name”: “michael”});</p>
<p>问题一：JSONP是需要动态创建script标签的，我们需不需要处理这些script元素？怎么处理？</p>
<p>问题二：JSONP请求的时候，服务器发生错误该怎么办，比如服务器崩掉，比如返回了404页面，前端该怎么处理这个错误，难道直接让它抛出么？</p>
<p>答案</p>
<p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求</p>
<p>JSONP的兼容性好，不需要XMLHttpRequest的支持</p>
<p><strong>方案2 - 跨域资源共享CORS</strong></p>
<p>跨域资源共享定义了在必须访问跨域资源的时，浏览器与服务器应该如何沟通。他的原理是使用自定义的HTTP头部，让服务器与浏览器进行沟通，主要是通过设置响应头的Access-Control-Allow-Origin来达到目的的。</p>
<p>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域HTTP请求。</p>
<p>比如，站点<a href="http://domain-a.com的某HTML页面通过" target="_blank" rel="noopener">http://domain-a.com的某HTML页面通过</a><img>的src请求<a href="http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。" target="_blank" rel="noopener">http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。</a></p>
<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。例如，XMLHttpRequest和Fetch API遵循同源策略。这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件</p>
<p>跨域资源共享(CORS)机制允许Web应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在API容器中（例如XMLHttpRequest或Fetch）使用CORS，以降低跨域HTTP请求所带来的风险。</p>
<p>跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明那些源站有权限访问那些资源。另外，规范要求，对那些可能对服务器数据产生副作用的HTTP请求方法（特别是GET以外的HTTP请求，或者搭配某些MIME类型的POST请求），浏览器必须首先使用OPTIONS方法发起一个预检请求（preflight request）,从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括Cookies和HTTP认证相关数据）。</p>
<p><strong>方案3-documnet.domain</strong></p>
<p>浏览器的同源策略使得不同域的框架是不能进行JS的交互操作的。比如：有一个页面是<a href="http://www.examples.com/a.htmls，在这个页面中还有一个http://examples.com/b.htmls，很显然，a.html与b.html是不同域的，所以我们无法通过在页面中书写js代码来获取iframe中的东西，但是，如果我们把这2个页面的document.domain都设置成相同的域名就可以了，需要注意的是，我们只能把document.domain设置成自身或更高一级的父域，且主域名必须相同。" target="_blank" rel="noopener">http://www.examples.com/a.htmls，在这个页面中还有一个http://examples.com/b.htmls，很显然，a.html与b.html是不同域的，所以我们无法通过在页面中书写js代码来获取iframe中的东西，但是，如果我们把这2个页面的document.domain都设置成相同的域名就可以了，需要注意的是，我们只能把document.domain设置成自身或更高一级的父域，且主域名必须相同。</a></p>
<p>使用条件</p>
<p>document.domain适用于不同子域的框架之间的交互。</p>
<p><strong>方案4-window.name</strong></p>
<p>window对象有个name属性，该属性有一个特征：即在一个窗口的生命周期内，窗口载入的所有页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p>
<p>方案5-window.postMessage</p>
<p>window.postMessage（message,targetOrigin）方法，可以用来向其他的window对象发送消息，无论这个window对象是属于同一个源还是不同源</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/浏览器数据库-IndexedDB-入门教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/浏览器数据库-IndexedDB-入门教程/" itemprop="url">浏览器数据库 IndexedDB 入门教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:44:59+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器数据库-IndexedDB-入门教程"><a href="#浏览器数据库-IndexedDB-入门教程" class="headerlink" title="浏览器数据库 IndexedDB 入门教程"></a>浏览器数据库 IndexedDB 入门教程</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据存储在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据存储方案，都不适合存储大量数据：Cookie的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage在2.5MB到10MB之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是IndexedDB诞生的背景。</p>
<p>通俗地说，IndexedDB就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB允许存储大量数据，提供查找接口，还能建立索引。这些都是LocalStorage所不具备的。就数据库类型而言，IndexedDB不属于关系型数据库（不支持SQL查询语句），更接近NoSQL数据库。</p>
<p>IndexedDB具有以下特点。</p>
<p>（1）键值对存储。IndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p>（2）异步。IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形式对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p>（3）支持事务。IndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p>（4）同源限制IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p>（5）存储空间大IndexedDB的存储空间比LocalStorage大得多，一般来说不少于250MB，甚至没有上限。</p>
<p>（6）支持二进制存储。IndexedDB不仅可以存储字符串，还可以存储二进制数据（ArrayBuffer对象和Blob对象）。</p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>IndexedDB是一个比较复杂的API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个API，就是学习它的各种对象接口。</p>
<ul>
<li>数据库：IDBDatabase对象</li>
<li>对象仓库：IDBObjectStore对象</li>
<li>索引：IDBIdex对象</li>
<li>事务：IDBTransaction对象</li>
<li>操作请求：IDBRequest对象</li>
<li>指针：IDBCursor对象</li>
<li>主键集合：IDBKeyRange对象</li>
</ul>
<p>下面是一些主要的概念。</p>
<p>（1）数据库</p>
<p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<p>（2）对象仓库</p>
<p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<p>（3）数据记录</p>
<p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>
<pre><code>{ id: 1, text: &apos;foo&apos;}
</code></pre><p>上面的对象中，id属性可以当作主键。</p>
<p>数据体可以是任意数据类型，不限于对象。</p>
<p>（4）索引</p>
<p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<p>（5）事务</p>
<p>数据记录的读写和删改，都要通过事务完成。事务对象提供error、abort和complete三个事件，用来监听操作结果。</p>
<h2 id="三、操作流程"><a href="#三、操作流程" class="headerlink" title="三、操作流程"></a>三、操作流程</h2><p>IndexedDB数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，同于快速上手，详细的各个对象的API请看这里。</p>
<p>3.1 打开数据库</p>
<p>使用IndexedDB的第一步是打开数据库，使用indexedDB.open()方法。</p>
<pre><code>var request = window.indexedDB.open(databaseName, version);
</code></pre><p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为1。</p>
<p>indexedDB.open()方法返回一个IDBRequest对象。这个对象通过三种事件error、success、upgradededed，处理打开数据库的操作结果。</p>
<p>（1）error事件</p>
<p>error事件表示打开数据库失败。</p>
<pre><code>request.onerror = function(event) {
    console.log(&apos;数据库打开报错&apos;);
}
</code></pre><p>（2）success事件</p>
<p>success事件表示成功打开数据库。</p>
<pre><code>var db;

request.onsuccess = function (event) {
    db = request.result;
    console.log(&apos;数据库打开成功&apos;);
}
</code></pre><p>这时，通过request对象的result属性拿到数据库对象。</p>
<p>（3）upgradeneeded事件</p>
<p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradedeeded。</p>
<pre><code>var db;

request.onupgradeneeded = function (event) {
    db = event.target.result;
}
</code></pre><p>这时通过事件对象的target.result属性，拿到数据库实例。</p>
<p>3.2 新建数据库</p>
<p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<pre><code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore(&apos;person&apos;, 
  {keyPath: &apos;id&apos;});
}
</code></pre><p>上面代码中，数据库新建成功以后，新增一张叫做person的表格，主键是id。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<pre><code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore;
  if (!db.objectStoreNames.contains(&apos;person&apos;)) {
    objectStore = db.createObjectStore(&apos;person&apos;, 
    {keyPath: &apos;id&apos;});
  }
}
</code></pre><p>主键（key）是默认建立索引的属性。比如，数据记录是{id: 1, name: ‘张三’}，那么id属性可以作为主键。主键也可以指定为下一层对象的属性，比如{foo: {bar: ‘baz’}}的foo.bar也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让IndexedDB自动生成主键。</p>
<pre><code>var objectStore = db.createObjectStore (
  &apos;person&apos;,
  { autoIncrement: true }
)
</code></pre><p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<pre><code>request.onuogradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore(&apos;person&apos;, 
{keyPath: &apos;id&apos;});
  objectStore.createIndex(&apos;name&apos;, &apos;name&apos;, {unique:
 false});
  objectStore.createIndex(&apos;email&apos;, &apos;email&apos;, {unique: 
true});
}
</code></pre><p>上面代码中，IDBObject.createIndex()的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<p>3-3 新增数据</p>
<p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<pre><code>function add() {
  var request = db.transaction([&apos;person&apos;], 
&apos;readwrite&apos;)
  .objectStore(&apos;person&apos;)
  .add({id: 1, name: &apos;张三&apos;, age: 24, email: 
&apos;zhangsan@example.com&apos;});

  request.onsuccess = function (event) {
    console.log(&apos;数据写入成功&apos;);
  }

  request.onerror = function (event) {
    console.log(&apos;数据写入失败&apos;);
  }
}

add();
</code></pre><p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过IDBTransaction.objectStore(name)方法，拿到IDBObjectStore对象，再通过表格对象的add()方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的success事件如error事件，了解是否写入成功。</p>
<p>3.4 读取数据</p>
<p>读取数据也是通过事务完成。</p>
<pre><code>function read() {
  var transaction = db.transaction([&apos;person&apos;]);
  var objectStore = transaction.objectStore(&apos;person&apos;);
  var request = objectStore.get(1);

  request.onerror = function(event) {
    console.log(&apos;事务失败&apos;);
  }

  request.onsuccess = function(event) {
    if(request.result) {
      console.log(&apos;Name：&apos; + request.result.name);
      console.log(&apos;Age：&apos; + request.result.age);
      console.log(&apos;Email：&apos; + request.result.email);
    } else {
      console.log(&apos;未获得数据记录&apos;);
    }
  };
}

read();
</code></pre><p>上面代码中，objectStore.get()方法用于读取数据，参数是主键的值。</p>
<p>3.5 遍历数据</p>
<p>遍历数据表格的所有记录，要使用指针对象IDBCursor。</p>
<pre><code>function readAll() {
  var objectStore = db.transaction
(&apos;person&apos;).objectStore(&apos;person&apos;);

  objectStore.openCursor().onsuccess = function(event) {
    var cursor = event.target.result;

    if(cursor) {
      console.log(&apos;Id：&apos; + cursor.key);
      console.log(&apos;Name：&apos; + cursor.value.name);
      console.log(&apos;Age：&apos; + cursor.value.age);
      console.log(&apos;Email：&apos; + cursor.value.email);
      cursor.continue();
    } else {
      console.log(&apos;没有更多数据了！&apos;);
    }
  }
}

readAll();
</code></pre><p>上面代码中，新建指针对象的openCursor()方法是一个异步操作，所以要监听success事件。</p>
<p>3.6 更新数据</p>
<p>更新数据要使用IDBObject.put()方法。</p>
<pre><code>function update() {
  var request = db.transaction([&apos;person&apos;], &apos;readwrite&apos;)
  .objectStore(&apos;person&apos;)
  .put({id: 1, name: &apos;李四&apos;, age: 35, eamil: 
&apos;lisi@example.com&apos;});

  request.onsuccess = function (event) {
    console.log(&apos;数据更新成功&apos;);
  };

  request.onerror = function (event) {
    console.log(&apos;数据更新失败&apos;);
  }
}

update();
</code></pre><p>上面代码中，put()方法自动更新了主键为1的记录。</p>
<p>3.7 删除数据</p>
<p>IDBObjectStore.delete()方法用于删除记录。</p>
<pre><code>function remove() {
  var request = db.transaction([&apos;person&apos;], &apos;readwrite&apos;)
  .objectStore(&apos;person&apos;)
  .delete(1);

  request.onsuccess = function (event) {
    cosole.log(&apos;数据删除成功&apos;);
  };
}

remove();
</code></pre><p>3.8 使用索引</p>
<p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取消）。</p>
<p>假定新建表格的时候，对name字段建立了索引。</p>
<pre><code>objectStore.createIndex(&apos;name&apos;, &apos;name&apos; { unique: false});
</code></pre><p>现在，就可以从name找到对应的数据记录了。</p>
<pre><code>var transaction = db.transaction([&apos;person&apos;], 
&apos;readonly&apos;);
var store = transaction.objectStore(&apos;person&apos;);
var index = store.index(&apos;name&apos;);
var request = index.get(&apos;李四&apos;);

request.onsuccess = function(e) {
  var result = e.target.result;
  if (result) {
    // ...
  } else {
    // ...
  }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/理解JavaScript函数调用和this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/理解JavaScript函数调用和this/" itemprop="url">理解JavaScript函数调用和this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:44:25+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>多年来，我看到很多关于JavaScript函数调用的混淆。特别是，很多人抱怨this函数的语义令人困惑。</p>
<p>在我看来，通过理解核心函数调用原语，然后查看在该原语之上调用函数作为</p>
<h1 id="this和箭头函数"><a href="#this和箭头函数" class="headerlink" title="this和箭头函数"></a>this和箭头函数</h1><p><strong>箭头函数能保存函数创建时的 this值，而不是调用时的值</strong></p>
<p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了–noImplicitThis标记。 它会指出 this.suits[pickedSuit]里的this的类型为any。</p>
<p><strong>到目前为止，我们已经将对象称为简单的键和值对。实际上，JavaScript对象还有一个附加属性：指向另一个对象的指针。我们将此指针称为对象的原型。如果您尝试在对象上查找某个键并且找不到它，JavaScript将在原型中查找它。它将遵循“原型链”，直到它看到一个null值。在那种情况下，它返回undefined。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/开发流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/开发流程/" itemprop="url">开发流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:43:46+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/继承与原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/继承与原型链/" itemprop="url">继承与原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:43:05+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h1><p>对于有基于类的语言经验（如Java或C++）的开发人员来说，JavaScript有点令人困惑，因为它是动态的，并且本身不提供一个class实现。（在ES2015/ES6中引入了class关键字，但只是语法糖，JavaScript仍然是基于原型的）。</p>
<p><img src="https://user-images.githubusercontent.com/7291672/44759590-a0102e00-ab6d-11e8-9094-f6e35ed158b2.png" alt=""></p>
<p>当谈到继承时，JavaScript只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为<em>proto</em>）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象，层层向上直到一个对象的原型对象为null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。</p>
<p>几乎所有JavaScript中的对象都是位于原型链顶端的Object的实例。</p>
<p>尽管这种原型继承通常被认为是JavaScript的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。</p>
<h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><p>JavaScript对象是动态的属性“包”（指其自己的属性）。JavaScript对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>给对象设置属性会创建自有属性。获取和设置属性的唯一限制是内置getter或setter的属性。</p>
<h2 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h2><p>JavaScript并没有其他基于类的语言所定义的“方法”。在JavaScript里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，this指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/高性能JavaScript编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/高性能JavaScript编程/" itemprop="url">高性能JavaScript编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:42:23+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一章-Loading-and-Execution-加载和运行"><a href="#第一章-Loading-and-Execution-加载和运行" class="headerlink" title="第一章 Loading and Execution    加载和运行"></a>第一章 Loading and Execution    加载和运行</h2><p><strong>Script Positioning    脚本位置</strong></p>
<p><strong>Grouping Scripts    成组脚本</strong></p>
<p><strong>Nonvlocking Scripts 非阻塞脚本</strong></p>
<p>Deferred Scripts 延期脚本</p>
<pre><code>&lt;scripts type=&quot;text/javascript&quot; src=&quot;file1.js&quot; 
defer&gt;&lt;/script&gt;
</code></pre><p>Dynamic Script Elements 动态脚本元素</p>
<pre><code>var script = document.createElement(&quot;script&quot;);
script.type = &quot;text/javascript&quot;;
script.src = &quot;file1.js&quot;;
document.getElementByTagName_r(&quot;head&quot;)
[0].appendChild(script);
</code></pre><p>XMLHttpRequest Script Injection XHR 脚本注入</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&quot;get&quot;, &quot;file1.js&quot;, true);
xhr.onreadstatechange = function() {
    if(xhr.readState === 4) {
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 ||
             xhr.status == 304){
            var script = document.createElement
            (&quot;script&quot;);
            script.type = &quot;text/javascript&quot;;
            script.text = xhr.responseText;
            document.body.appendChild(script);
        }
    }
};
xhr.send(null);
</code></pre><p>Recommended Nonblocking Pattern 推荐的非阻塞模式</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;loader.js&quot;&gt;&lt;/
script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    loadScript(&quot;the-rest.js&quot;, function(){    
        Application.init();
    });
&lt;/script&gt;
</code></pre><p><strong>Summary    总结</strong></p>
<p>管理浏览器中的JavaScript代码是个棘手的问题，因为代码执行阻塞了其他浏览器处理过程，诸如用户界面绘制。每次遇到script标签，页面必须停下来等待代码下载（如果是外部的）并执行，然后再继续处理页面其他部分。但是，有几种方法可以减少JavaScript对性能的影响：</p>
<ul>
<li><p>将所有script标签放置在页面的底部，紧靠body关闭标签的上方。此法可以保证页面在脚本运行之前完成解析。</p>
</li>
<li><p>将脚本成组打包。页面的script标签越少，页面的加载速度就越快，响应也更加迅速。不论外部脚本文件还是内联代码都是如此。</p>
</li>
<li><p>有几种方法可以使用非阻塞方式下载JavaScript：</p>
</li>
</ul>
<ol>
<li><p>为script标签添加defer属性（只适用于Internet Explorer和Firefox 3.5 以上版本）</p>
</li>
<li><p>动态创建script元素，用它下载并执行代码</p>
</li>
<li><p>用XHR对象下载代码，并注入到页面中</p>
</li>
</ol>
<p>通过使用上述策略，你可以极大提高哪些大量使用JavaScript代码的网页应用的实际性能。</p>
<h2 id="第二章Data-Access-数据访问"><a href="#第二章Data-Access-数据访问" class="headerlink" title="第二章Data Access 数据访问"></a>第二章Data Access 数据访问</h2><p><strong>Managing Scope 管理作用域</strong></p>
<p>Scope Chains and Identifier Resolution 作用域链和标识符解析</p>
<p>每一个JavaScript函数都被表示为对象。进一步说，它是一个函数实例。函数对象正如其他对象那样，拥有你可以编程访问的属性，和一系列不能被程序访问，仅供JavaScript引擎使用的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义。</p>
<p><strong>Identifier Resolution Performance 标识符识别性能</strong></p>
<p><strong>Scope Chain Augmentation改变作用域链</strong></p>
<p><strong>Dynamic Scopes 动态作用域</strong></p>
<p><strong>Closures，Scope，and Memory 闭包，作用域，和内存</strong></p>
<p>闭包是JavaScript最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过Douglas Crockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。</p>
<p><strong>Object Members 对象成员</strong></p>
<p>大多数JavaScript代码以面向对象的形式编写。无论通过创建自定义对象还是使用内置的对象，诸如文档对象模型（DOM）和浏览器对象模型（BOM）之中的对象。因此，存在很多对象成员访问。</p>
<p><strong>Prototypes 原形</strong></p>
<p>JavaScript中的对象是基于原形得到。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。</p>
<p><strong>Prototype Chains 原型链</strong></p>
<p>对象的原形决定了一个实例的类型。默认情况下，所有对象都是Object的实例，并继承了所有基本方法，如toString()。你可以用“构造器”创建另外一种类型的原形。</p>
<p><strong>Nested Members 嵌套成员</strong></p>
<p><strong>Caching Object Member Values 缓存对象成员的值</strong></p>
<p><strong>Summary 总结</strong></p>
<p>在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数据项，对象成员。它们有不同的性能考虑。</p>
<ul>
<li>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。</li>
<li>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。</li>
<li>避免使用with表达式，因为它改变了运行期上下文的作用域链。而且应当小心对待try-catch表达式的catch子句，因为它具有同样效果。</li>
<li>嵌套对象成员会造成重大性能影响，尽量少用。</li>
<li>一个属性或方法在原型链中的位置越深，访问它的速度就越慢。</li>
<li>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。</li>
</ul>
<p>通过使用这些策略，你可以极大地提高哪些需要大量JavaScript代码的网页应用的实际性能。</p>
<h2 id="第三章-DOM-Scripting-DOM编程"><a href="#第三章-DOM-Scripting-DOM编程" class="headerlink" title="第三章    DOM Scripting DOM编程"></a>第三章    DOM Scripting DOM编程</h2><p><strong>DOM in the Browser World 浏览器世界中的DOM</strong></p>
<p><strong>Inherently Slow 天生就慢</strong></p>
<p><strong>DOM Access and Modification DOM访问和修改</strong></p>
<p><strong>innerHTML Versus DOM methods innerHTML 与DOM方法比较</strong></p>
<p><strong>Cloning Nodes 节点克隆</strong></p>
<p><strong>HTML Collections HTML集合</strong></p>
<p><strong>Expensive collections 昂贵的集合</strong></p>
<p><strong>Local variables when accessing collection elements 访问集合元素时使用局部变量</strong></p>
<p><strong>Walking the DOM DOM漫谈</strong></p>
<p>Crawling the DOM 抓取DOM</p>
<p>Element nodes 元素节点</p>
<p>The Selectors API 选择器API</p>
<p><strong>Repaints and Reflows 重绘和重排版</strong></p>
<p><strong>When Does a Reflow Happen? 重排版时会发生什么？</strong></p>
<p><strong>Queuing and Flushing Render Tree Changes 查询并刷新渲染树改变</strong></p>
<p><strong>Minimizing Repaints and Reflows 最小化重绘和重排版</strong></p>
<p><strong>Style changes 改变风格</strong></p>
<p><strong>Batching DOM changes 批量修改DOM</strong></p>
<p><strong>Caching Layout Information 缓冲布局信息</strong></p>
<p><strong>Take Elements Out of the Flow for Animations 将元素提出动画流</strong></p>
<p><strong>IE和:hover</strong></p>
<p><strong>Event Delegation 事件托管</strong></p>
<p><strong>Summary 总结</strong></p>
<p>DOM访问和操作是现代网页应用中很重要的一部分。但每次你通过桥梁从ECMAScript岛到达DOM岛时，都会被收取“过桥费”。为减少DOM编程中的性能损失，请牢记以下几点：</p>
<ul>
<li>最小化DOM访问，在JavaScript端做尽可能多的事情。</li>
<li>在反复访问的地方使用局部变量存放DOM引用</li>
<li>小心地处理HTML集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的length属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。</li>
<li>如果可能的话，使用速度更快的API，诸如querySelectorAll()和firstElementChild。</li>
<li>注意重绘和重排版；批量修改风格，离线操作DOM树，缓存并减少对布局信息的访问。</li>
<li>动画中使用绝对坐标，使用拖放代理。</li>
<li>使用事件托管技术最小化事件句柄数量。</li>
</ul>
<h2 id="第四章-Algorithms-and-Flow-Control-算法和流程控制"><a href="#第四章-Algorithms-and-Flow-Control-算法和流程控制" class="headerlink" title="第四章 Algorithms and Flow Control 算法和流程控制"></a>第四章 Algorithms and Flow Control 算法和流程控制</h2><p><strong>Loops 循环</strong></p>
<p><strong>Types of Loops 循环的类型</strong></p>
<p><strong>Loop Performance 循环性能</strong></p>
<p><strong>Decreasing the work per iteration 减少迭代的工作量</strong></p>
<p><strong>Decreasing the number of iterations 减少迭代次数</strong></p>
<p><strong>Function-Based Iteration 基于函数的迭代</strong></p>
<p><strong>Conditionals 条件表达式</strong></p>
<p>if-else Versus switch     if-else与switch比较</p>
<p><strong>Optimizing if-else 优化if-else</strong></p>
<p><strong>Lookup Tables 查表法</strong></p>
<p><strong>Resursion 递归</strong></p>
<p>Call Stack Limits 调用栈限制</p>
<p><strong>Recursion Patterns 递归模式</strong></p>
<p><strong>Iteration 迭代</strong></p>
<p><strong>Memoization 制表</strong></p>
<p><strong>Summary 总结</strong></p>
<p>正如其他编程语言，代码的写法和算法选用影响JavaScript的运行时间。与其他编程语言不同的是，JavaScript可用资源有限，所以优化技术更为重要。</p>
<ul>
<li>for，while，do-while循环的性能特性相似，谁也不比谁更快或更慢。</li>
<li>除非你要迭代遍历一个属性未知的对象，否则不要使用for-in循环。</li>
<li>改善循环性能的更好办法是减少每次迭代中的运算量，并减少循环迭代次数。</li>
<li>一般来说，switch总是比if-else更快，但并不总是最好的解决方法。</li>
<li>当判断条件较多时，查表法比if-else或者switch更快。</li>
<li>浏览器的调用栈尺寸限制了递归算法在JavaScript中的应用；栈溢出错误导致其他代码也不能正常执行。</li>
<li>如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作。</li>
</ul>
<p>运行的代码总量越大，使用这些策略所带来的性能提升就越明显。</p>
<h2 id="第五章-Strings-and-Regular-Expressions-字符串和正则表达式"><a href="#第五章-Strings-and-Regular-Expressions-字符串和正则表达式" class="headerlink" title="第五章 Strings and Regular Expressions 字符串和正则表达式"></a>第五章 Strings and Regular Expressions 字符串和正则表达式</h2><p><strong>String Concatenation 字符串连接</strong></p>
<p>Plus(+) and Plus-Equals (+=) Operators 加和加等于操作</p>
<p>Firefox and compile-time folding Firefox和编译期合并</p>
<p>Array Joining 数组联结</p>
<p>String.prototype.concat</p>
<p><strong>Regular Expression Optimization 正则表达式优化</strong></p>
<p>How Regular Expression Work 正则表达式工作原理</p>
<p>Understanding Backtrack 理解回溯</p>
<p>Repetiton and backtracking 重复与回溯</p>
<p>Runaway Backtracking 回溯失控</p>
<p>The solution：Be specific    解决方法：具体化</p>
<p>Emulating atomic groups using lookahead and backreferences 使用前瞻和后向引用列举原子组</p>
<p>Nested quantifiers and runaway backtracking 嵌套量词和回溯失控</p>
<p>From bad to worse 从坏到更坏</p>
<p>A Note on Benchmarking 测试基准说明</p>
<p><strong>More Ways to Improve Regular Expression Efficiency 提高正则表达式效率的更多方法</strong></p>
<p><strong>When Not to Use Regular Expressions 什么时候不应该使用正则表达式</strong></p>
<p><strong>String Trimming 字符串修剪</strong></p>
<p><strong>Trimming with Regular Expressions 用正则表达式修剪</strong></p>
<p><strong>A Hybrid Solution 混合解决方案</strong></p>
<p><strong>Summary 总结</strong></p>
<ul>
<li>密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍，但本章中的建议可帮助您避免常见缺陷。</li>
<li>当连接数量巨大或尺寸巨大的字符串时，数组联合是IE7和它的早期版本上唯一具有合理性能的方法。</li>
<li>如果你不关心IE7和它的早期版本，数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之，可避免(产生)不必要的中间字符串。</li>
<li>回溯即是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因。</li>
<li>回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯。</li>
<li>提高正则表达式效率的各种技术手段，帮助正则表达式更快地找到匹配，以及在非匹配位置上花费更少时间（见《更多提高正则表达式效率的方法》）。</li>
<li>正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串时。</li>
<li>虽然有很多方法来修整一个字符串，使用两个简单的正则表达式（一个用于去除头部空格，另一个用于去除尾部空格）提供了一个简洁、跨浏览器的方法，适用于不同内容和长度的字符串。从字符串末尾开始循环查找第一个非空格字符，或者在一个混合应用中将此技术与正则表达式结合起来，提供了一个很好的替代方案，它很少受到字符串整体长度的影响。</li>
</ul>
<h2 id="第六章-Responsive-Interfaces-响应接口"><a href="#第六章-Responsive-Interfaces-响应接口" class="headerlink" title="第六章    Responsive Interfaces 响应接口"></a>第六章    Responsive Interfaces 响应接口</h2><p><strong>The Browser UI Thread    浏览器UI线程</strong></p>
<p><strong>Browser Limits    浏览器限制</strong></p>
<p><strong>How Long Is Too Long?    多久才算“太久”?</strong></p>
<p>更复杂的是有些浏览器在JavaScript 运行时不将UI 更新放入队列。例如，如果你在某些JavaScript 代码运行时点击按钮，浏览器可能不会将重绘按钮按下的UI 更新任务放入队列，也不会放入由这个按钮启动的JavaScript 任务。其结果是一个无响应的UI，表现为“挂起”或“冻结”。</p>
<p><strong>Yielding with Timers 用定时器让出时间片</strong></p>
<p>Timer Basics 定时器基础</p>
<p>Timer Precision 定时器精度</p>
<p><strong>Array Processing with Timers 在数组处理中使用定时器</strong></p>
<p><strong>Splitting Up Tasks 分解任务</strong></p>
<p>Timed Code 限时运行代码</p>
<p>Timers and Performance 定时器与性能</p>
<p><strong>Web Workers 网页工人线程</strong></p>
<p>Worker Environment 工人线程运行环境</p>
<p>Worker Communication 工人线程交互</p>
<p>Loading External Files 加载外部文件</p>
<p>Practical Users 实际用途</p>
<p><strong>Summary    总结</strong></p>
<p>JavaScript和用户界面更新在同一个进程内运行，同一时刻只有其中一个可以运行。这意味着当JavaScript代码正在运行时，用户界面不能响应输入，反之亦然。有效地管理UI线程就是要确保JavaScript不能运行太长时间，以免影响用户体验。最后，请牢记如下几点：</p>
<ul>
<li>JavaScript运行时间不应该超过100毫秒。过长的运行时间导致UI更新出现可察觉的延迟，从而对整体用户体验产生负面影响。</li>
<li>JavaScript运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript长时间运行将导致用户体验混乱和脱节。</li>
<li>定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务。</li>
<li>网页工人线程是新式浏览器才支持的特性，它允许你在UI线程之外运行JavaScript代码而避免锁定UI。</li>
</ul>
<p>网页应用程序越复杂，积极主动地管理UI线程就越显得重要。没有什么JavaScript代码可以重要到允许影响用户体验的程度。</p>
<h2 id="第七章-Ajax-异步JavaScript和XML"><a href="#第七章-Ajax-异步JavaScript和XML" class="headerlink" title="第七章    Ajax 异步JavaScript和XML"></a>第七章    Ajax 异步JavaScript和XML</h2><p>Ajax是高性能JavaScript的基石。它可以通过延迟下载大量资源使页面加载更快。它通过在客户端和服务器端之间异步传送数据，避免页面集体加载。它还用于在一次HTTP请求中获取整个页面的资源。通过选择正确的传输技术和最有效的数据格式，你可以显著改善用户与网站之间的互动。</p>
<p>本章考察从服务器收发数据最快的技术，以及最有效的数据编码格式。</p>
<p><strong>Data Transmission    数据传输</strong></p>
<p>Requesting Data 请求数据</p>
<p>XMLHttpRequest</p>
<p>POST versus GET when using XHR. 使用XHR时，应使用POST还是GET</p>
<p>Dynamic script tag insertion 动态脚本标签插入</p>
<p>Multipart XHR 多部分 XHR</p>
<p><strong>Sending Data 发送数据</strong></p>
<p>XMLHttpRequest</p>
<p>Beacons 灯标</p>
<p><strong>Data Formats 数据格式</strong></p>
<p>XML</p>
<p>XPath</p>
<p>Response sizes and parse times 响应报文大小和解析时间</p>
<p>JSON</p>
<p>JSON-P</p>
<p>Should you use JSON? 你应该使用JSON吗？</p>
<p>HTML</p>
<p>Custom Formatting 自定义格式</p>
<p><strong>Data Format Conclusions 数据格式总结</strong></p>
<p><strong>Ajax Performance Guidelines Ajax性能导向</strong></p>
<p>Cache Data 缓存数据</p>
<p>Setting HTTP headers 设置HTTP头</p>
<p>Storing data locally 本地存储数据</p>
<p><strong>Know the Limitations of Your Ajax Library 了解Ajax库的限制</strong></p>
<p><strong>Summary 总结</strong></p>
<p>高性能Ajax包括：知道你项目的具体需求，选择正确的数据格式和与之相配的传输技术。</p>
<p>作为数据格式，纯文本和HTML是高度限制的，但它们可节省客户端的CPU周期。XML被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON是轻量级的，解析迅速（作为本地代码而不是字符串），交互性与XML相当。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器端构造格式，并在客户端解析。</p>
<p>当从页面域请求数据时，XHR提供最完善的控制和灵活性，尽管它将所有传入数据视为一个字符串，这有可能降低解析速度。另一方面，动态脚本标签插入技术允许跨域请求和本地运行JavaScript和JSON，虽然它的接口不够安全，而且不能读取信息头或响应报文代码。多部分XHR可减少请求的数量，可在一次响应中处理不同的文件类型，尽管它不能缓存收到的响应报文。当发送数据时，图像灯标是最简单和最有效的方法。XHR也可用POST方法发送大量数据。</p>
<p>除这些格式和传输技术之外，还有一些准则有助于进一步提高Ajax的速度：</p>
<ul>
<li>减少请求数量，可通过JavaScript和CSS文件打包，或者使用MXHR。</li>
<li>缩短页面的加载时间，在页面其他内容加载之后，使用Ajax获取少量重要文件。</li>
<li>确保代码错误不要直接显示给用户，并在服务器端处理错误。</li>
<li>学会何时使用一个健壮的Ajax库，何时编写自己的底层Ajax代码。</li>
</ul>
<p>Ajax是提升你网站潜在性能之最大的改进区域之一，因为很多网站大量使用异步请求，又因为它提供了许多不相关问题的解决方案，这些问题诸如，需要加载太多资源。对XHR的创造性应用是如此的与众不同，它不是呆滞不友好的界面，而是响应迅速且高效的代名词；它不会引起用户的憎恨，谁见了它都会爱上它。</p>
<h2 id="第八章-Programming-Practics-编程实践"><a href="#第八章-Programming-Practics-编程实践" class="headerlink" title="第八章     Programming Practics    编程实践"></a>第八章     Programming Practics    编程实践</h2><p>每种编程语言都有痛点，而且低效模式随着时间的推移不断发展。其原因在于，越来越多的人们开始使用这种语言，不断扩种它的边界。自2005年以来，当术语“Ajax”出现时，网页开发者对JavaScript和浏览器的推动作用远超过以往。其结果是出现了一些非常具体的模式，既有优秀的做法也有糟糕的做法。这些模式的出现，是因为网络上JavaScript的性质决定的。</p>
<p><strong>Avoid Double Evaluation 避免二次评估</strong></p>
<p><strong>Use Object/Array Literals 使用对象/数组直接量</strong></p>
<p><strong>Don’t Repeat Work 不要重复工作</strong></p>
<p><strong>Lazy Loading 延迟加载</strong></p>
<p><strong>Conditional Advance Loading 条件预加载</strong></p>
<p><strong>Use the Fast Parts 使用速度快的部分</strong></p>
<p><strong>Bitwise Operators 位操作运算符</strong></p>
<p><strong>Native Methods 原生方法</strong></p>
<p><strong>Summary 总结</strong></p>
<p>JavaScript提出了一些独特的性能挑战，关系到你组织代码的方法。网页应用变得越来越高级，包含的JavaScript代码越来越多，出现了一些模式和反模式。请牢记以下编程经验：</p>
<ul>
<li>通过避免使用eval_r()和Function()构造器避免二次评估。此外，给setTimeout()和setInterval()传递函数参数而不是字符串参数。</li>
<li>创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。</li>
<li>避免重复进行相同工作。当需要检测浏览器时，使用延迟加载或条件预加载。</li>
<li>当执行数学运算时，考虑使用位操作，它直接在数学底层进行操作。</li>
<li>原生方法总是比JavaScript写的东西要快。尽量使用原生方法。</li>
</ul>
<p>本书涵盖了很多技术和方法，如果将这些优化应用在哪些经常运行的代码上，你将会看到巨大的性能提升。</p>
<h2 id="第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能JavaScript应用程序"><a href="#第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能JavaScript应用程序" class="headerlink" title="第九章    Building and Deploying High-Performance JavaScript Applications    创建并部署高性能JavaScript应用程序"></a>第九章    Building and Deploying High-Performance JavaScript Applications    创建并部署高性能JavaScript应用程序</h2><p>根据Yahoo!卓越性能团队在2007年进行的研究，40%-60%的Yahoo!用户没有使用缓存的经验，大约20%页面视图不使用缓存（<a href="https://yuiblog.com/blog/2007/01/04/performance-research-part-2/）。另外，由Yahoo!研究小组发现，并由Google的Steve" target="_blank" rel="noopener">https://yuiblog.com/blog/2007/01/04/performance-research-part-2/）。另外，由Yahoo!研究小组发现，并由Google的Steve</a> Souders所证实的一项最新研究表明，大约15%的美国大型网站所提供的内容没有压缩。</p>
<p>这些事实强调有必要确保哪些基于JavaScript的网页应用尽量高效地发布。虽然部分工作在设计开发过程中已经完成，但构建和部署过程也很重要且往往被忽视。如果在这个关键过程中不够小心，你应用程序的性能将受到影响，无论你怎么努力使它更快。</p>
<p>本章的目的是给你必要的知识，有效地组织并部署基于JavaScript的Web应用程序。一些概念使用Apache Ant进行说明，它是一个基于Java的构建工具，并很快成为开发网页应用程序的工业标准，在本章末尾，给出了一个用PHP5写的定制灵活的开发工具的例子。</p>
<p><strong>Apache Ant</strong></p>
<p><strong>Combining JavaScript Files 合并JavaScript文件</strong></p>
<p><strong>Preprocessing JavaScript Files 预处理JavaScript文件</strong></p>
<p><strong>JavaScript Minification    JavaScript紧凑</strong></p>
<p><strong>Buildtime Versus Runtime Build Process 开发过程中的编译时和运行时</strong></p>
<p><strong>JavaScript Compression JavaScript压缩</strong></p>
<p><strong>Caching JavaScript Files 缓存JavaScript文件</strong></p>
<p><strong>Working Around Caching Issues 关于缓存问题</strong></p>
<p><strong>Using a Content Delivery Network 使用内容传递网</strong></p>
<p><strong>Deploying JavaScript Resources 部署JavaScript资源</strong></p>
<p><strong>Agile JavaScript Build Process 灵巧的JavaScript开发过程</strong></p>
<p><strong>Summary 总结</strong></p>
<p>开发和部署过程对基于JavaScript的应用程序可以产生巨大影响，最重要的几个步骤如下：</p>
<ul>
<li>合并JavaScript文件，减少HTTP请求的数量</li>
<li>使用YUI压缩器紧凑处理JavaScript文件</li>
<li>以压缩形式提供JavaScript文件（gzip编码）</li>
<li>通过设置HTTP响应报文头使JavaScript文件可缓存，通过向文件名附加时间戳解决缓存问题</li>
<li>使用内容传递网络（CDN）提供JavaScript文件，CDN不仅可以提高性能，它还可以为你管理压缩和缓存</li>
</ul>
<p>所有这些步骤应当自动完成，不论是使用公开的开发工具诸如Apache Ant，还是使用自定义的开发工具以实现特定需求。如果你使这些开发工具为你服务，你可以极大改善哪些大量使用JavaScript代码的网页应用或网站的性能。</p>
<h2 id="第十章-Tools-工具"><a href="#第十章-Tools-工具" class="headerlink" title="第十章    Tools    工具"></a>第十章    Tools    工具</h2><p>当确定脚本加载和运行时的瓶颈所在时，合手的工具是必不可少的。许多浏览器厂商和大型网站分享了一些技术和工具，帮助开发者使网页更快，效率更高。本章关注于这些免费工具：</p>
<p><strong>Profiling 性能分析</strong></p>
<p><strong>Network analysis 网络分析</strong></p>
<p><strong>JavaScript Profiling JavaScript 性能分析</strong></p>
<p><strong>YUI Profiler YUI分析器</strong></p>
<p><strong>Anonymous Functions 匿名函数</strong></p>
<p><strong>Firebug</strong></p>
<p><strong>Console Panel Profiler 控制台面板分析器</strong></p>
<p><strong>Console API 终端API</strong></p>
<p><strong>Net Panel 网络面板</strong></p>
<p><strong>Internet Explorer Developer Tools IE开发人员工具</strong></p>
<p><strong>Safari Web Inspector Safari 网页监察器</strong></p>
<p><strong>Profiles Panel 分析面板</strong></p>
<p><strong>Resources Panel 资源面板</strong></p>
<p><strong>Chrome Developers Tools    Chrome开发人员工具</strong></p>
<p><strong>Script Blocking 脚本阻塞</strong></p>
<p><strong>Page Speed</strong></p>
<p><strong>Fiddler</strong></p>
<p><strong>YSlow</strong></p>
<p><strong>dynaTrace Ajax Edition Ajax版的dynaTrace</strong></p>
<p><strong>Summary 总结</strong></p>
<p>当网页或应用程序变慢时，分析网上传来的资源，分析脚本的运行性能，使你能够集中精力在那些需要努力优化的地方。</p>
<ul>
<li>使用网络分析器找出加载脚本和其他页面资源的瓶颈所在，这有助于决定哪些脚本需要延迟加载，或者进行进一步分析。</li>
<li>传统的智慧告诉我们应尽量减少HTTP请求的数量，尽量延迟加载脚本以使页面渲染速度更快，向用户提供更好的整体体验。</li>
<li>使用性能分析器找出脚本运行时速度慢的部分，检查每个函数所花费的时间，以及函数被调用的次数，通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。</li>
<li>虽然花费时间和调用次数通常是数据中最有价值的点，还是应当仔细查看函数的调用过程，可能发现其它优化方法。</li>
</ul>
<p>这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们，确保开发时间用在解决问题的刀刃上。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/白话js-this指向问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/白话js-this指向问题/" itemprop="url">白话js_this指向问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:41:46+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="白话js-this指向问题"><a href="#白话js-this指向问题" class="headerlink" title="白话js this指向问题"></a>白话js this指向问题</h2><p><strong>前言</strong></p>
<p>通过本文，你大概能了解this基础指向的问题，抛开例子去说this太虚幻，这里还是结合几篇博文做个整理，算是个人的记录了。</p>
<p>先说概念，this指向与申明无关，永远指向距离自己<strong>最近的最终调用者</strong>。我们从几种调用情况去理解，下面看看例子理解下：</p>
<p><strong>1.函数的直接调用</strong></p>
<pre><code>function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //undefined
    console.log(this); // window
}
a();
</code></pre><p>如上，我们申明一个函数，然后直接调用，a()前面没任何调用它的对象，这时候我们一般理解为被全局window对象调用，那我们就得去window去找age属性，很明显window没有，这里输出undefined。</p>
<p>我们改改代码，用window去调用函数a，同时定义a的age属性，如下：</p>
<pre><code>window.age = &apos;26&apos;;
function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //26
    console.log(this);//window
}
window.a();
</code></pre><p>那我们可以这样理解，<strong>针对函数调用</strong>，我们在一个函数内申明this，我们去看它最终是被谁调用，如果最终的调用前啥都没有，this就会指向window，这里只是针对js非严格模式。</p>
<pre><code>function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //undefined
    console.log(this); //window
}
function b() {
    a();
}
b();
</code></pre><p>你以为我说到这，函数调用的this问题就说完了？不存在的，死记硬背难啊，情况多变，<strong>为什么函数直接调用，前面啥都没有就指向window，为什么？</strong></p>
<p><strong>我再知乎看到一篇从函数调用原理讲this的文章，这里就引入下，</strong></p>
<p>函数一般常见三种调用方式，其实对于我是两种</p>
<p><strong>1.func(a,b)</strong> — 普通函数调用</p>
<p><strong>2.obj.child.method(context,a,b)</strong> — 调用对象内的某个方法，这个方法相当于对象的子属性</p>
<p><strong>3.func.call(context,a,b)</strong> — 这个我确实在调用中没怎么用过。</p>
<p>对于前两种，普通调用，对象属性的函数调用我们都常见，而第三种其实才是我们原本函数该有的调用，那我们这个this的讲解就偏偏与第三种有关系了。我们将前两者改写为第三种调用。</p>
<pre><code>func(a,b) ==&gt; func.call(undefined,a,b)
obj.child.method ==&gt; obj.child.method.call(obj.child,a,b)
//因为不确定obj里面的method是属于obj的属性还是obj child的属
性，再加个
obj.method ==&gt; obj.method.call(obj,a,b)
</code></pre><p>那我们就可以将所有的函数调用统一为 <strong>func.call(context,a,b)这一种</strong>，<strong>如果不是这一种，按照上面去改写，**</strong>其中context就是我们一直苦苦寻找的this**.</p>
<p>OK,上面是函数的普通调用，咱们来改写上面的例子。</p>
<pre><code>function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //undefined
    console.log(this); // window
}
a(); //等价于a.call(undefined);
</code></pre><p>那按照我们上面说的，this应该是undefined啊，为毛是Window，这里又插入一个小规则</p>
<p><strong>如果你传的context为null或者undefined，那么window对象就是默认的context（严格模式下默认context是undefined）</strong></p>
<p>那这里我们就明白为啥普通函数直接调用，this指向window了。</p>
<p><strong>2.函数作为对象属性方法被调用</strong></p>
<p>怎么去解释，我们还是用上面函数调用的改写去理解，先看一个例子。</p>
<pre><code>var a = {
    age: &quot;29&quot;,
    fn:function() {
        console.log(this.age); // 29
    }
}
a.fn(); //等价于a.fn.call(a)
//参照obj.method ==&gt; obj.method.call(obj,a,b)来看
</code></pre><p>method fn是对象a的一个属性，照着上面的对等公式，最终this指向就是对象a自己，也验证了上面我们说的，this指向它最终的调用者。</p>
<p>再来看一个例子：</p>
<pre><code>var a = {
    age: 10,
    func:{
        age:12,
        fn:function() {
            console.log(this.age); //12
        }
    }
}
a.func.fn(); //等价于 a.method.fn.call(a.method)    
// 参照obj.child.method ==&gt; obj.child.method.call
(obj.child,a,b)来看
</code></pre><p>func是对象a的一个child属性，而方法fn包含在func内，所以参照这个例子，this指向了a.func，而a.func提供了age属性，这里就输出12了，问题不大吧？</p>
<p>那我们现在来融合函数调用与对象调用来看个例子：</p>
<pre><code>var a = {
    age: 10,
    func: {
        age: 12,
        fn: function() {
            console.log(this.age); // undefined
            console.log(this); // window
        }
    }
}
var j = a.func.fn;
j(); // 等价于window.j()或者j.call(undefined)
</code></pre><p>跟我读，this指向最终，且离自己最近的调用者，最终调用的是方法j()，按照改写说的通，按照我们说的方法前面啥都没有就是window也说的通，就是这个意思了。</p>
<h2 id="3-构造函数的调用"><a href="#3-构造函数的调用" class="headerlink" title="3.构造函数的调用"></a>3.构造函数的调用</h2><p>我们先来看个例子，当我们输出a.user，this指向了谁？</p>
<pre><code>function Fn() {
    this.age = 25;
}
var a = new Fn();
console.log(a.age); //25
</code></pre><p>先明白this指向谁，我们要弄懂什么是构造函数，new干嘛了？var a = new Fn()干嘛了？</p>
<p>构造函数就是初始化一个实例对象，当我们new Fn()其实就是将Fn()复制了一份，并作为对象返回，赋值给了变量a。</p>
<p>我们可以console a，得到的就是Fn()函数的实例，而且继承了Fn里面的age属性，所以此时this指向a，a里面有age属性。</p>
<p>我们来白话一遍，这样说，当我们用构造函数方法，this指向我们new出来返回的对象，就是复制Fn得到了一个Fn副本，this指向了Fn副本，而这个Fn副本被赋予给了变量a，于是this指向了a，这个Fn副本继承了原函数的属性，所以这里顺利的输出了25.(并不是复制了整个函数，这句话有问题，我暂时不理解)</p>
<h2 id="构造函数与return"><a href="#构造函数与return" class="headerlink" title="构造函数与return"></a>构造函数与return</h2><p><strong>我在上面说，构造函数this会指向new之后的实例（复制出来的副本），但如果在函数里有return，this指向可能会发生变化。</strong></p>
<pre><code>function Fn() {
    this.age = 17;
    return {age:18};
}
var a = new Fn();
console.log(a); // {age:18}
console.log(a.age); //18
</code></pre><p>很明显，return的对象赋值给了变量a，这里输出了18.再来看看这段代码：</p>
<pre><code>function Fn() {
    this.age = &apos;25&apos;;
    return function() {};
}
var a = new Fn();
console.log(a.age); // undefined
</code></pre><p>再来一段代码：</p>
<pre><code>function Fn() {
    this.age = 11;
    return 1;
}
var a = new Fn();
console.log(a.age); //11
</code></pre><p>我们可以做个大致判断，当在构造函数中return 一个对象时，this会指向这个对象，如上面的第一，第二段代码，但如果return的不是一个对象，那就不会改变this指向，还是指向new出来的实例。</p>
<p><strong>构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕后，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangXiaofei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangXiaofei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
