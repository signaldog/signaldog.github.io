<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/js基础Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/js基础Interview/" itemprop="url">js基础Interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T16:15:13+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>原形    原型链</li>
<li>作用域    闭包</li>
<li>异步 单线程</li>
</ul>
<h2 id="JS-API"><a href="#JS-API" class="headerlink" title="JS API"></a>JS API</h2><ul>
<li>DOM操作</li>
<li>Ajax</li>
<li>事件绑定</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>版本管理</li>
<li>模块化</li>
<li>打包工具</li>
</ul>
<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul>
<li>页面渲染</li>
<li>性能优化</li>
</ul>
<p><strong>题目</strong></p>
<ul>
<li>JS中使用typeof能得到的哪些类型？</li>
<li>何时使用===何时使用==？</li>
<li>window.onload和DOMContentLoaded的区别？</li>
<li>用JS创建10个a标签，点击的时候弹出来对应的序号</li>
<li>简述如何实现一个模块加载器，实现类似require.js的基本功能</li>
<li>实现数组的随机排序</li>
</ul>
<p><strong>引用类型</strong></p>
<p>对象、数组、函数</p>
<p><strong>变量计算 - 强制类型转换</strong></p>
<ul>
<li>字符串拼接</li>
<li>==运算符</li>
<li>if语句</li>
<li>逻辑运算</li>
</ul>
<p><strong>JS中的内置函数</strong> - 数据封装类对象</p>
<ul>
<li>Object</li>
<li>Array</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Function</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p><strong>JS按存储方式区分变量类型</strong></p>
<p><strong>如何理解JSON</strong></p>
<p>JSON只不过是一个JS对象而已如Math</p>
<h2 id="原型和原型链-构造函数"><a href="#原型和原型链-构造函数" class="headerlink" title="原型和原型链-构造函数"></a>原型和原型链-构造函数</h2><p><strong>题目</strong></p>
<ul>
<li>如何准确判断一个变量是数组类型</li>
<li>写一个原型链继承的例子</li>
<li>描述new一个对象的过程</li>
<li>zepto(或其他框架)源码中如何使用原型链</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>构造函数</li>
<li>构造函数-扩展</li>
<li>原形规则和示例</li>
<li>原型链</li>
<li>instanceof</li>
</ul>
<p><strong>构造函数</strong></p>
<pre><code>function Foo(name, age){ // Foo 构造函数首字母一般大写
    this.name = name
    this.age = age
    this.class = &apos;class-1&apos;
    // return this  // 默认有这一行
}
var f = new Foo(&apos;zhangsan&apos;, 20)
// var f1 = new Foo(&apos;lisi&apos;, 22) // 创建多个对象
</code></pre><p>执行过程：</p>
<p>this变成空对象 -》 赋值</p>
<p>扩展</p>
<ul>
<li>var a = {} 其实是var a = new Object()的语法糖</li>
<li>var a = [] 其实是var a = new Array()的语法糖</li>
<li>function Foo(){…}其实是var Foo = new Function(…)</li>
<li>使用instanceof判断一个函数是否是一个变量的构造函数</li>
</ul>
<p>==》 判断一个变量是否为“数组”：变量instanceof Array</p>
<h2 id="原形规则和示例"><a href="#原形规则和示例" class="headerlink" title="原形规则和示例"></a>原形规则和示例</h2><p><strong>5条原型规则</strong></p>
<ul>
<li>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”意外）</li>
<li>所有的引用类型（数组、对象、函数），都有一个<em>proto</em>属性，属性值是一个普通的对象（<em>proto</em>：隐式原型）</li>
<li>所有的函数，都有一个prototype属性，属性值也是一个普通的对象（prototype：显式原型）</li>
<li>所有的引用类型（数组、对象、函数），<em>proto</em>属性值指向它的构造函数的“prototype”属性值</li>
<li><p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<em>proto</em>（即它的构造函数的prototype）中寻找。</p>
<p>  var obj = {}; obj.a = 100;<br>  var arr = []; arr.a = 100;<br>  function fn() {}<br>  fn.a = 100;</p>
<p>  console.log(obj.<em>proto</em>);<br>  console.log(arr.<em>proto</em>);<br>  console.log(fn.<em>proto</em>);</p>
<p>  console.log(fn.prototype)</p>
<p>  console.log(obj.<em>proto</em> === Object.prototype)</p>
</li>
</ul>
<p>示例：</p>
<pre><code>// 构造函数
function Foo(name, age) {
    this.name = name
}
Foo.prototype.alertName = function () {
    alert(this.name)
}
// 创建示例
var f = new Foo(&apos;zhangsan&apos;)
f.printName = function () {
    console.log(this.name)
}
// 测试
f.printName()
f.alertName()
</code></pre><p><strong>扩展</strong></p>
<p>this</p>
<pre><code>// 测试
f.printName()
f.alertName()

this 就是指向f
</code></pre><p>循环对象自身的属性</p>
<pre><code>var item
for (item in f) {
    // 高级浏览器已经在for in 中屏蔽了来自原型的属性
    // 但是这里建议大家还是加上这个判断，保证程序的健壮性
    if (f.hasOwnProperty(item)) {
        console.log(item)
    }
}
</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><pre><code>// .......
//测试
f.toString()  // 要去 f._proto_._proto_中查找
</code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>用于判断引用类型属于哪个构造函数的方法</p>
<ul>
<li>f instanceof Foo的判断逻辑是：</li>
<li>f的<em>proto</em>一层一层往上，能否对应到Foo.prototype</li>
<li>再试着判断f instanceof Object</li>
</ul>
<h2 id="问题与解答"><a href="#问题与解答" class="headerlink" title="问题与解答"></a>问题与解答</h2><p><strong>如何判断一个变量是数组类型</strong></p>
<pre><code>var arr = []
arr instanceof Array // true
typeof arr // object, typeof 是无法判断是否是数组的
</code></pre><p><strong>写一个原型链继承的例子</strong></p>
<pre><code>// 动物
function Animal() {
    this.eat = function() {
        console.log(&apos;animal eat&apos;)
    }
}
// 狗
function Dog() {
    this.bark = function() {
        console.log(&apos;dog bark&apos;)
    }
}
Dog.prototype = new Animal()
// 哈士奇
var hashiqi = new Dog()
// 接下的代码演示时，会推荐更加贴近实战的原型继承示例！
</code></pre><p><strong>描述new一个对象的过程</strong></p>
<ul>
<li>创建一个新对象</li>
<li>this指向这个新对象</li>
<li>执行代码，即对this赋值</li>
<li><p>返回this</p>
<p>  function Elem(id) {<br>  this.elem = document.getElementById(id)<br>  }</p>
<p>  Elem.prototype.html = function(val) {</p>
<pre><code>var elem = this.elem
if (val) {
    elem.innerHTML = val
    return this // 链式操作
} else {
    return elem.innerHTML
}
</code></pre><p>  }</p>
<p>  Elem.prototype.on = function(type, fn) {</p>
<pre><code>var elem = this.elem
elem.addEventListener(type, fn)
return this
</code></pre><p>  }</p>
<p>  var div1 = new Elem(‘div1’)<br>  // console.log(div1.html())<br>  // div1.html(‘</p><p>hello imooc</p>‘)<br>  // div1.on(‘click’, function() {<br>  //     alert(‘clicked’)<br>  // })<p></p>
<p>  div1.html(‘</p><p>hello imooc</p>‘).on(‘click’, function() {<p></p>
<pre><code>alert(&apos;clicked&apos;)
</code></pre><p>  }).html(‘</p><p>javascript</p>‘)<p></p>
</li>
</ul>
<p><strong>zepto（或其他框架）源码中如何使用原型链</strong></p>
<ul>
<li>阅读源码是高效提高技能的方式</li>
<li>但不能“埋头苦钻”有技巧在其中</li>
<li>慕课网搜索“zepto设计和源码分析”</li>
</ul>
<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><p><strong>题目</strong></p>
<ul>
<li>说一下对变量提升的理解</li>
<li>说明this几种不同的使用场景</li>
<li>创建10个a标签，点击的时候弹出来对应的序号</li>
<li>如何理解作用域</li>
<li>实际开发中闭包的应用</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>执行上下文</li>
<li>this</li>
<li>作用域</li>
<li>作用域链</li>
<li>闭包</li>
</ul>
<p><strong>执行上下文</strong></p>
<pre><code>console.log(a)  // undefined
var a = 100

fn(&apos;zhangsan&apos;) // &apos;zhangsan&apos; 20
function fn(name) {
    age = 20
    console.log(name, age)
    var age
}
</code></pre><ul>
<li>范围：一段script或者一个函数</li>
<li>全局：变量定义、函数声明            一段script</li>
<li>函数：变量定义、函数声明、this、arguments            函数</li>
</ul>
<p>PS：注意“函数声明”和“函数表达式”的区别</p>
<p><strong>this</strong></p>
<ul>
<li><p>this要在执行时才能确认值，定义时无法确认</p>
<p>  var a = {</p>
<pre><code>name: &apos;A&apos;,
fn: function() {
    console.log(this.name)
}
</code></pre><p>  }<br>  a.fn()  // this === a<br>  a.fn.call({name: ‘B’}) // this === {name: ‘B’}<br>  var fn1 = a.fn<br>  fn1() // this === window</p>
</li>
<li><p>作为构造函数执行</p>
</li>
<li>作为对象属性执行</li>
<li>作为普通函数执行</li>
<li>call    apply    bind</li>
</ul>
<p><strong>作用域</strong></p>
<pre><code>// 无块级作用域
if (true) {
    var name = &apos;zhangsan&apos;
}
console.log(name)

// 函数和全局作用域
var a = 100
function fn() {
    var a = 200
    console.log(&apos;fn&apos;, a)
}
console.log(&apos;global&apos;, a)
fn()
</code></pre><ul>
<li>没有块级作用域</li>
<li>只有函数和全局作用域</li>
</ul>
<p><strong>作用域链</strong></p>
<pre><code>var a = 100
function fn() {
    var b = 200

    // 当前作用域没有定义的变量，即“自由变量”
    console.log(a)

    console.log(b)
}
fn()

var a = 100
function F1() {
    var b = 200
    function F2() {
        var c = 300
        console.log(a) // a是自由变量
        console.log(b) // b是自由变量
        console.log(c)
    }
    F2()
}
F1()
</code></pre><p><strong>闭包</strong></p>
<pre><code>function F1() {
    var a = 100

    // 返回一个函数（函数作为返回值）
    return function() { // 函数定义时的*父*作用域
        console.log(a) // 自由变量，父作用域寻找
    }
}
// f1 得到一个函数
var f1 = F1()
var a = 200
f1()
</code></pre><p><strong>闭包的使用场景</strong></p>
<ul>
<li>函数作为返回值（上一个demo）</li>
<li>函数作为参数传递（自己思考）</li>
</ul>
<p>作为参数</p>
<pre><code>function F1() {
    var a = 100
    return function() {
        console.log(a) // 自由变量，父作用域寻找
    }
}
var f1 = F1()

function F2(fn) {
    var a = 200
    fn()
}
F2(f1)
</code></pre><p><strong>说一下对变量提升的理解</strong></p>
<ul>
<li>变量定义</li>
<li>函数声明（注意和函数表达式的区别）</li>
</ul>
<p><strong>说明this几种不同的使用场景</strong></p>
<ul>
<li>作为构造函数执行</li>
<li>作为对象属性执行</li>
<li>作为普通函数执行</li>
<li>call    apply    bind</li>
</ul>
<p>创建10个a标签 点击的时候弹出来对应的序号</p>
<pre><code>// 这是一个错误的写法！！！
var i, a
for(i =0; i&lt;10; i++) {
    a = document.createElement(&apos;a&apos;)
    a.innerHTML = i + &apos;&lt;br&gt;&apos;
    a.addEventListener(&apos;click&apos;, function(e) {
        e.preventDefault()
        alert(i) // 自由变量，要去父作用域获取值
    })
    document.body.appendChild(a)
}

// 这是正确的写法！！！
var i 
for(i = 0;i&lt;10;i++) {
    (function(i) {
        // 函数作用域
        var a = document.createElement(&apos;a&apos;)
        a.innerHTML = i + &apos;&lt;br&gt;&apos;
        a.addEventListener(&apos;click&apos;, function(e) {
            e.preventDefault()
            alert(i)
        })
        document.body.appendChild(a)
    })(i)
}
</code></pre><p>自执行函数，就是不用调用，只要定义完成，立即执行的函数</p>
<p><strong>如何理解作用域</strong></p>
<ul>
<li>自由变量</li>
<li>作用域链，即自由变量的查找</li>
<li>闭包的两个场景</li>
</ul>
<p><strong>实际开发中闭包的应用</strong></p>
<pre><code>// 闭包实际应用中主要用于封装变量，收敛权限
function isFirstLoad() {
    var _list = []
    return function(id) {
        if (_list.indexOf(id) &gt;= 0) {
            return false
        } else {
            _list.push(id) 
            return true
        }
    }
}

//使用
var firstLoad = isFirstLoad()
firstLoad(10) // true
firstLoad(10) // false
firstLoad(20) // true
</code></pre><h2 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h2><p><strong>题目</strong></p>
<ul>
<li>同步和异步的区别是什么？分别举一个同步和异步的例子</li>
<li>一个关于setTimeout的笔试题</li>
<li>前端使用异步的场景有哪些</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>什么是异步（对比同步）</li>
<li>前端使用异步的场景</li>
<li>异步和单线程</li>
</ul>
<p><strong>什么是异步</strong></p>
<pre><code>console.log(100)
setTimeout(function() {
    console.log(200)
}, 1000)
console.log(300)
</code></pre><p>对比同步</p>
<pre><code>console.log(100)
alert(200) // 1秒钟之后点击确认
console.log(300)
</code></pre><p><strong>何时需要异步</strong></p>
<ul>
<li>在可能发生等待的情况</li>
<li>等待过程中不能像alert一样阻塞程序运行</li>
<li>因此，所以的“等待的情况”都需要异步</li>
</ul>
<p><strong>前端使用异步的场景</strong><br>.</p>
<ul>
<li>定时任务：setTimeout，setInterval</li>
<li>网络请求：ajax请求，动态img标签加载</li>
<li>事件绑定</li>
</ul>
<p>ajax请求代码示例</p>
<pre><code>console.log(&apos;start&apos;)
$.get(&apos;./data1.json&apos;, function(data1) {
    console.log(data1)
})
console.log(&apos;end&apos;)
</code></pre><p>img标签加载示例</p>
<pre><code>console.log(&apos;start&apos;)
var img = document.createElement(&apos;img&apos;)
img.onload = function() {
    console.log(&apos;loaded&apos;)
}
img.src = &apos;/xxx.png&apos;
console.log(&apos;end&apos;)
</code></pre><p>事件绑定示例</p>
<pre><code>console.log(&apos;start&apos;)
document.getElementById(&apos;btn1&apos;).addEventListener
(&apos;click&apos;, function(){
    alert(&apos;clicked&apos;)
})
console.log(&apos;end&apos;)
</code></pre><p><strong>异步和单线程</strong></p>
<pre><code>console.log(100)
setTimeout(function() {
    console.log(200)
}, 1000)
console.log(300)
</code></pre><ul>
<li>执行第一行，打印100</li>
<li>执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）</li>
<li>执行最后一行，打印300</li>
<li>待所有程序执行完，处于空闲状态时，会立马看有没有暂存起来的要执行。</li>
<li>发现暂存起来的setTimeout中的函数无需等待时间，就立即来过来执行</li>
</ul>
<p><strong>同步和异步的区别是什么</strong></p>
<ul>
<li>同步会阻塞代码执行，而异步不会</li>
<li>alert是同步，setTimeout是异步</li>
</ul>
<p><strong>一个关于setTimeout的笔试题</strong></p>
<pre><code>console.log(1)
setTimeout(function() {
    console.log(2)
}, 0)
console.log(3)
setTimeout(function() {
    console.log(4)
}, 1000)
console.log(5)
</code></pre><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><p><strong>题目</strong></p>
<ul>
<li>获取 2017-06-10 格式的日期</li>
<li>获取随机数，要求是长度一致的字符串格式</li>
<li>写一个能遍历对象和数组的通用forEach函数</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>日期</li>
<li>Math</li>
<li>数组API</li>
<li>对象API</li>
</ul>
<p><strong>日期</strong></p>
<pre><code>Date.now()    // 获取当前时间毫秒数
var dt = new Date() 
dt.getTime() // 获取毫秒数
dt.getFullYear() // 年
dt.getMonth() // 月（0 - 11）
dt.getDate() // 日（0 - 31）
dt.getHours() // 小时（0 - 23）
dt.getMinutes() // 分钟（0 - 59）
dt.getSeconds() // 秒（0 -59）
</code></pre><p><strong>Math</strong></p>
<ul>
<li>获取随机数Math.random()</li>
</ul>
<p><strong>数组API</strong></p>
<ul>
<li>forEach 遍历所有元素</li>
<li>every 判断所有元素是否都符合条件</li>
<li>some 判断是否有至少一个元素符合条件</li>
<li>sort 排序</li>
<li>map 对元素重新组装，生成新数组</li>
<li>filter 过滤符合条件的元素</li>
</ul>
<p>forEach</p>
<pre><code>var arr = [1,2,3]
arr.forEach(function(item, index) {
    // 遍历数组的所有元素
    console.log(index, item)
})
</code></pre><p>every </p>
<pre><code>var arr = [1,2,3]
var result = arr.every(function (item, index) {
    // 用来判断所有的数组元素，都满足一个条件
    if (item &lt; 4) {
        return true
    }
})
console.log(result)
</code></pre><p>some </p>
<pre><code>var arr = [1,2,3]
var result = arr.some(function (item, index) {
    // 用来判断所有的数组元素，只要有一个满足条件即可
    if (item &lt; 2) {
        return true
    }
})
console.log(result)
</code></pre><p>sort</p>
<pre><code>var arr = [1,4,2,3,5]
var arr2 = arr.sort(function(a,b) {
    // 从小到大排序
    return a - b

    // 从大到小排序
    // return b - a
})
console.log(arr2)
</code></pre><p>map </p>
<pre><code>var arr = [1,2,3,4]
var arr2 = arr.map(function(item, index) {
    // 将元素重新组装，并返回
    return &apos;&lt;b&gt;&apos; + item + &apos;&lt;/b&gt;&apos;
})
console.log(arr2)
</code></pre><p>filter</p>
<pre><code>var arr = [1,2,3]
var arr2 = arr.filter(function(item, index) {
    // 通过某一个条件过滤数组
    if (item &gt;= 2) {
        return true
    }
})
console.log(arr2)
</code></pre><p><strong>对象API</strong></p>
<pre><code>var obj = {
    x: 100,
    y: 200,
    z: 300
}
var key
for(key in obj) {
    // 注意这里的hasOwnProperty，再讲原型链时候讲过了
    if (obj.hasOwnProperty(key)){
        console.log(key, obj[key])
    }
}
</code></pre><p><strong>获取2017-06-10格式的日期</strong></p>
<pre><code>function formatDate(dt) {
    if (!dt) {
        dt = new Date()
    }
    var year = dt.getFullYear()
    var month  = dt.getMonth() + 1
    var date = dt.getDate()
    if (month &lt; 10) {
        // 强制类型转换
        month = &apos;0&apos; + month
    }
    if (date &lt; 10) {
        // 强制类型转换
        date = &apos;0&apos; + date
    }
    // 强制类型转换
    return year + &apos;-&apos; + month + &apos;-&apos; + date
}
var dt = new Date()
var formatDate = formatDate(dt)
console.log(formatDate)
</code></pre><p><strong>获取随机数，要求是长度一致的字符串格式</strong></p>
<pre><code>var random = Math.random()
var random = random + &apos;0000000000&apos; // 后面加上10个零
var random = random.slice(0, 10)
console.log(random)
</code></pre><p>写一个能遍历对象和数组的forEach函数</p>
<pre><code>function forEach(obj, fn) {
    var key 
    if (obj instanceof Array) {
        // 准确判断是不是数组
        obj.forEach(function(item, index){
            fn(index, item)
        })
    } else {
        // 不是数组就是对象
        for(key in  obj) {
            fn(key, obj[key])
        }
    }
}

var arr = [1,2,3]
// 注意，这里参数的顺序换了，为了和对象的遍历格式一致
forEach(arr, function(index, item) {
    console.log(index, item)
})

var obj = {x: 100, y: 200}
forEach(obj, function(key, value) {
    console.log(key, value)
})
</code></pre><h2 id="JS-Web-API"><a href="#JS-Web-API" class="headerlink" title="JS-Web-API"></a>JS-Web-API</h2><ul>
<li>W3C标准中关于JS的规定有：</li>
<li>DOM操作</li>
<li>BOM操作</li>
<li>事件绑定</li>
<li>ajax请求（包括http协议）</li>
<li><p>存储</p>
</li>
<li><p>页面弹框是window.alert(123)，浏览器需要做：</p>
</li>
<li>定义一个window全局变量，对象类型</li>
<li>给它定义一个alert属性，属性值是一个函数</li>
</ul>
<hr>
<ul>
<li>但是W3C标准没有规定任何JS基础相关的东西</li>
<li>不管什么变量类型、原型、作用域和异步</li>
<li>只管定义用于浏览器中JS操作页面的API和全局变量</li>
</ul>
<hr>
<ul>
<li>全面考虑，JS内置的全局函数和对象有哪些？</li>
<li>之前讲过的Object Array Boolean String Math JSON等</li>
<li>刚刚提到的window document</li>
<li>接下来还有继续讲到的所有未定义的全局变量，如navigator.userAgent</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>常说的JS（浏览器执行的JS）包含两部分：</li>
<li>JS基础知识（ECMA262标准）</li>
<li>JS-Web-API（W3C标准）</li>
</ul>
<p><strong>DOM操作</strong></p>
<p>Document    Object    Model</p>
<p><strong>题目</strong></p>
<ul>
<li>DOM是哪种基本的数据结构？</li>
<li>DOM操作的常用API有哪些</li>
<li>DOM节点的attr和property有何区别</li>
</ul>
<p><strong>DOM的本质</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;note&gt;
    &lt;to&gt;Tove&lt;/to&gt;
    &lt;from&gt;Jani&lt;/from&gt;
    &lt;heading&gt;Reminder&lt;/heading&gt;
    &lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;
    &lt;other&gt;
        &lt;a&gt;&lt;/a&gt;
        &lt;b&gt;&lt;/b&gt;
    &lt;/other&gt;
&lt;/note&gt;
</code></pre><hr>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;p&gt;this is p&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>DOM节点操作</strong></p>
<p>DOM可以理解为：</p>
<p>浏览器吧拿到的html代码，结构化一个浏览器能识别并且js可操作的一个模型而已。</p>
<ul>
<li>获取DOM节点</li>
<li>prototype</li>
<li>Attribute</li>
</ul>
<p><strong>获取DOM节点</strong></p>
<pre><code>var div1 = document.getElementById(&apos;div1&apos;) // 元素
var divList = document.getElementsByTagName
(&apos;div&apos;) // 集合
console.log(divList.length)
console.log(divList[0])

var containerList = document.getElementsByClassName
(&apos;.container&apos;) // 集合
var pList = document.querySelectorAll(&apos;p&apos;) // 集合
</code></pre><p><strong>property</strong></p>
<pre><code>var pList = document.querySelectorAll(&apos;p&apos;)
var p = pList[0]
console.log(p.style.width) // 获取样式
p.style.width = &apos;100px&apos; // 修改样式
console.log(p.className) // 获取class
p.className = &apos;p1&apos; // 修改class

// 获取nodeName和nodeType
console.log(p.nodeName)
console.log(p.nodeType)
</code></pre><p><strong>Attribute</strong></p>
<pre><code>var pList = document.querySelectorAll(&apos;p&apos;)
var p = pList[0]
p.getAttribute(&apos;data-name&apos;)
p.setAttribute(&apos;data-name&apos;, &apos;imooc&apos;)
p.getAttribute(&apos;style&apos;)
p.setAttribute(&apos;style&apos;, &apos;font-size:30px;&apos;)
</code></pre><p><strong>DOM结构操作</strong></p>
<ul>
<li>新增节点</li>
<li>获取父元素</li>
<li>获取子元素</li>
<li>删除节点</li>
</ul>
<p><strong>新增节点</strong></p>
<pre><code>var div1 = document.getElementById(&apos;div1&apos;)
// 添加新节点
var p1 = document.createElement(&apos;p&apos;)
p1.innerHTML = &apos;this is p1&apos;
div1.appendChild(p1) // 添加新创建的元素
// 移动已有节点
var p2 = document.getElementById(&apos;p2&apos;)
div1.appendChild(p2)
</code></pre><p><strong>获取父元素和子元素</strong></p>
<pre><code>var div1 = document.getElementById(&apos;div1&apos;)
var parent = div1.parentElement

var child = div1.childNodes
div1.removeChild(child[0])
</code></pre><p><strong>解答</strong></p>
<ul>
<li>DOM是哪种基本的数据结构？</li>
<li>DOM操作的常用API有哪些</li>
<li>DOM节点的Attribute和property有何区别</li>
</ul>
<p><strong>DOM是哪种基本的数据结构</strong></p>
<ul>
<li>树</li>
</ul>
<p><strong>DOM操作的常用API有哪些</strong></p>
<ul>
<li>获取DOM节点，以及节点的property和Attribute</li>
<li>获取父节点，获取子节点</li>
<li>新增节点，删除节点</li>
</ul>
<p>DOM节点的Attribute和property有何区别</p>
<ul>
<li>property只是一个JS对象的属性的修改</li>
<li>Attribute是对html标签属性的修改</li>
</ul>
<p><strong>BOM操作</strong></p>
<p>Browser    Object    Model</p>
<p><strong>题目</strong></p>
<ul>
<li>如何检测浏览器的类型</li>
<li>拆解url的各部分</li>
</ul>
<p><strong>navigator &amp; screen</strong></p>
<pre><code>// navigator
var ua = navigator.userAgent
var isChrome = ua.indexOf(&apos;Chrome&apos;)
console.log(isChrome)

// screen
console.log(screen.width)
console.log(screen.height)
</code></pre><p><strong>location &amp; history</strong></p>
<pre><code>// location 
console.log(location.href)
console.log(location.protocol) // &apos;http:&apos; &apos;https:&apos;
console.log(location.host) // 域名
console.log(location.pathname) // &apos;/learn/199&apos;
console.log(location.search)
console.log(location.hash)

// history
history.back()
history.forward()
</code></pre><p><strong>如何检测浏览器的类型</strong></p>
<pre><code>var ua = navigator.userAgent
var isChrome = ua.indexOf(&apos;Chrome&apos;)
console.log(isChrome)
</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><strong>题目</strong></p>
<ul>
<li>编写一个通用的事件监听函数</li>
<li>描述事件冒泡流程</li>
<li>对于一个无限下拉加载图片的页面，如何给每个图片绑定事件</li>
</ul>
<p><strong>通用事件绑定</strong></p>
<pre><code>var btn = document.getElementById(&apos;bnt1&apos;)
btn.addEventListener(&apos;click&apos;, function(event) {
    console.log(&apos;clicked&apos;)
})
function bindEvent(elem, type, fn){
    elem.addEventListener(type, fn)
}

var a = document.getElementById(&apos;link1&apos;)
bindEvent(a, &apos;click&apos;, function(e) {
    e.preventDefault() // 阻止默认行为
    alert(&apos;clicked&apos;)
})
</code></pre><p><strong>关于IE低版本的兼容性</strong></p>
<ul>
<li>IE低版本使用attachEvent绑定事件，和W3C标准不一样</li>
<li>IE低版本使用量已非常少，很多网站都早已不支持</li>
<li>建议对IE低版本的兼容性：了解即可，无需深究</li>
<li>如果遇到对IE低版本要求苛刻的面试，果断放弃</li>
</ul>
<p><strong>事件冒泡</strong></p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;激活&lt;/p&gt;
        &lt;p id=&quot;p2&quot;&gt;取消&lt;/p&gt;
        &lt;p id=&quot;p3&quot;&gt;取消&lt;/p&gt;
        &lt;p id=&quot;p4&quot;&gt;取消&lt;/p&gt;
    &lt;/div&gt;
    &lt;div id=&quot;div2&quot;&gt;
        &lt;p id=&quot;p5&quot;&gt;取消&lt;/p&gt;
        &lt;p id=&quot;p6&quot;&gt;取消&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><hr>
<pre><code>var p1 = document.getElementById(&apos;p1&apos;)
var body = document.body
function bindEvent(elem, type, fn){
    elem.addEventListener(type, fn)
}

bindEvent(p1, &apos;click&apos;, function(e) {
    e.stopPropatation() // 阻止默认行为
    alert(&apos;激活&apos;)
})
bindEvent(body, &apos;click&apos;, function(e) {
    alert(&apos;取消&apos;)
})
</code></pre><p><strong>代理</strong></p>
<pre><code>&lt;div id=&quot;div1&quot;&gt;
   &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;
   &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;
   &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;
   &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;
   &lt;!-- 会随时新增更多a标签 --&gt;
&lt;/div&gt;
</code></pre><hr>
<pre><code>var div1 =document.getElementById(&apos;div1&apos;)
div1.addEventListener(&apos;click&apos;, function(e) {
    var target = e.target
    if(target.nodeName === &apos;A&apos;) {
        alert(target.innerHTML)
    }
})
</code></pre><p><strong>完善通用绑定事件的函数</strong></p>
<pre><code>function bindEvent(elem, type, selector, fn) {
    if (fn == null) {
        fn = selector
        selector = null
    }
    elem.addEventListener(type, function(e) {
        var target
        if(selector) {
            target = e.target
            if(target.matchs(selector)) {
                fn.call(target, e)
            }
        } else {
            fn(e)
        }
    })
}
</code></pre><hr>
<pre><code>// 使用代理
var div1 = document.getElementById(&apos;div1&apos;)
bindEvent(div1, &apos;click&apos;, &apos;a&apos;, function(e) {
    console.log(this.innerHTML)
})

// 不使用代理
var a = document.getElementById(&apos;a1&apos;)
bindEvent(div1, &apos;click&apos;, function(e) {
    console.log(a.innerHTML)
})
</code></pre><p><strong>代理的好处</strong></p>
<ul>
<li>代码简洁</li>
<li>减少浏览器内存占用</li>
</ul>
<p><strong>简述事件冒泡流程</strong></p>
<ul>
<li>DOM树形结构</li>
<li>事件冒泡</li>
<li>阻止冒泡</li>
<li>冒泡的应用</li>
</ul>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p><strong>题目</strong></p>
<ul>
<li>手动编写一个ajax，不依赖第三方库</li>
<li>跨域的几种实现方式</li>
</ul>
<p>imooc.com    m.imooc.com     coding.imooc.com</p>
<p><strong>知识点</strong></p>
<ul>
<li>XMLHttpRequest</li>
<li>状态码说明</li>
<li>跨域</li>
</ul>
<p><strong>XMLHttpRequest</strong></p>
<pre><code>var xhr = new XMLHttpRequest()
xhr.open(&apos;GET&apos;, &apos;/api&apos;, false)
xhr.onreadystatechange = function() {
    // 这里的函数异步执行，可参考之前JS基础中的异步模块
    if(xhr.readyState == 4) {
        if(xhr.status == 200) {
            alert(xhr.responseText)
        }
    }
}
xhr.send(null)
</code></pre><p><strong>IE兼容性问题</strong></p>
<ul>
<li>IE低版本使用ActiveXObject，和W3C标准不一样</li>
<li>IE低版本使用量以非常少，很多网站都早已不支持</li>
<li>建议对IE低版本的兼容性：了解即可，无需深究</li>
</ul>
<p><strong>状态码说明</strong></p>
<p><strong>readyState</strong></p>
<ul>
<li>0 -（未初始化）还没有调用send()方法</li>
<li>1 -（载入）已调用send()方法，正在发送请求</li>
<li>2 -（载入完成）send()方法执行完成，已经接收到全部响应内容</li>
<li>3 -（交互）正在解析响应内容</li>
<li>4 -（完成）响应内容解析完成，可以在客户端调用了</li>
</ul>
<p><strong>status</strong></p>
<ul>
<li>2xx - 表示成功处理请求。如200</li>
<li>3xx - 需要重定向，浏览器直接跳转</li>
<li>4xx - 客户端请求错误，如404</li>
<li>5xx - 服务器端错误</li>
</ul>
<p><strong>跨域</strong></p>
<ul>
<li>什么是跨域</li>
<li>JSONP</li>
<li>服务器端设置http header</li>
</ul>
<p><strong>什么是跨域</strong></p>
<ul>
<li>浏览器有同源策略，不允许ajax访问其他域接口</li>
<li>你的网站</li>
<li>别的网站</li>
<li>跨域条件：协议、域名、端口，有一个不同就算跨域</li>
</ul>
<p><strong>可以跨域的三个标签</strong></p>
<ul>
<li>但是有三个标签允许跨域加载资源</li>
<li>img src=xxx</li>
<li>link href=xxxx</li>
<li>script src=xxx</li>
</ul>
<p><strong>三个标签的场景</strong></p>
<ul>
<li>img用于打点统计，统计网站可能是其他域</li>
<li>link、script可以使用CDN,CDN的也是其他域</li>
<li>script可以用于JSONP。</li>
</ul>
<p><strong>跨域注意事项</strong></p>
<ul>
<li>所有的跨域请求都必须经过信息提供方允许</li>
<li>如果未经允许即可获取，那是浏览器同源策略出现漏洞</li>
</ul>
<p><strong>JSONP实现原理</strong></p>
<ul>
<li>加载<a href="http://coding.m.imooc.com/classindex.html" target="_blank" rel="noopener">http://coding.m.imooc.com/classindex.html</a></li>
<li>不一定服务器端真正有一个classindex.html文件</li>
<li>服务器可以根据请求，动态生成一个文件，返回</li>
<li>同理于script src=”<a href="http://coding.m.imooc.com/api.js&quot;" target="_blank" rel="noopener">http://coding.m.imooc.com/api.js&quot;</a></li>
</ul>
<hr>
<pre><code>window.callback = function (data) {
    // 这是我们跨域得到信息
    console.log(data)
}
&lt;/script&gt;
&lt;script src=&quot;http://coding.m.imooc.com/api.js&quot;&gt;&lt;/script&gt;
&lt;!-- 以上将返回 callback({x:100, y:200}) --&gt;
</code></pre><p><strong>服务器端设置http header</strong></p>
<ul>
<li>另外一个解决跨域的简洁方法，需要服务器端来做</li>
<li>但是作为交互方，我们必须知道这个方法</li>
<li>是将来解决跨域问题的一个趋势</li>
</ul>
<hr>
<pre><code>// 注意：不同后端语言的写法可能不一样

// 第二个参数填写允许跨域的域名城，不建议直接写“*”
response.setHeader(&quot;Access-Control-Allow-Origin&quot;, 
&quot;http://a.com, http://b.com&quot;);
response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-
Requested-With&quot;);
response.setHeader(&quot;Access-Control-Allow-Methods&quot;,
 &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);

// 接收跨域的cookie
response.setHeader(&quot;Access-Control-Allow-Credentials&quot;,
 &quot;true&quot;);
</code></pre><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><strong>题目</strong></p>
<ul>
<li>请描述一下cookie，sessionStorage和localStorage的区别？</li>
</ul>
<p><strong>cookie</strong></p>
<ul>
<li>本身用于客户端和服务器端通信</li>
<li>但是它有本地存储的功能，于是就被“借用”</li>
<li>使用document.cookie=…获取和修改即可</li>
</ul>
<p><strong>cookie用于存储的缺点</strong></p>
<ul>
<li>存储量太小，只有4KB</li>
<li>所有http请求都带着，会影响获取资源的效率</li>
<li>API简单，需要封装才能用 document.cookie = …</li>
</ul>
<p><strong>locationStorage和sessionStorage</strong></p>
<ul>
<li>HTML5专门为存储而设计，最大容量5M</li>
<li>API简答易用：</li>
<li>localStorage.setItem(key,value); localStorage.getItem(key);</li>
</ul>
<p>坑</p>
<ul>
<li>iOS safari隐藏模式下</li>
<li>localStorage.getItem会报错</li>
<li>建议统一使用try-catch封装</li>
</ul>
<p><strong>cookie sessionStorage localStorage的区别</strong></p>
<ul>
<li>容量</li>
<li>是否会携带到ajax中</li>
<li>API易用性</li>
</ul>
<h2 id="运行环境-1"><a href="#运行环境-1" class="headerlink" title="运行环境"></a>运行环境</h2><p><strong>关于开发环境</strong></p>
<ul>
<li>面试官想通过开发环境了解面试者的经验</li>
<li>开发环境，最能体现工作产出的效率</li>
<li><p>会以聊天的形式为主，而不是出具体的问题</p>
</li>
<li><p>IDE</p>
</li>
<li>git</li>
<li>JS模块化</li>
<li>打包工具</li>
<li>上线回滚的流程</li>
</ul>
<p><strong>常用Git命令</strong></p>
<ul>
<li>git add .</li>
<li>git checkout xxx</li>
<li>git commit -m “xxx”</li>
<li>git push origin master</li>
<li>git pull origin master</li>
<li>分支</li>
<li>git branch</li>
<li>git checkout -b xxx/ git checkout xxx</li>
<li>git merge xxx</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>这本身就是一个面试的问题</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>不使用模块化的情况</li>
<li>使用模块化</li>
<li>AMD</li>
<li>CommonJS</li>
</ul>
<p><strong>不使用模块化</strong></p>
<ul>
<li>util.js getFormatDate函数</li>
<li>a-util.js aGetFormatDate函数 使用getFormatDate</li>
<li>a.js aGetFormatDate</li>
</ul>
<p>代码</p>
<pre><code>// util.js
function getFormatDate(date, type) {
    // type === 1 返回 2017-06-15
    // type === 2 返回 2017年6月15日 格式
    // ---
}

// a-util.js
function aGetFormatDate(date) {
    // 要求返回 2017年6月15日 格式
    return getFormatDate(date, 2)
}

// a.js
var dt = new Date()
console.log(aGetFormatDate(dt))
</code></pre><p>使用</p>
<pre><code>&lt;script src=&quot;util.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;a-util.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;
&lt;!-- 1. 这些代码中的函数必须是全局变量，才能暴露给使用方。全局
变量污染 --&gt;
&lt;!-- 2. a.js知道要引用 a-util.js，但是他知道还需要依赖
util.js吗？ --&gt;
</code></pre><p><strong>使用模块化</strong></p>
<pre><code>// util.js
export {
    getFormatDate: function (date, type) {
        // type === 1 返回 2017-06-15
        // type === 2 返回 2017年6月15日 格式
    }
}

// a-util.js
var getFormatDate = require(&apos;util.js&apos;)
export {
    aGetFormatDate: function (date) {
        // 要求返回 2017年6月15日 格式
        return getFormatDate(date, 2)
    }
}

// a.js
var aGetFormatDate = require(&apos;a-util.js&apos;)
var dt = new Date()
console.log(aGetFormatDate(dt))

// 直接`&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;`,其他的根据依赖关系自动引用
// 那两个函数，没必要做成全局变量，不会带来污染和覆盖
</code></pre><p><strong>AMD</strong></p>
<ul>
<li>require.js requirejs.org/</li>
<li>全局define函数</li>
<li>全局require函数</li>
<li>依赖JS会自动、异步加载</li>
</ul>
<p><strong>使用require.js</strong></p>
<pre><code>// util.js
define(function() {
    return {
        getFormatDate: function(date, type) {
            if (type === 1) {
                return &apos;2017-06-15&apos;
            }
            if (type === 2) {
                return &apos;2017年6月15日&apos;
            }
        }
    }
})

// a-util.js
define([&apos;./util.js&apos;], function(util) {
    return {
        aGetFormatDate: function(date) {
            return util.getFormatDate(date, 2)
        }
    }
})

// a.js
define([&apos;./a-util.js&apos;], function(aUtil){
    return {
        printDate: function (date) {
            console.log(aUtil.aGetFormatDate(date))
        }
    }
})

// main.js
require([&apos;./a.js&apos;], function(a) {
    var date = new Date()
    a.printDate(date)
})
</code></pre><p>引用main.js</p>
<pre><code>&lt;script src=&quot;/require.min.js&quot; data-main=&quot;./main.js&quot;&gt;&lt;/
script&gt;
</code></pre><p><strong>CommonJS</strong></p>
<ul>
<li>nodejs模块化规范，现在被大量用前端，原因：</li>
<li>前端开发依赖的插件和库，都可以用npm中获取</li>
<li>构建工具的高度自动化，使得使用npm的成本非常低</li>
<li>CommonJS不会异步加载JS，而是同步一次性加载出来</li>
</ul>
<p><strong>使用CommonJS</strong></p>
<pre><code>// util.js 
module.exports = {
    getFormatDate: function (date, type) {
        if(type === 1) {
            return &apos;2017-06-15&apos;
        }
        if (type === 2) {
            return &apos;2017年6月15日&apos;
        }
    }
}

// a-util.js
var util = require(&apos;util.js&apos;)
module.exports = {
    aGetFormatDate: function (date) {
        return util.getFormatDate(date, 2)
    }
}
</code></pre><p>使用</p>
<ul>
<li>需要构建工具支持</li>
<li>一般和npm一起使用</li>
</ul>
<p><strong>AMD和CommonJS的使用场景</strong></p>
<ul>
<li>需要异步加载JS，使用AMD</li>
<li>使用了npm之后建议使用CommonJS</li>
</ul>
<h2 id="上线和回滚"><a href="#上线和回滚" class="headerlink" title="上线和回滚"></a>上线和回滚</h2><p><strong>知识点</strong></p>
<ul>
<li>上线和回滚的基本流程</li>
<li><p>linux基本命令</p>
<p><strong>上线回滚流程介绍</strong></p>
</li>
<li><p>是非常重要的开发环节</p>
</li>
<li>各个公司的具体流程不同</li>
<li>由专门的工具后者系统完成，我们无需关心细节</li>
<li>如果你没有参与过，面试时也要说出要点</li>
<li>只讲要点，具体实现无法讲解</li>
</ul>
<p><strong>上线流程要点</strong></p>
<ul>
<li>将测试完成的代码提交到git版本库的master分支</li>
<li>将当前服务器的代码全部打包并记录版本号，备份</li>
<li>将master分支的代码提交覆盖到线上服务器，生成新版本号</li>
</ul>
<p><strong>回滚流程要点</strong></p>
<ul>
<li>将当前服务器的代码打包并记录版本号，备份</li>
<li>将备份的上一个版本号解压，覆盖到线上服务器，并生成新的版本号</li>
</ul>
<p><strong>linux基本命令</strong></p>
<ul>
<li>服务器使用linux居多，server版，只有命令行</li>
<li>测试环境要匹配线上环境，因此也是linux</li>
<li>经常需要登录测试机来自己配置、获取数据</li>
</ul>
<p>mkdir ls ll  cd pwd cp(拷贝) mv(移动) </p>
<p>rm(删除) vi cat、head、tail(看) grep(搜索)</p>
<h2 id="运行环境-2"><a href="#运行环境-2" class="headerlink" title="运行环境"></a>运行环境</h2><ul>
<li>浏览器就可以通过访问链接来得到页面的内容</li>
<li>通过绘制和渲染，显示出页面的最终的样子</li>
<li>整个过程中，我们需要考虑什么问题？</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>页面加载过程</li>
<li>性能优化</li>
<li>安全性</li>
</ul>
<p><strong>题目</strong></p>
<ul>
<li>从输入url得到html的详细过程</li>
<li>window.onload和DOMContentLoaded的区别</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>加载资源的形式</li>
<li>加载一个资源的过程</li>
<li>浏览器渲染页面的过程</li>
</ul>
<p><strong>加载资源的形式</strong></p>
<ul>
<li>输入url(或跳转页面)加载html</li>
<li><a href="http://coding.m.imooc.com" target="_blank" rel="noopener">http://coding.m.imooc.com</a></li>
<li>加载html中的静态资源</li>
<li>script src=”/static/js/jquery.js”</li>
</ul>
<p><strong>加载一个资源的过程</strong></p>
<ul>
<li>浏览器根据DNS服务器得到域名的IP地址</li>
<li>向这个IP的机器发送http请求</li>
<li>服务器收到、处理并返回http请求</li>
<li>浏览器得到返回内容</li>
</ul>
<p><strong>浏览器渲染页面的过程</strong></p>
<ul>
<li>根据HTML结构生成DOM Tree</li>
<li>根据CSS生成CSSOM</li>
<li>将DOM和CSSOM整合形成RenderTree</li>
<li>根据RenderTree开始渲染和展示</li>
<li>遇到script时，会执行并阻塞渲染(因为js有权利改变DOM结构)</li>
</ul>
<p><strong>window.onload和DOMContentLoaded</strong></p>
<pre><code>window.addEventListener(&apos;load&apos;, function() {
    // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener(&apos;DOMContentLoaded&apos;, function(){
    // DOM渲染完即可执行，此时图片、视频还可能没有加载完
})
</code></pre><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><strong>原则</strong></p>
<ul>
<li>多使用内存、缓存或者其他方法</li>
<li>减少CPU计算、较少网络</li>
</ul>
<p><strong>从哪里入手</strong></p>
<ul>
<li>加载页面和静态资源</li>
<li>页面渲染</li>
</ul>
<p><strong>加载资源优化</strong></p>
<ul>
<li>静态资源的压缩合并</li>
<li>静态资源缓存</li>
<li>使用CDN让资源加载更快</li>
<li>使用SSR后端渲染，数据直接输出到HTML中</li>
</ul>
<p><strong>渲染优化</strong></p>
<ul>
<li>CSS放前面，JS放后面</li>
<li>懒加载（图片懒加载、下拉加载更多）</li>
<li>减少DOM查询，对DOM查询做缓存</li>
<li>减少DOM操作，多个操作尽量合并在一起执行</li>
<li>事件节流</li>
<li>尽早执行操作（如DOMContentLoaded）</li>
</ul>
<p><strong>资源合并</strong></p>
<pre><code>&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;
</code></pre><hr>
<pre><code>&lt;script src=&quot;abc.js&quot;&gt;&lt;/script&gt;
</code></pre><p><strong>缓存</strong></p>
<ul>
<li>通过连接名称控制缓存</li>
<li>script src=”abc_1.js”</li>
<li>只有内容改变的时候，链接名称才会改变</li>
<li>script src=”abc_2.js”</li>
</ul>
<p><strong>CDN</strong></p>
<p><strong>使用SSR后端渲染</strong></p>
<ul>
<li>现在Vue React 提出了这样的概念</li>
<li>其实jsp php asp 都属于后端渲染</li>
</ul>
<p><strong>懒加载</strong></p>
<pre><code>&lt;img id=&quot;img1&quot; src=&quot;preview.png&quot; data-
realsrc=&quot;abc.png&quot;&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var img1 = document.getElementById(&apos;img1&apos;)
    img1.src = img1.getAttribute(&apos;data-realsrc&apos;)
&lt;/script&gt;
</code></pre><p><strong>缓存DOM查询</strong></p>
<pre><code>// 未缓存DOM查询
var i 
for(i = 0; i &lt; document.getElementsByTagName
(&apos;p&apos;).length; i++) {
    // todo
}

// 缓存了DOM查询
var pList = document.getElementsByTagName(&apos;p&apos;)
var i 
for(i = 0; i &lt; pList.length; i++) {
    // todo
}
</code></pre><p><strong>合并DOM插入</strong></p>
<pre><code>var listNode = document.getElementById(&apos;list&apos;)

// 要插入10个li标签
var frag = document.createDocumentFragment();
var x, li;
for(x = 0; x &lt; 10; x++) {
    li = document.createElement(&apos;li&apos;);
    li.innerHTML = &quot;List item &quot; + x;
    frag.appendChild(li);
}

listNode.appendChild(frag);
</code></pre><p><strong>事件节流</strong></p>
<pre><code>var textarea = document.getElementById(&apos;text&apos;)
var timeoutId
textarea.addEventListener(&apos;keyup&apos;, function() {
    if(timeoutId) {
        clearTimeout(timeoutId)
    }
    timeoutId = setTimeout(function() {
        // 触发 change事件
    }, 100)
})
</code></pre><p><strong>尽早操作</strong></p>
<pre><code>window.addEventListener(&apos;load&apos;, function() {
    // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener(&apos;DOMContentLoaded&apos;, function
() {
    // DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
</code></pre><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul>
<li>综合性的问题：场景的前端安全问题有哪些</li>
</ul>
<p><strong>知识点</strong></p>
<ul>
<li>XSS跨站请求攻击</li>
<li>XSRF跨站请求伪造</li>
</ul>
<p><strong>XSS</strong></p>
<ul>
<li>在新浪博客写一篇文章，同时偷偷插入一段script</li>
<li>攻击代码中，获取cookie，发送自己的服务器</li>
<li>发布博客，有人查看博客内容</li>
<li>会把查看者的cookie发送到攻击者的服务器</li>
</ul>
<p>预防 </p>
<ul>
<li>前端替换关键字，例如替换 &lt; 为 &lt; &gt; 为 &gt;</li>
<li>后端替换</li>
</ul>
<p><strong>XSRF</strong></p>
<ul>
<li>你已登录一个购物网站，正在浏览商品</li>
<li>该网站付费接口是xxx.com/pay?id=100但是没有任何验证</li>
<li>然后你收到一封邮件，隐藏着img src = xxx.com?id=100</li>
<li>你查看邮件的时候，就已经悄悄的付费购买了 </li>
</ul>
<p>解决</p>
<ul>
<li>增加验证验证流程，如输入指纹、密码、短信验证码</li>
</ul>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p><strong>简历</strong></p>
<ul>
<li>简洁明了，重点突出项目经历和解决方案</li>
<li>把个人博客放在简历中，并且定期维护更新博客</li>
<li>把个人的开源项目放在简历中，并维护开源项目</li>
<li>简历千万不要造假，要保持能力和经历上的真实性</li>
</ul>
<p><strong>面试过程中</strong></p>
<ul>
<li>如何看待加班？加班就像借钱，救急不救穷</li>
<li>千万不可挑战面试官，不要反考面试官</li>
<li>学会给面试官惊喜，但不要太多</li>
<li>遇到不会回答的问题，说出你知道的也可以</li>
<li>谈谈你的缺点 — 说一下你最近正在学什么就可以了(你不会什么)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/杂记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/杂记/" itemprop="url">杂记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:48:12+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>css中两个类选择器之间没有空格形成多类选择器， 有空格形成后代选择器  。</strong></p>
<hr>
<p><strong>CSS hover，没有延迟</strong></p>
<hr>
<p><p-column styleclass="txt-center overline" field="stationName" header="配电站"><br>      <ng-template let-unit="" let-row="rowData" ptemplate="body"><br>      &lt;span <strong>title=”“</strong>&gt;<br>    </ng-template><br></p-column></p>
<hr>
<h2 id="css3修改滚动条样式"><a href="#css3修改滚动条样式" class="headerlink" title="css3修改滚动条样式"></a>css3修改滚动条样式</h2><p><strong>1.滚动条组成</strong></p>
<p>::-webkit-scrollbar 滚动条整体部分</p>
<p>::-webkit-scrollbar-thumb  滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）</p>
<p>::-webkit-scrollbar-track  滚动条的轨道（里面装有Thumb）</p>
<p>::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。</p>
<p>::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去）</p>
<p>::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处</p>
<p>::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件</p>
<p><strong>2.简洁版demo</strong></p>
<p>/<em>定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸</em>/ </p>
<pre><code>::-webkit-scrollbar 
{ 
    width: 16px;     
    height: 16px;     
    background-color: #F5F5F5; 
} 
</code></pre><p>/<em>定义滚动条轨道 内阴影+圆角</em>/ </p>
<pre><code>::-webkit-scrollbar-track 
{ 
    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3); 
    border-radius: 10px; 
    background-color: #F5F5F5; 
} 
</code></pre><p>/<em>定义滑块 内阴影+圆角</em>/ </p>
<pre><code>::-webkit-scrollbar-thumb 
{ 
    border-radius: 10px; 
    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); 
    background-color: #555; 
} 
</code></pre><hr>
<h1 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h1><p>惰性求值（Lazy evaluation）是在需要时才进行求值的计算方式。惰性求值自然地在数据结构中包含递归，可以以简单的方式表示无限的概念，这种方式有利于程序的模块化。</p>
<p>Haskell语言以采用惰性求值而广为人熟知。Scheme也部分采用了惰性求值。</p>
<hr>
<p><strong>0.1 + 0.2 - 0.3</strong></p>
<p>// 5.551115123125783e-17</p>
<p>0.1 + 0.2 === 0.3 // false</p>
<hr>
<h2 id="Array-prototype-slice-call-方法详解"><a href="#Array-prototype-slice-call-方法详解" class="headerlink" title="Array.prototype.slice.call()方法详解"></a>Array.prototype.slice.call()方法详解</h2><p>多次用到 Array.prototype.slice.call(arguments, 1)，不就是等于 arguments.slice(1) 吗？像前者那样写具体的好处是什么？这个很多js新手最疑惑的地方。那为什么呢？</p>
<p>因为arguments并不是真正的数组对象，只是与数组类似而已，所以它并没有slice这个方法，而Array.prototype.slice.call(arguments, 1)可以理解成是让arguments转换成一个数组对象，让arguments具有slice()方法。要是直接写arguments.slice(1)会报错。</p>
<p>typeof arguments===”object” //而不是 “Array”</p>
<hr>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>
<hr>
<p>在JavaScript中，如果你在一个函数体内又用到了function关键字，那么你将会生成一个闭包(Closure)。</p>
<p>闭包含有当前作用域内的所有变量接入。</p>
<p>每一次对外部函数的调用都会产生一个独立的包含本地变量的闭包。</p>
<p><strong>闭包到底什么用</strong></p>
<p>可以在函数外部读取函数内部的变量<br>可以将这些变量的值在内存中持久化</p>
<hr>
<h1 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h1><p>IIFE（立即调用函数表达式）是一个在定义时就会立即执行的JavaScript函数。</p>
<p>这是一个被称为<strong>自执行匿名函数</strong>的设计模式，主要包含两部分。第一部分是包围在<strong>圆括号运算符</strong>（）里的一个匿名函数，这个匿名函数拥有独立的词法作用域，这不仅避免了外界访问此IIFE中的变量，而且又不会污染全局作用域。</p>
<p>第二部分再使用()创建了一个立即执行函数表达式，JavaScript引擎到此将直接执行函数。</p>
<hr>
<p>箭头函数导致this总是指向函数定义生效时所在的对象</p>
<hr>
<p>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行</p>
<hr>
<p>Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p>
<hr>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<hr>
<p>创建XMLHttpRequest对象的语法：</p>
<p>xmlhttp = new XMLHttpRequest();</p>
<p>老版本的Internet Explorer（IE5和IE6）使用ActiveX对象：</p>
<p>xmlhttp = new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<hr>
<p>echarts: itemStyle属性要加normal属性</p>
<hr>
<h1 id=""><a href="#" class="headerlink" title=""></a><ng-container></ng-container></h1><p>使用<ng-container>把一些兄弟元素归为一组</ng-container></p>
<p>Angular的<ng-container>是一个分组元素，但它不会污染样式或元素布局，因为Angular压根不会把它放进DOM中。</ng-container></p>
<p><ng-container>是一个由Angular解析器负责识别处理的语法元素。它不是一个指令、组件、类或接口，更像是JavaScript中if块中的花括号。</ng-container></p>
<p>没有这些花括号，JavaScript只会执行第一句，而你原本的意图是把其中的所有语句都视为一体来根据条件执行。而<ng-container>满足了Angular模板中类似的需求。</ng-container></p>
<hr>
<p><a href="https://www.chungold.com/" target="_blank" rel="noopener">https://www.chungold.com/</a></p>
<p>账号 <a href="mailto:hon_ghuan1688@126.com" target="_blank" rel="noopener">hon_ghuan1688@126.com</a></p>
<p>密码  zhnyfw@001</p>
<hr>
<p>background-clip 属性<br>background-clip属性指定背景绘制区域</p>
<p>语法<br>background-clip:</p>
<pre><code>border-box // 背景到border
padding-box // 背景到padding
content-box // 背景到content
</code></pre><hr>
<p>background-origin属性</p>
<p>background-origin属性指定background-position属性应该是相对位置</p>
<hr>
<p>background-size</p>
<p>第二个值，不写默认为auto</p>
<hr>
<p>background:linear-gradient(angle …);</p>
<p>角度说明</p>
<p>0deg将创建一个从上到下的渐变，90deg将创建一个从左到右的渐变。</p>
<hr>
<p>Internet Explorer 渐变</p>
<pre><code>语法    
filter:progid:DXImageTransform.Microsoft.gradient
(startColorstr=&apos;startColor&apos;, 
endColorstr=&apos;endColor&apos;,GradientType(类型)=(0,1,2));
</code></pre><hr>
<p>常见的闭包：</p>
<pre><code>function wait(message) {
    setTimeout(function timer() {
        console.log(message);
    }, 1000);
}
wait(&apos;Hello closure&apos;);
</code></pre><p>只要使用了回调函数，实际上就是在使用闭包！</p>
<hr>
<p>模块有两个主要特征：</p>
<p>1.为创建内部作用域而调用了一个包装函数；</p>
<p>2.包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p>
<hr>
<p>CommonJS // module.exports  require 同步</p>
<p>cmd  // define (module.exports) require 异步</p>
<hr>
<pre><code>&lt;script&gt;标签
CommonJS
AMD(Asynchronous Module Definition)
CMD(Common Module Definition)
UMD(Universal Module Definition)
ES6模块
</code></pre><hr>
<pre><code>var request;
if (window.XMLHttpRequest) {
    request = new XMLHttpRequest();
} else {
    request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
}
</code></pre><p>通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。</p>
<hr>
<p>字符串方法</p>
<p>ES7提案</p>
<p>要安装补丁库</p>
<pre><code>npm install babel-polyfill --save-dev
</code></pre><hr>
<p>es6标签模板</p>
<p>常用场景：防止XS攻击</p>
<p>多语言转换</p>
<pre><code>{
    let user={
        name: &apos;list&apos;,
        info: &apos;hello world&apos;
    };
    console.log(abc`i am ${user.name},${user.info}`);
    function abc(s,v1,v2){
        console.log(s,v1,v2);
        return s+v1+v2
    }
}
</code></pre><hr>
<p>ES6遍历字符串</p>
<p>let of</p>
<p>可以遍历字节大于两位的字符串</p>
<p>padStart</p>
<p>padEnd</p>
<p>可以用来在1前后加零</p>
<hr>
<pre><code>Array.from([1,3,5],function(item){return item*2});

function(item){return item*2} 相当于map映射
</code></pre><hr>
<p>includes对比find和findIndex对NaN处理不会报错</p>
<p>并且能找NaN</p>
<pre><code>[1,2,NaN].includes(NaN) ===&gt; true
</code></pre><hr>
<pre><code>{
    let x=&apos;test&apos;;
    function test2(x,y=x){
        console.log(&apos;作用域&apos;，x,y);
        //  kill kill
    }
    test2(&apos;kill&apos;);
}
</code></pre><hr>
<p>es6尾调用：函数的最后是不是一个函数</p>
<pre><code>function tail(x){
    console.log(&apos;tail&apos;,x);
}
function fx(x){
    return tail(x)
}
fx(123)
</code></pre><p>嵌套函数，依赖函数使用尾调用</p>
<hr>
<p><strong>es6属性表达式</strong></p>
<p>key值因为另一个变量而变化</p>
<pre><code>{
    let a=&apos;b&apos;;
    let es5_obj={
        a:&apos;c&apos;,
        b:&apos;c&apos;
    };

    let es6_obj={
        [a]:&apos;c&apos;
    }

    console.log(es5_obj,es6_obj);
}
</code></pre><hr>
<p>es对象</p>
<pre><code>Object.assign()属于浅拷贝

只拷贝自身对象的属性

不拷贝继承的属性和对象中不可枚举的属性
</code></pre><hr>
<p>es Symbol用法</p>
<pre><code>{
    let a1=Symbol.for(&apos;abc&apos;);
    let obj={
        [a1]:&apos;123&apos;,
        &apos;abc&apos;:345,
        &apos;c&apos;:456
    }
}
</code></pre><p>但for ..in..和let …of…拿不到Symbol值的</p>
<p>要用</p>
<pre><code>Object.getOwnPropertySymbols(obj).forEach(function(item){
    console.log(obj[item]);
})
</code></pre><p>两边都取到</p>
<pre><code>Reflect.ownKeys(obj).forEach(function(item){
    console.log(&apos;ownkeys&apos;,item,obj[item]);
})
</code></pre><hr>
<p>ES6Map</p>
<pre><code>Map是对Object的补充，key值可以是任意类型
</code></pre><hr>
<p>ES6Set</p>
<p>去重效果</p>
<pre><code>let arr=[1,2,3,1,&apos;2&apos;];
let list2=new Set(arr);

console.log(&apos;unique&apos;,list2);
</code></pre><p>但是Set在去重时不会转换数据类型。</p>
<hr>
<p>一、</p>
<pre><code>weakSet和Set支持的数据类型不一样

weakSet的元素只能是对象
</code></pre><p>二、</p>
<pre><code>weakSet的对象是弱引用

===》就是在其他地方有没有被引用过，不会跟垃圾回收机制挂钩上

weakSet添加了一个值只是对象的引用，不会整个值拷过来，是不是垃
圾回收掉，不会去检测
</code></pre><p>三、</p>
<pre><code>不能遍历
</code></pre><hr>
<p>es6 Map</p>
<pre><code>{
    let map = new Map();
    let arr=[&apos;123&apos;];

    map.set(arr,456);

    console.log(&apos;map&apos;,map,map.get(arr));
}

{
    let map = new Map([[&apos;a&apos;,123],[&apos;b&apos;,456]]);
    console.log(&apos;map args&apos;,map);
}
</code></pre><hr>
<h2 id="数组结构横向对比，增，查，改，删"><a href="#数组结构横向对比，增，查，改，删" class="headerlink" title="数组结构横向对比，增，查，改，删"></a>数组结构横向对比，增，查，改，删</h2><pre><code>{
    let map=new Map();
    let array=[];
    // 增
    map.set(&apos;t&apos;,1);
    array.push({t:1});

    console.info(&apos;map-array&apos;,map.array);

    // 查
    let map_exist=map.has(&apos;t&apos;);
    let array_ezist=array.find(item=&gt;item.t);
    console.info(&apos;map-array&apos;,map_exist,array_exist);

    //改
    map.set(&apos;t&apos;,2);
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;);
    console.info(&apos;map-array-modify&apos;,map,array);

    //删
    map.delete(&apos;t&apos;);
    let index = array.findIndex(item=&gt;item.t);
    array.splice(index,1);
}
</code></pre><hr>
<p><strong>Set和array的对比</strong></p>
<pre><code>{
    let set = new Set();
    let array=[];

    // 增
    set.add({t:1});
    array.push({t:1});

    console.log(&apos;set-array&apos;,set,array);

    // 查
    let set_exist=set.has({t:1}); 这里的{t:1}与增加时的不一样
    array同上

    // 改
    set.forEach(item=&gt;item.t?item.t=2:&apos;&apos;);
    array.forEach(item=&gt;item.t?item.t=2:&apos;&apos;);

    // 删
    set.forEach(item=&gt;item.t?set.delete(item):&apos;&apos;);
    array同上
}
</code></pre><hr>
<h2 id="map-set-object对比"><a href="#map-set-object对比" class="headerlink" title="map,set,object对比"></a>map,set,object对比</h2><pre><code>{
    let item={t:1};
    let map = new Map();
    let set = new Set();
    let obj = {};

    // 增
    map.set(&apos;t&apos;,1);
    set.add(item);
    obj[&apos;t&apos;]=1;

    console.info(&apos;map-set-obj&apos;,obj,map,set);

    //查

    console.log({
        map_exist:map.has(&apos;t&apos;),
        set_exist:set.has(item),
        obj_exist: &apos;t&apos; in obj
    })

    // 改
    map.set(&apos;t&apos;,2);
    item.t=2;
    obj[&apos;t&apos;]=2;

    //删除
    map.delete(&apos;t&apos;);
    set.delete(item);
    delete obj[&apos;t&apos;];

}
</code></pre><hr>
<p>Proxy可以认为是代理或拦截</p>
<pre><code>{
    let obj={
        time:&apos;2017-03-11&apos;;
        name:&apos;net&apos;,
        _r:123
    };

    let monitor=new Proxy(obj,{
        // 拦截对象属性的读取
        get(target,key){
            return target[key].replace(&apos;2017&apos;,&apos;2018&apos;)
        }
        // 拦截对象设置属性
        set(target,key,value){
            if(key===&apos;name&apos;){
                return target[key]=value;
            } else {
                return target[key];
            }
        }
        // 拦截key in object操作
        has(target,key){
            if(key===&apos;name&apos;){
                return target[key]
            } else {
                return false;
            }
        }
        // 拦截delete
        deleteProperty(target,key){
            if(key.indexOf(&apos;_&apos;)&gt;-1){
                delete target[key];
                return true;
            }else {
                return target[key]
            }
        }
        // 拦截Object.keys,Object.getOwnPropertySymbols,
        Object.getOwnPropertyNames

        ownKeys(target){
            return Object.keys(target).filter
            (item=&gt;item!=&apos;time&apos;)
        }
    });

    console.log(&apos;get&apos;,monitor.time); // 2018

    monitor.time=&apos;2018&apos;;
    monitor.name=&apos;mukewang&apos;;
    console.log(&apos;set&apos;,monitor.time,mointor);
    // set 2018-03-11
       Proxy{time: &quot;2017-03-11&quot;, name: &quot;mukewang&quot;, _r: 123}

    console.log(&apos;has&apos;, &apos;name&apos; in monitor,&apos;time&apos; in 
    monitor);
    // has true false

    delete monitor.time;
    console.log(&apos;delete&apos;,monitor);
    // delete
       Proxy{time: &quot;2017-03-11&quot;, name: &quot;mukewang&quot;, _r: 123}

    delete monitor._r;
    console.log(&apos;delete&apos;,monitor);
    // delete
       Proxy{time: &quot;2017-03-11&quot;, name: &quot;mukewang&quot;}

    console.log(&apos;ownKeys&apos;,Object.keys(monitor));
    // ownKeys[&quot;name&quot;,&quot;_r&quot;]

}
</code></pre><hr>
<p>Reflect用途</p>
<pre><code>obj同上
Reflect.get(obj,&apos;time&apos;);

Reflect.set(obj,&apos;name&apos;,&apos;mukewang&apos;);

Reflect.has(obj,&apos;name&apos;);
</code></pre><hr>
<p>Proxy和Reflect一起的实例用途</p>
<pre><code>{
    function validator(target,validator){
        return new Proxy(target,{
            _validator:validator,
            set(target,key,value,proxy){
                if(target.hasOwnProperty(key)){
                    let va=this._validator[key];
                    if(!!va(value)){
                        return Reflect.set
                        (target,key,value,proxy)
                    }else{
                        throw Error(`不能设置${key}到
                        ${value}`)
                    }
                }else{
                    throw Error(`${key} 不存在`)
                }
            }
        })
    }

    const personValidators={
        name(val){
            return typeof val===&apos;string&apos;
        },
        age(val){
            return typeof val===&apos;number&apos; &amp;&amp; val&gt;18
        }
    }

    class Person{
        constructor(name,age){
            this.name=name;
            this.age=age;
            return validator(this,personValidators)
        }
    }

    const person=new Person(&apos;lilei&apos;,30);

    console.log(person);
    // Proxy {name: &quot;lilei&quot;, age: 30}

    person.name=48;
    // 报错 不能设置name到48
}
</code></pre><p>// 应用==》校验可以加在personValidators中</p>
<hr>
<p>在类的继承中如果用super传递参数super函数放在函数的第一行</p>
<p>静态方法通过类去调用而不是通过类的实例去调用</p>
<hr>
<pre><code>{
    let ajax=function(callback){
        相当于执行完ajax执行callback
        即callback相当于回调
    };
}

{
    // 基本定义
    let ajax = function(callback) {
        console.log(&apos;执行&apos;);
        setTimeout(function() {
            callback &amp;&amp; callback.call()
        }, 1000);
    };
    ajax(function() {
        console.log(&apos;timeout1&apos;);
    })
}
</code></pre><hr>
<p>iterator在数组中的应用</p>
<pre><code>{
  let arr=[&apos;hello&apos;,&apos;world&apos;];
  let map=arr[Symbol.iterator]();
  console.log(map.next());
  console.log(map.next());
  console.log(map.next());
}

{value: &quot;hello&quot;, done: false}
{value: &quot;world&quot;, done: false}
{value: undefined, done: true}
</code></pre><p>Object没有iterator接口，因为它的数据是我们填充的，不知道里面的数据需要怎么遍历</p>
<pre><code>{
    let obj = {
        start: [1, 3, 2],
        end: [7, 9, 8],
        [Symbol.iterator]() {
            let self = this;
            let index = 0;
            let arr = self.start.concat(self.end);
            let len = arr.length;
            return {
                next() {
                    if (index &lt; len) {
                        return {
                            value: arr[index++],
                            done: false
                        }
                    } else {
                        return {
                            value: arr[index++],
                            done: true
                        }
                    }
                }
            }
        }
    }
    for (const key of obj) {
        console.log(key);
        // 1 3 4  7 9 8
    }
}
</code></pre><p>注意一、</p>
<pre><code>不管什么样的数据结构，可能简单或复杂
自定义部署要按照以上步骤

要返回next()方法
</code></pre><hr>
<p>Generator函数和iterator接口的关系</p>
<p>任意一个对象或接口都是部署在Symbol.iterator属性上的</p>
<p>generator就是一个遍历器生成函数</p>
<p>状态机</p>
<pre><code>{
    let state = function*() {
        while (1) {
            yield &apos;A&apos;;
            yield &apos;B&apos;;
            yield &apos;C&apos;;
        }
    }
    let status = state();
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());    
    // 循环打印
}
</code></pre><p>async和await是generator的语法糖</p>
<pre><code>{
    let state = async function() {
        while (1) {
            await &apos;A&apos;;
            await &apos;B&apos;;
            await &apos;C&apos;;
        }
    }
    let status = state();
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());
    console.log(status.next());
}
</code></pre><p>实例抽奖</p>
<pre><code>{
    let draw = function(count) {
        // 具体抽奖逻辑
        console.log(`剩余${count}次`)
    }

    let residue = function*(count) {
        while (count &gt; 0) {
            count--;
            yield draw(count);
        }
    }

    let star = residue(5);
    let btn = document.createElement(&apos;button&apos;);
    btn.id = &apos;start&apos;;
    btn.textContent = &apos;抽奖&apos;;
    document.body.appendChild(btn);
    document.getElementById(&apos;start&apos;).addEventListener
    (&apos;click&apos;, function() {
        star.next();
    }, false)
}
</code></pre><p>// 关于长轮询(服务端的某一个状态不断变化，需要定时取状态，因为HTTP是无状态的连接)</p>
<p>怎么取到状态一个是长轮询，另一个是websocket但websocket浏览器兼容性不好</p>
<p>长轮询就是通过定时器不断的访问一个接口</p>
<pre><code>{
    // 长轮询
    let ajax = function*() {
        yield new Promise(function(resolve, reject) {
            // 模拟http请求
            setTimeout(function() {
                resolve({ code: 0 })
            }, 200)
        })
    }

    let pull = function() {
        let generator = ajax();
        let step = generator.next();
        step.value.then(function(d) {
            if (d.code != 0) {
                setTimeout(function() {
                    console.log(&apos;wait&apos;);
                    pull()
                }, 1000);
            } else {
                console.log(d);
            }
        })
    }

    pull();
}
</code></pre><hr>
<p>修饰器三点</p>
<ol>
<li>修饰器是一个函数</li>
<li>修改行为</li>
<li>修改类的行为</li>
</ol>
<p>实例-广告插点</p>
<pre><code>{
    let log = (type) =&gt; {
        return function(target, name, descriptor) {
            let src_method = descriptor.value;
            descriptor.value = (...arg) =&gt; {
                src_method.apply(target, arg);
                console.log(`log ${type}`);
            }
        }
    }

    class AD {
        @log(&apos;show&apos;)
        show() {
            console.log(&apos;ad is show&apos;);
        }
        @log(&apos;click&apos;)
        click() {
            console.log(&apos;ad is click&apos;);
        }
    }

    let ad = new AD();
    ad.show();
    ad.click();
}
</code></pre><hr>
<p>箭头函数的this指向是定义时的指向，而不是运行时的指向</p>
<p>闭包是函数和声明该函数的词法环境的组合。<br><strong>这个环境包含了这个闭包创建时所能访问的所有局部变量。</strong></p>
<hr>
<p>hasOwnProperty 是 JavaScript 中处理属性并且不会遍历原型链的方法之一。(另一种方法: Object.keys())</p>
<p>注意：检查属性是否undefined还不够。该属性可能存在，但其值恰好设置为undefined。</p>
<hr>
<p>当你执行：</p>
<pre><code>var o = new Foo();
</code></pre><p>JavaScript实际上执行的是：</p>
<pre><code>var o = new Object();
o._proto_ = Foo.prototype;
Foo.call(o);
</code></pre><p>当你执行：</p>
<pre><code>o.someProp;
</code></pre><p>===&gt;</p>
<pre><code>Object.getPrototypeOf(o).someProp
Object.getPrototypeOf(Object.getPrototypeOf(o)).someprop
</code></pre><hr>
<p>call()方法调用一个函数，其具有一个指定的this值和分别地提供的参数（参数的列表）</p>
<p>返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。</p>
<hr>
<p>§401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</p>
<p>§403 Forbidden - [*] 表示用户得到授权（与 401 错误相对），但是访问是被<br>禁止的。</p>
<hr>
<p>使用es6注意事项</p>
<p>使用严格模式，注意作用域</p>
<p>使用类与对象，结合模块化构建中大型项目</p>
<p>使用Promise替换传统的回调函数</p>
<p>使用箭头函数要注意this的指向</p>
<p>学会使用Generator完成异步操作应用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/学习Javascript闭包-Closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/学习Javascript闭包-Closure/" itemprop="url">学习Javascript闭包(Closure)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:46:53+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习Javascript闭包（Closure）"><a href="#学习Javascript闭包（Closure）" class="headerlink" title="学习Javascript闭包（Closure）"></a>学习Javascript闭包（Closure）</h1><p>闭包（closure）是JavaScript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<h2 id="一、变量的作用域"><a href="#一、变量的作用域" class="headerlink" title="一、变量的作用域"></a>一、变量的作用域</h2><p>要理解闭包，首先必须理解JavaScript特许的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>JavaScript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<pre><code>var n = 999;
function f1() {
    alert(n);
}

f1(); // 999
</code></pre><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<pre><code>function f1() {
    var n = 999;
}

alert(n); // error
</code></pre><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<h2 id="二、如何从外部读取局部变量？"><a href="#二、如何从外部读取局部变量？" class="headerlink" title="二、如何从外部读取局部变量？"></a>二、如何从外部读取局部变量？</h2><p>处于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<pre><code>function f1() {
    var n =999;
    function f2() {
        alert(n); // 999
    }
}
</code></pre><p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<pre><code>function f1(){
    var n =999;
    function f2(){
        alert(n);
    }
    return f2;
}

var result=f1();
result(); // 999
</code></pre><h2 id="三、闭包的概念"><a href="#三、闭包的概念" class="headerlink" title="三、闭包的概念"></a>三、闭包的概念</h2><p>上一节代码中的f2函数，就是闭包。</p>
<p>各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="四、闭包的用途"><a href="#四、闭包的用途" class="headerlink" title="四、闭包的用途"></a>四、闭包的用途</h2><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解这句话呢？请看下面的代码。</p>
<pre><code>function f1(){
    var n =999;
    nAdd=function(){n+=1}
    function f2(){
        alert(n);
    }
    return f2;
}
var result = f1();
result(); // 999
nAdd();
result(); // 1000
</code></pre><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000.这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function）,而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<h2 id="五、使用闭包的注意点"><a href="#五、使用闭包的注意点" class="headerlink" title="五、使用闭包的注意点"></a>五、使用闭包的注意点</h2><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h2 id="六、思考题"><a href="#六、思考题" class="headerlink" title="六、思考题"></a>六、思考题</h2><p>如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。</p>
<p>代码片段一。</p>
<pre><code>var name = &quot;The Window&quot;;
var object = {
    name: &quot;My Object&quot;,
    getNameFunc:function(){
        return function(){
            return this.name;
        };
    }
};

alert(object.getNameFunc()());
</code></pre><p>代码片段二。</p>
<pre><code>var name = &apos;The Window&apos;;
var object = {
    name: &apos;My Object&apos;,
    getNameFunc:function(){
        var that = this;
        return function(){
            return that.name;
        };
    }
};
alert(object.getNameFunc()());
</code></pre><p>JavaScript 本质上是原型的，除了null和之外，几乎所有语言undefined都是objects。当试图访问某个属性时object，解释器会尝试通过查找该属性的存在来解决它object。如果它找不到属性，它将继续查找原型链，这是一个继承的对象链，直到它找到属性，或遍历到链的末尾。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/同步和异步请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/同步和异步请求/" itemprop="url">同步和异步请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:46:20+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="同步和异步请求"><a href="#同步和异步请求" class="headerlink" title="同步和异步请求"></a><strong>同步和异步请求</strong></h1><p>XMLHttpRequest支持同步和异步通信。但是，一般来说，由于性能原因，异步请求应优先于同步请求。</p>
<p>同步请求阻止代码的执行，这会导致屏幕上出现“冻结”和无响应的用户体验。</p>
<p><strong>异步请求</strong></p>
<p>如果你在扩展中使用XMLHttpRequest。则你应该使用异步模式的请求。使用异步模式的话，当数据完全请求回来以后，会执行一个指定的回调函数，在执行请求的同时浏览器会正常的执行其他事务的处理。</p>
<p><strong>同步请求</strong></p>
<p>同步XHR通常会导致网络挂起。但开发人员通常不会注意到这个问题，因为在网络状况不佳或服务器响应速度慢的情况下，挂起只会显示同步XHR现在处于启用状态。建议开发人员远离这个API。</p>
<p>同步XHR不允许所有新的XHR功能（如timeout或abort）。这样做会调用InvalidAccessError。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/前端跨域的几种解决方式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/前端跨域的几种解决方式总结/" itemprop="url">前端跨域的几种解决方式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:45:41+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>JavaScript的同源策略，是由Netscape提出的一个著名的安全策略，为了阻止A站的JS去操作别的网站的数据。你想啊，你现在打开了浏览器，在一个tab窗口中打开了银行网站，在另外一个tab窗口中打开了一个恶意网站，而那个恶意网站挂了一个专门修改银行信息的JavaScript，当你访问这个恶意网站并且执行它JavaScript时，你的银行页面就会被这个JavaScript修改（比如说获取你的卡号和密码，又或者是转账到黑客的账户上等等），后果会非常严重！而同源策略就为了防止这种事情发生，它规定了A网站下的JS文件只能操作A网站下的数据，不能去操作B网站的数据。</p>
<p>为了方便理解，我们把这个词拆分成同源和策略这2个词吧。</p>
<p>所谓同源指的就是资源是来自同一个源的。如果两个页面拥有相同的协议，端口号，和主机（包括子域名和主域名），那么这两个页面就属于同一个源。</p>
<p>所谓策略指的是可以做什么事情。同一个源下的JS可以操作同一个源下的数据。</p>
<p>举个例子来看看你理解了没有吧，看下面这个链接，协议是http协议，主机是store.company.com，端口号一般默认的都是80了。然后和下面的这个表中的各个URL进行比较，判断一下那些是同源的，那些是不同源。</p>
<h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ol>
<li><a href="http://store.company.com/dir2/other.html" target="_blank" rel="noopener">http://store.company.com/dir2/other.html</a></li>
<li><a href="http://store.company.com/dir/inner/another.html" target="_blank" rel="noopener">http://store.company.com/dir/inner/another.html</a></li>
<li><a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a></li>
<li><a href="http://store.company.com:81/dir/etc.html" target="_blank" rel="noopener">http://store.company.com:81/dir/etc.html</a></li>
<li><a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a></li>
</ol>
<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>跨域</p>
<pre><code>跨域
</code></pre><ul>
<li>一个域名地址的组成：</li>
</ul>
<p><a href="http://www.abc.com:8080/scripts/jquery.js" target="_blank" rel="noopener">http://www.abc.com:8080/scripts/jquery.js</a></p>
<p>  <code>http://</code>      <code>协议</code> </p>
<p>  <code>www</code>  <code>子域名</code> </p>
<p>  <code>.</code>  </p>
<p>  <code>abc.com</code> <code>主域名</code> </p>
<p>  <code>:</code>  </p>
<p>  <code>8080</code> <code>端口号</code>  </p>
<p>  <code>/</code> </p>
<p>  <code>scripts/jquery.js</code>  <code>请求资源地</code></p>
<ul>
<li><p>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。</p>
</li>
<li><p>不同域之间相互请求资源，就算作“跨域”</p>
<p>比如：<a href="http://www.abc.com/index.html" target="_blank" rel="noopener">http://www.abc.com/index.html</a> 请求 <a href="http://www.efg.com/service.php" target="_blank" rel="noopener">http://www.efg.com/service.php</a></p>
</li>
</ul>
<p>跨域的解决方案</p>
<p><strong>方案1 - JSONP</strong></p>
<p>JSONP是JSON with padding的简写。JSONP由两部分组成：回调函数和数据。</p>
<p>回调函数是客户端和服务端约定好一个函数名，一般在请求中指定。</p>
<p>数据是传入回调函数中的JSON数据。</p>
<p>JSONP是通过动态的</p>
<p>callback({“name”: “michael”});</p>
<p>问题一：JSONP是需要动态创建script标签的，我们需不需要处理这些script元素？怎么处理？</p>
<p>问题二：JSONP请求的时候，服务器发生错误该怎么办，比如服务器崩掉，比如返回了404页面，前端该怎么处理这个错误，难道直接让它抛出么？</p>
<p>答案</p>
<p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求</p>
<p>JSONP的兼容性好，不需要XMLHttpRequest的支持</p>
<p><strong>方案2 - 跨域资源共享CORS</strong></p>
<p>跨域资源共享定义了在必须访问跨域资源的时，浏览器与服务器应该如何沟通。他的原理是使用自定义的HTTP头部，让服务器与浏览器进行沟通，主要是通过设置响应头的Access-Control-Allow-Origin来达到目的的。</p>
<p>当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域HTTP请求。</p>
<p>比如，站点<a href="http://domain-a.com的某HTML页面通过" target="_blank" rel="noopener">http://domain-a.com的某HTML页面通过</a><img>的src请求<a href="http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。" target="_blank" rel="noopener">http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。</a></p>
<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。例如，XMLHttpRequest和Fetch API遵循同源策略。这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件</p>
<p>跨域资源共享(CORS)机制允许Web应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在API容器中（例如XMLHttpRequest或Fetch）使用CORS，以降低跨域HTTP请求所带来的风险。</p>
<p>跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明那些源站有权限访问那些资源。另外，规范要求，对那些可能对服务器数据产生副作用的HTTP请求方法（特别是GET以外的HTTP请求，或者搭配某些MIME类型的POST请求），浏览器必须首先使用OPTIONS方法发起一个预检请求（preflight request）,从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括Cookies和HTTP认证相关数据）。</p>
<p><strong>方案3-documnet.domain</strong></p>
<p>浏览器的同源策略使得不同域的框架是不能进行JS的交互操作的。比如：有一个页面是<a href="http://www.examples.com/a.htmls，在这个页面中还有一个http://examples.com/b.htmls，很显然，a.html与b.html是不同域的，所以我们无法通过在页面中书写js代码来获取iframe中的东西，但是，如果我们把这2个页面的document.domain都设置成相同的域名就可以了，需要注意的是，我们只能把document.domain设置成自身或更高一级的父域，且主域名必须相同。" target="_blank" rel="noopener">http://www.examples.com/a.htmls，在这个页面中还有一个http://examples.com/b.htmls，很显然，a.html与b.html是不同域的，所以我们无法通过在页面中书写js代码来获取iframe中的东西，但是，如果我们把这2个页面的document.domain都设置成相同的域名就可以了，需要注意的是，我们只能把document.domain设置成自身或更高一级的父域，且主域名必须相同。</a></p>
<p>使用条件</p>
<p>document.domain适用于不同子域的框架之间的交互。</p>
<p><strong>方案4-window.name</strong></p>
<p>window对象有个name属性，该属性有一个特征：即在一个窗口的生命周期内，窗口载入的所有页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p>
<p>方案5-window.postMessage</p>
<p>window.postMessage（message,targetOrigin）方法，可以用来向其他的window对象发送消息，无论这个window对象是属于同一个源还是不同源</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/浏览器数据库-IndexedDB-入门教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/浏览器数据库-IndexedDB-入门教程/" itemprop="url">浏览器数据库 IndexedDB 入门教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:44:59+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器数据库-IndexedDB-入门教程"><a href="#浏览器数据库-IndexedDB-入门教程" class="headerlink" title="浏览器数据库 IndexedDB 入门教程"></a>浏览器数据库 IndexedDB 入门教程</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据存储在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据存储方案，都不适合存储大量数据：Cookie的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage在2.5MB到10MB之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是IndexedDB诞生的背景。</p>
<p>通俗地说，IndexedDB就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB允许存储大量数据，提供查找接口，还能建立索引。这些都是LocalStorage所不具备的。就数据库类型而言，IndexedDB不属于关系型数据库（不支持SQL查询语句），更接近NoSQL数据库。</p>
<p>IndexedDB具有以下特点。</p>
<p>（1）键值对存储。IndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括JavaScript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p>（2）异步。IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形式对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p>（3）支持事务。IndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p>（4）同源限制IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p>（5）存储空间大IndexedDB的存储空间比LocalStorage大得多，一般来说不少于250MB，甚至没有上限。</p>
<p>（6）支持二进制存储。IndexedDB不仅可以存储字符串，还可以存储二进制数据（ArrayBuffer对象和Blob对象）。</p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>IndexedDB是一个比较复杂的API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个API，就是学习它的各种对象接口。</p>
<ul>
<li>数据库：IDBDatabase对象</li>
<li>对象仓库：IDBObjectStore对象</li>
<li>索引：IDBIdex对象</li>
<li>事务：IDBTransaction对象</li>
<li>操作请求：IDBRequest对象</li>
<li>指针：IDBCursor对象</li>
<li>主键集合：IDBKeyRange对象</li>
</ul>
<p>下面是一些主要的概念。</p>
<p>（1）数据库</p>
<p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<p>（2）对象仓库</p>
<p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<p>（3）数据记录</p>
<p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>
<pre><code>{ id: 1, text: &apos;foo&apos;}
</code></pre><p>上面的对象中，id属性可以当作主键。</p>
<p>数据体可以是任意数据类型，不限于对象。</p>
<p>（4）索引</p>
<p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<p>（5）事务</p>
<p>数据记录的读写和删改，都要通过事务完成。事务对象提供error、abort和complete三个事件，用来监听操作结果。</p>
<h2 id="三、操作流程"><a href="#三、操作流程" class="headerlink" title="三、操作流程"></a>三、操作流程</h2><p>IndexedDB数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，同于快速上手，详细的各个对象的API请看这里。</p>
<p>3.1 打开数据库</p>
<p>使用IndexedDB的第一步是打开数据库，使用indexedDB.open()方法。</p>
<pre><code>var request = window.indexedDB.open(databaseName, version);
</code></pre><p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为1。</p>
<p>indexedDB.open()方法返回一个IDBRequest对象。这个对象通过三种事件error、success、upgradededed，处理打开数据库的操作结果。</p>
<p>（1）error事件</p>
<p>error事件表示打开数据库失败。</p>
<pre><code>request.onerror = function(event) {
    console.log(&apos;数据库打开报错&apos;);
}
</code></pre><p>（2）success事件</p>
<p>success事件表示成功打开数据库。</p>
<pre><code>var db;

request.onsuccess = function (event) {
    db = request.result;
    console.log(&apos;数据库打开成功&apos;);
}
</code></pre><p>这时，通过request对象的result属性拿到数据库对象。</p>
<p>（3）upgradeneeded事件</p>
<p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradedeeded。</p>
<pre><code>var db;

request.onupgradeneeded = function (event) {
    db = event.target.result;
}
</code></pre><p>这时通过事件对象的target.result属性，拿到数据库实例。</p>
<p>3.2 新建数据库</p>
<p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<pre><code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore(&apos;person&apos;, 
  {keyPath: &apos;id&apos;});
}
</code></pre><p>上面代码中，数据库新建成功以后，新增一张叫做person的表格，主键是id。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<pre><code>request.onupgradeneeded = function(event) {
  db = event.target.result;
  var objectStore;
  if (!db.objectStoreNames.contains(&apos;person&apos;)) {
    objectStore = db.createObjectStore(&apos;person&apos;, 
    {keyPath: &apos;id&apos;});
  }
}
</code></pre><p>主键（key）是默认建立索引的属性。比如，数据记录是{id: 1, name: ‘张三’}，那么id属性可以作为主键。主键也可以指定为下一层对象的属性，比如{foo: {bar: ‘baz’}}的foo.bar也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让IndexedDB自动生成主键。</p>
<pre><code>var objectStore = db.createObjectStore (
  &apos;person&apos;,
  { autoIncrement: true }
)
</code></pre><p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<pre><code>request.onuogradeneeded = function(event) {
  db = event.target.result;
  var objectStore = db.createObjectStore(&apos;person&apos;, 
{keyPath: &apos;id&apos;});
  objectStore.createIndex(&apos;name&apos;, &apos;name&apos;, {unique:
 false});
  objectStore.createIndex(&apos;email&apos;, &apos;email&apos;, {unique: 
true});
}
</code></pre><p>上面代码中，IDBObject.createIndex()的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<p>3-3 新增数据</p>
<p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<pre><code>function add() {
  var request = db.transaction([&apos;person&apos;], 
&apos;readwrite&apos;)
  .objectStore(&apos;person&apos;)
  .add({id: 1, name: &apos;张三&apos;, age: 24, email: 
&apos;zhangsan@example.com&apos;});

  request.onsuccess = function (event) {
    console.log(&apos;数据写入成功&apos;);
  }

  request.onerror = function (event) {
    console.log(&apos;数据写入失败&apos;);
  }
}

add();
</code></pre><p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过IDBTransaction.objectStore(name)方法，拿到IDBObjectStore对象，再通过表格对象的add()方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的success事件如error事件，了解是否写入成功。</p>
<p>3.4 读取数据</p>
<p>读取数据也是通过事务完成。</p>
<pre><code>function read() {
  var transaction = db.transaction([&apos;person&apos;]);
  var objectStore = transaction.objectStore(&apos;person&apos;);
  var request = objectStore.get(1);

  request.onerror = function(event) {
    console.log(&apos;事务失败&apos;);
  }

  request.onsuccess = function(event) {
    if(request.result) {
      console.log(&apos;Name：&apos; + request.result.name);
      console.log(&apos;Age：&apos; + request.result.age);
      console.log(&apos;Email：&apos; + request.result.email);
    } else {
      console.log(&apos;未获得数据记录&apos;);
    }
  };
}

read();
</code></pre><p>上面代码中，objectStore.get()方法用于读取数据，参数是主键的值。</p>
<p>3.5 遍历数据</p>
<p>遍历数据表格的所有记录，要使用指针对象IDBCursor。</p>
<pre><code>function readAll() {
  var objectStore = db.transaction
(&apos;person&apos;).objectStore(&apos;person&apos;);

  objectStore.openCursor().onsuccess = function(event) {
    var cursor = event.target.result;

    if(cursor) {
      console.log(&apos;Id：&apos; + cursor.key);
      console.log(&apos;Name：&apos; + cursor.value.name);
      console.log(&apos;Age：&apos; + cursor.value.age);
      console.log(&apos;Email：&apos; + cursor.value.email);
      cursor.continue();
    } else {
      console.log(&apos;没有更多数据了！&apos;);
    }
  }
}

readAll();
</code></pre><p>上面代码中，新建指针对象的openCursor()方法是一个异步操作，所以要监听success事件。</p>
<p>3.6 更新数据</p>
<p>更新数据要使用IDBObject.put()方法。</p>
<pre><code>function update() {
  var request = db.transaction([&apos;person&apos;], &apos;readwrite&apos;)
  .objectStore(&apos;person&apos;)
  .put({id: 1, name: &apos;李四&apos;, age: 35, eamil: 
&apos;lisi@example.com&apos;});

  request.onsuccess = function (event) {
    console.log(&apos;数据更新成功&apos;);
  };

  request.onerror = function (event) {
    console.log(&apos;数据更新失败&apos;);
  }
}

update();
</code></pre><p>上面代码中，put()方法自动更新了主键为1的记录。</p>
<p>3.7 删除数据</p>
<p>IDBObjectStore.delete()方法用于删除记录。</p>
<pre><code>function remove() {
  var request = db.transaction([&apos;person&apos;], &apos;readwrite&apos;)
  .objectStore(&apos;person&apos;)
  .delete(1);

  request.onsuccess = function (event) {
    cosole.log(&apos;数据删除成功&apos;);
  };
}

remove();
</code></pre><p>3.8 使用索引</p>
<p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取消）。</p>
<p>假定新建表格的时候，对name字段建立了索引。</p>
<pre><code>objectStore.createIndex(&apos;name&apos;, &apos;name&apos; { unique: false});
</code></pre><p>现在，就可以从name找到对应的数据记录了。</p>
<pre><code>var transaction = db.transaction([&apos;person&apos;], 
&apos;readonly&apos;);
var store = transaction.objectStore(&apos;person&apos;);
var index = store.index(&apos;name&apos;);
var request = index.get(&apos;李四&apos;);

request.onsuccess = function(e) {
  var result = e.target.result;
  if (result) {
    // ...
  } else {
    // ...
  }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/理解JavaScript函数调用和this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/理解JavaScript函数调用和this/" itemprop="url">理解JavaScript函数调用和this</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:44:25+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>多年来，我看到很多关于JavaScript函数调用的混淆。特别是，很多人抱怨this函数的语义令人困惑。</p>
<p>在我看来，通过理解核心函数调用原语，然后查看在该原语之上调用函数作为</p>
<h1 id="this和箭头函数"><a href="#this和箭头函数" class="headerlink" title="this和箭头函数"></a>this和箭头函数</h1><p><strong>箭头函数能保存函数创建时的 this值，而不是调用时的值</strong></p>
<p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了–noImplicitThis标记。 它会指出 this.suits[pickedSuit]里的this的类型为any。</p>
<p><strong>到目前为止，我们已经将对象称为简单的键和值对。实际上，JavaScript对象还有一个附加属性：指向另一个对象的指针。我们将此指针称为对象的原型。如果您尝试在对象上查找某个键并且找不到它，JavaScript将在原型中查找它。它将遵循“原型链”，直到它看到一个null值。在那种情况下，它返回undefined。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/开发流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/开发流程/" itemprop="url">开发流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:43:46+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/继承与原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/继承与原型链/" itemprop="url">继承与原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:43:05+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h1><p>对于有基于类的语言经验（如Java或C++）的开发人员来说，JavaScript有点令人困惑，因为它是动态的，并且本身不提供一个class实现。（在ES2015/ES6中引入了class关键字，但只是语法糖，JavaScript仍然是基于原型的）。</p>
<p><img src="https://user-images.githubusercontent.com/7291672/44759590-a0102e00-ab6d-11e8-9094-f6e35ed158b2.png" alt=""></p>
<p>当谈到继承时，JavaScript只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为<em>proto</em>）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象，层层向上直到一个对象的原型对象为null。根据定义，null没有原型，并作为这个原型链中的最后一个环节。</p>
<p>几乎所有JavaScript中的对象都是位于原型链顶端的Object的实例。</p>
<p>尽管这种原型继承通常被认为是JavaScript的弱点之一，但是原型继承模型本身实际上比经典模型更强大。例如，在原型模型的基础上构建经典模型相当简单。</p>
<h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><p>JavaScript对象是动态的属性“包”（指其自己的属性）。JavaScript对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>给对象设置属性会创建自有属性。获取和设置属性的唯一限制是内置getter或setter的属性。</p>
<h2 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h2><p>JavaScript并没有其他基于类的语言所定义的“方法”。在JavaScript里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，this指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/高性能JavaScript编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/高性能JavaScript编程/" itemprop="url">高性能JavaScript编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:42:23+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一章-Loading-and-Execution-加载和运行"><a href="#第一章-Loading-and-Execution-加载和运行" class="headerlink" title="第一章 Loading and Execution    加载和运行"></a>第一章 Loading and Execution    加载和运行</h2><p><strong>Script Positioning    脚本位置</strong></p>
<p><strong>Grouping Scripts    成组脚本</strong></p>
<p><strong>Nonvlocking Scripts 非阻塞脚本</strong></p>
<p>Deferred Scripts 延期脚本</p>
<pre><code>&lt;scripts type=&quot;text/javascript&quot; src=&quot;file1.js&quot; 
defer&gt;&lt;/script&gt;
</code></pre><p>Dynamic Script Elements 动态脚本元素</p>
<pre><code>var script = document.createElement(&quot;script&quot;);
script.type = &quot;text/javascript&quot;;
script.src = &quot;file1.js&quot;;
document.getElementByTagName_r(&quot;head&quot;)
[0].appendChild(script);
</code></pre><p>XMLHttpRequest Script Injection XHR 脚本注入</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open(&quot;get&quot;, &quot;file1.js&quot;, true);
xhr.onreadstatechange = function() {
    if(xhr.readState === 4) {
        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 ||
             xhr.status == 304){
            var script = document.createElement
            (&quot;script&quot;);
            script.type = &quot;text/javascript&quot;;
            script.text = xhr.responseText;
            document.body.appendChild(script);
        }
    }
};
xhr.send(null);
</code></pre><p>Recommended Nonblocking Pattern 推荐的非阻塞模式</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;loader.js&quot;&gt;&lt;/
script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    loadScript(&quot;the-rest.js&quot;, function(){    
        Application.init();
    });
&lt;/script&gt;
</code></pre><p><strong>Summary    总结</strong></p>
<p>管理浏览器中的JavaScript代码是个棘手的问题，因为代码执行阻塞了其他浏览器处理过程，诸如用户界面绘制。每次遇到script标签，页面必须停下来等待代码下载（如果是外部的）并执行，然后再继续处理页面其他部分。但是，有几种方法可以减少JavaScript对性能的影响：</p>
<ul>
<li><p>将所有script标签放置在页面的底部，紧靠body关闭标签的上方。此法可以保证页面在脚本运行之前完成解析。</p>
</li>
<li><p>将脚本成组打包。页面的script标签越少，页面的加载速度就越快，响应也更加迅速。不论外部脚本文件还是内联代码都是如此。</p>
</li>
<li><p>有几种方法可以使用非阻塞方式下载JavaScript：</p>
</li>
</ul>
<ol>
<li><p>为script标签添加defer属性（只适用于Internet Explorer和Firefox 3.5 以上版本）</p>
</li>
<li><p>动态创建script元素，用它下载并执行代码</p>
</li>
<li><p>用XHR对象下载代码，并注入到页面中</p>
</li>
</ol>
<p>通过使用上述策略，你可以极大提高哪些大量使用JavaScript代码的网页应用的实际性能。</p>
<h2 id="第二章Data-Access-数据访问"><a href="#第二章Data-Access-数据访问" class="headerlink" title="第二章Data Access 数据访问"></a>第二章Data Access 数据访问</h2><p><strong>Managing Scope 管理作用域</strong></p>
<p>Scope Chains and Identifier Resolution 作用域链和标识符解析</p>
<p>每一个JavaScript函数都被表示为对象。进一步说，它是一个函数实例。函数对象正如其他对象那样，拥有你可以编程访问的属性，和一系列不能被程序访问，仅供JavaScript引擎使用的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义。</p>
<p><strong>Identifier Resolution Performance 标识符识别性能</strong></p>
<p><strong>Scope Chain Augmentation改变作用域链</strong></p>
<p><strong>Dynamic Scopes 动态作用域</strong></p>
<p><strong>Closures，Scope，and Memory 闭包，作用域，和内存</strong></p>
<p>闭包是JavaScript最强大的一个方面，它允许函数访问局部范围之外的数据。闭包的使用通过Douglas Crockford的著作流行起来，当今在最复杂的网页应用中无处不在。不过，有一种性能影响与闭包有关。</p>
<p><strong>Object Members 对象成员</strong></p>
<p>大多数JavaScript代码以面向对象的形式编写。无论通过创建自定义对象还是使用内置的对象，诸如文档对象模型（DOM）和浏览器对象模型（BOM）之中的对象。因此，存在很多对象成员访问。</p>
<p><strong>Prototypes 原形</strong></p>
<p>JavaScript中的对象是基于原形得到。原形是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。</p>
<p><strong>Prototype Chains 原型链</strong></p>
<p>对象的原形决定了一个实例的类型。默认情况下，所有对象都是Object的实例，并继承了所有基本方法，如toString()。你可以用“构造器”创建另外一种类型的原形。</p>
<p><strong>Nested Members 嵌套成员</strong></p>
<p><strong>Caching Object Member Values 缓存对象成员的值</strong></p>
<p><strong>Summary 总结</strong></p>
<p>在JavaScript中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数据项，对象成员。它们有不同的性能考虑。</p>
<ul>
<li>直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。</li>
<li>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。</li>
<li>避免使用with表达式，因为它改变了运行期上下文的作用域链。而且应当小心对待try-catch表达式的catch子句，因为它具有同样效果。</li>
<li>嵌套对象成员会造成重大性能影响，尽量少用。</li>
<li>一个属性或方法在原型链中的位置越深，访问它的速度就越慢。</li>
<li>一般来说，你可以通过这种方法提高JavaScript代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。</li>
</ul>
<p>通过使用这些策略，你可以极大地提高哪些需要大量JavaScript代码的网页应用的实际性能。</p>
<h2 id="第三章-DOM-Scripting-DOM编程"><a href="#第三章-DOM-Scripting-DOM编程" class="headerlink" title="第三章    DOM Scripting DOM编程"></a>第三章    DOM Scripting DOM编程</h2><p><strong>DOM in the Browser World 浏览器世界中的DOM</strong></p>
<p><strong>Inherently Slow 天生就慢</strong></p>
<p><strong>DOM Access and Modification DOM访问和修改</strong></p>
<p><strong>innerHTML Versus DOM methods innerHTML 与DOM方法比较</strong></p>
<p><strong>Cloning Nodes 节点克隆</strong></p>
<p><strong>HTML Collections HTML集合</strong></p>
<p><strong>Expensive collections 昂贵的集合</strong></p>
<p><strong>Local variables when accessing collection elements 访问集合元素时使用局部变量</strong></p>
<p><strong>Walking the DOM DOM漫谈</strong></p>
<p>Crawling the DOM 抓取DOM</p>
<p>Element nodes 元素节点</p>
<p>The Selectors API 选择器API</p>
<p><strong>Repaints and Reflows 重绘和重排版</strong></p>
<p><strong>When Does a Reflow Happen? 重排版时会发生什么？</strong></p>
<p><strong>Queuing and Flushing Render Tree Changes 查询并刷新渲染树改变</strong></p>
<p><strong>Minimizing Repaints and Reflows 最小化重绘和重排版</strong></p>
<p><strong>Style changes 改变风格</strong></p>
<p><strong>Batching DOM changes 批量修改DOM</strong></p>
<p><strong>Caching Layout Information 缓冲布局信息</strong></p>
<p><strong>Take Elements Out of the Flow for Animations 将元素提出动画流</strong></p>
<p><strong>IE和:hover</strong></p>
<p><strong>Event Delegation 事件托管</strong></p>
<p><strong>Summary 总结</strong></p>
<p>DOM访问和操作是现代网页应用中很重要的一部分。但每次你通过桥梁从ECMAScript岛到达DOM岛时，都会被收取“过桥费”。为减少DOM编程中的性能损失，请牢记以下几点：</p>
<ul>
<li>最小化DOM访问，在JavaScript端做尽可能多的事情。</li>
<li>在反复访问的地方使用局部变量存放DOM引用</li>
<li>小心地处理HTML集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的length属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。</li>
<li>如果可能的话，使用速度更快的API，诸如querySelectorAll()和firstElementChild。</li>
<li>注意重绘和重排版；批量修改风格，离线操作DOM树，缓存并减少对布局信息的访问。</li>
<li>动画中使用绝对坐标，使用拖放代理。</li>
<li>使用事件托管技术最小化事件句柄数量。</li>
</ul>
<h2 id="第四章-Algorithms-and-Flow-Control-算法和流程控制"><a href="#第四章-Algorithms-and-Flow-Control-算法和流程控制" class="headerlink" title="第四章 Algorithms and Flow Control 算法和流程控制"></a>第四章 Algorithms and Flow Control 算法和流程控制</h2><p><strong>Loops 循环</strong></p>
<p><strong>Types of Loops 循环的类型</strong></p>
<p><strong>Loop Performance 循环性能</strong></p>
<p><strong>Decreasing the work per iteration 减少迭代的工作量</strong></p>
<p><strong>Decreasing the number of iterations 减少迭代次数</strong></p>
<p><strong>Function-Based Iteration 基于函数的迭代</strong></p>
<p><strong>Conditionals 条件表达式</strong></p>
<p>if-else Versus switch     if-else与switch比较</p>
<p><strong>Optimizing if-else 优化if-else</strong></p>
<p><strong>Lookup Tables 查表法</strong></p>
<p><strong>Resursion 递归</strong></p>
<p>Call Stack Limits 调用栈限制</p>
<p><strong>Recursion Patterns 递归模式</strong></p>
<p><strong>Iteration 迭代</strong></p>
<p><strong>Memoization 制表</strong></p>
<p><strong>Summary 总结</strong></p>
<p>正如其他编程语言，代码的写法和算法选用影响JavaScript的运行时间。与其他编程语言不同的是，JavaScript可用资源有限，所以优化技术更为重要。</p>
<ul>
<li>for，while，do-while循环的性能特性相似，谁也不比谁更快或更慢。</li>
<li>除非你要迭代遍历一个属性未知的对象，否则不要使用for-in循环。</li>
<li>改善循环性能的更好办法是减少每次迭代中的运算量，并减少循环迭代次数。</li>
<li>一般来说，switch总是比if-else更快，但并不总是最好的解决方法。</li>
<li>当判断条件较多时，查表法比if-else或者switch更快。</li>
<li>浏览器的调用栈尺寸限制了递归算法在JavaScript中的应用；栈溢出错误导致其他代码也不能正常执行。</li>
<li>如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作。</li>
</ul>
<p>运行的代码总量越大，使用这些策略所带来的性能提升就越明显。</p>
<h2 id="第五章-Strings-and-Regular-Expressions-字符串和正则表达式"><a href="#第五章-Strings-and-Regular-Expressions-字符串和正则表达式" class="headerlink" title="第五章 Strings and Regular Expressions 字符串和正则表达式"></a>第五章 Strings and Regular Expressions 字符串和正则表达式</h2><p><strong>String Concatenation 字符串连接</strong></p>
<p>Plus(+) and Plus-Equals (+=) Operators 加和加等于操作</p>
<p>Firefox and compile-time folding Firefox和编译期合并</p>
<p>Array Joining 数组联结</p>
<p>String.prototype.concat</p>
<p><strong>Regular Expression Optimization 正则表达式优化</strong></p>
<p>How Regular Expression Work 正则表达式工作原理</p>
<p>Understanding Backtrack 理解回溯</p>
<p>Repetiton and backtracking 重复与回溯</p>
<p>Runaway Backtracking 回溯失控</p>
<p>The solution：Be specific    解决方法：具体化</p>
<p>Emulating atomic groups using lookahead and backreferences 使用前瞻和后向引用列举原子组</p>
<p>Nested quantifiers and runaway backtracking 嵌套量词和回溯失控</p>
<p>From bad to worse 从坏到更坏</p>
<p>A Note on Benchmarking 测试基准说明</p>
<p><strong>More Ways to Improve Regular Expression Efficiency 提高正则表达式效率的更多方法</strong></p>
<p><strong>When Not to Use Regular Expressions 什么时候不应该使用正则表达式</strong></p>
<p><strong>String Trimming 字符串修剪</strong></p>
<p><strong>Trimming with Regular Expressions 用正则表达式修剪</strong></p>
<p><strong>A Hybrid Solution 混合解决方案</strong></p>
<p><strong>Summary 总结</strong></p>
<ul>
<li>密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍，但本章中的建议可帮助您避免常见缺陷。</li>
<li>当连接数量巨大或尺寸巨大的字符串时，数组联合是IE7和它的早期版本上唯一具有合理性能的方法。</li>
<li>如果你不关心IE7和它的早期版本，数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之，可避免(产生)不必要的中间字符串。</li>
<li>回溯即是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因。</li>
<li>回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯。</li>
<li>提高正则表达式效率的各种技术手段，帮助正则表达式更快地找到匹配，以及在非匹配位置上花费更少时间（见《更多提高正则表达式效率的方法》）。</li>
<li>正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串时。</li>
<li>虽然有很多方法来修整一个字符串，使用两个简单的正则表达式（一个用于去除头部空格，另一个用于去除尾部空格）提供了一个简洁、跨浏览器的方法，适用于不同内容和长度的字符串。从字符串末尾开始循环查找第一个非空格字符，或者在一个混合应用中将此技术与正则表达式结合起来，提供了一个很好的替代方案，它很少受到字符串整体长度的影响。</li>
</ul>
<h2 id="第六章-Responsive-Interfaces-响应接口"><a href="#第六章-Responsive-Interfaces-响应接口" class="headerlink" title="第六章    Responsive Interfaces 响应接口"></a>第六章    Responsive Interfaces 响应接口</h2><p><strong>The Browser UI Thread    浏览器UI线程</strong></p>
<p><strong>Browser Limits    浏览器限制</strong></p>
<p><strong>How Long Is Too Long?    多久才算“太久”?</strong></p>
<p>更复杂的是有些浏览器在JavaScript 运行时不将UI 更新放入队列。例如，如果你在某些JavaScript 代码运行时点击按钮，浏览器可能不会将重绘按钮按下的UI 更新任务放入队列，也不会放入由这个按钮启动的JavaScript 任务。其结果是一个无响应的UI，表现为“挂起”或“冻结”。</p>
<p><strong>Yielding with Timers 用定时器让出时间片</strong></p>
<p>Timer Basics 定时器基础</p>
<p>Timer Precision 定时器精度</p>
<p><strong>Array Processing with Timers 在数组处理中使用定时器</strong></p>
<p><strong>Splitting Up Tasks 分解任务</strong></p>
<p>Timed Code 限时运行代码</p>
<p>Timers and Performance 定时器与性能</p>
<p><strong>Web Workers 网页工人线程</strong></p>
<p>Worker Environment 工人线程运行环境</p>
<p>Worker Communication 工人线程交互</p>
<p>Loading External Files 加载外部文件</p>
<p>Practical Users 实际用途</p>
<p><strong>Summary    总结</strong></p>
<p>JavaScript和用户界面更新在同一个进程内运行，同一时刻只有其中一个可以运行。这意味着当JavaScript代码正在运行时，用户界面不能响应输入，反之亦然。有效地管理UI线程就是要确保JavaScript不能运行太长时间，以免影响用户体验。最后，请牢记如下几点：</p>
<ul>
<li>JavaScript运行时间不应该超过100毫秒。过长的运行时间导致UI更新出现可察觉的延迟，从而对整体用户体验产生负面影响。</li>
<li>JavaScript运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript长时间运行将导致用户体验混乱和脱节。</li>
<li>定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务。</li>
<li>网页工人线程是新式浏览器才支持的特性，它允许你在UI线程之外运行JavaScript代码而避免锁定UI。</li>
</ul>
<p>网页应用程序越复杂，积极主动地管理UI线程就越显得重要。没有什么JavaScript代码可以重要到允许影响用户体验的程度。</p>
<h2 id="第七章-Ajax-异步JavaScript和XML"><a href="#第七章-Ajax-异步JavaScript和XML" class="headerlink" title="第七章    Ajax 异步JavaScript和XML"></a>第七章    Ajax 异步JavaScript和XML</h2><p>Ajax是高性能JavaScript的基石。它可以通过延迟下载大量资源使页面加载更快。它通过在客户端和服务器端之间异步传送数据，避免页面集体加载。它还用于在一次HTTP请求中获取整个页面的资源。通过选择正确的传输技术和最有效的数据格式，你可以显著改善用户与网站之间的互动。</p>
<p>本章考察从服务器收发数据最快的技术，以及最有效的数据编码格式。</p>
<p><strong>Data Transmission    数据传输</strong></p>
<p>Requesting Data 请求数据</p>
<p>XMLHttpRequest</p>
<p>POST versus GET when using XHR. 使用XHR时，应使用POST还是GET</p>
<p>Dynamic script tag insertion 动态脚本标签插入</p>
<p>Multipart XHR 多部分 XHR</p>
<p><strong>Sending Data 发送数据</strong></p>
<p>XMLHttpRequest</p>
<p>Beacons 灯标</p>
<p><strong>Data Formats 数据格式</strong></p>
<p>XML</p>
<p>XPath</p>
<p>Response sizes and parse times 响应报文大小和解析时间</p>
<p>JSON</p>
<p>JSON-P</p>
<p>Should you use JSON? 你应该使用JSON吗？</p>
<p>HTML</p>
<p>Custom Formatting 自定义格式</p>
<p><strong>Data Format Conclusions 数据格式总结</strong></p>
<p><strong>Ajax Performance Guidelines Ajax性能导向</strong></p>
<p>Cache Data 缓存数据</p>
<p>Setting HTTP headers 设置HTTP头</p>
<p>Storing data locally 本地存储数据</p>
<p><strong>Know the Limitations of Your Ajax Library 了解Ajax库的限制</strong></p>
<p><strong>Summary 总结</strong></p>
<p>高性能Ajax包括：知道你项目的具体需求，选择正确的数据格式和与之相配的传输技术。</p>
<p>作为数据格式，纯文本和HTML是高度限制的，但它们可节省客户端的CPU周期。XML被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON是轻量级的，解析迅速（作为本地代码而不是字符串），交互性与XML相当。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器端构造格式，并在客户端解析。</p>
<p>当从页面域请求数据时，XHR提供最完善的控制和灵活性，尽管它将所有传入数据视为一个字符串，这有可能降低解析速度。另一方面，动态脚本标签插入技术允许跨域请求和本地运行JavaScript和JSON，虽然它的接口不够安全，而且不能读取信息头或响应报文代码。多部分XHR可减少请求的数量，可在一次响应中处理不同的文件类型，尽管它不能缓存收到的响应报文。当发送数据时，图像灯标是最简单和最有效的方法。XHR也可用POST方法发送大量数据。</p>
<p>除这些格式和传输技术之外，还有一些准则有助于进一步提高Ajax的速度：</p>
<ul>
<li>减少请求数量，可通过JavaScript和CSS文件打包，或者使用MXHR。</li>
<li>缩短页面的加载时间，在页面其他内容加载之后，使用Ajax获取少量重要文件。</li>
<li>确保代码错误不要直接显示给用户，并在服务器端处理错误。</li>
<li>学会何时使用一个健壮的Ajax库，何时编写自己的底层Ajax代码。</li>
</ul>
<p>Ajax是提升你网站潜在性能之最大的改进区域之一，因为很多网站大量使用异步请求，又因为它提供了许多不相关问题的解决方案，这些问题诸如，需要加载太多资源。对XHR的创造性应用是如此的与众不同，它不是呆滞不友好的界面，而是响应迅速且高效的代名词；它不会引起用户的憎恨，谁见了它都会爱上它。</p>
<h2 id="第八章-Programming-Practics-编程实践"><a href="#第八章-Programming-Practics-编程实践" class="headerlink" title="第八章     Programming Practics    编程实践"></a>第八章     Programming Practics    编程实践</h2><p>每种编程语言都有痛点，而且低效模式随着时间的推移不断发展。其原因在于，越来越多的人们开始使用这种语言，不断扩种它的边界。自2005年以来，当术语“Ajax”出现时，网页开发者对JavaScript和浏览器的推动作用远超过以往。其结果是出现了一些非常具体的模式，既有优秀的做法也有糟糕的做法。这些模式的出现，是因为网络上JavaScript的性质决定的。</p>
<p><strong>Avoid Double Evaluation 避免二次评估</strong></p>
<p><strong>Use Object/Array Literals 使用对象/数组直接量</strong></p>
<p><strong>Don’t Repeat Work 不要重复工作</strong></p>
<p><strong>Lazy Loading 延迟加载</strong></p>
<p><strong>Conditional Advance Loading 条件预加载</strong></p>
<p><strong>Use the Fast Parts 使用速度快的部分</strong></p>
<p><strong>Bitwise Operators 位操作运算符</strong></p>
<p><strong>Native Methods 原生方法</strong></p>
<p><strong>Summary 总结</strong></p>
<p>JavaScript提出了一些独特的性能挑战，关系到你组织代码的方法。网页应用变得越来越高级，包含的JavaScript代码越来越多，出现了一些模式和反模式。请牢记以下编程经验：</p>
<ul>
<li>通过避免使用eval_r()和Function()构造器避免二次评估。此外，给setTimeout()和setInterval()传递函数参数而不是字符串参数。</li>
<li>创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。</li>
<li>避免重复进行相同工作。当需要检测浏览器时，使用延迟加载或条件预加载。</li>
<li>当执行数学运算时，考虑使用位操作，它直接在数学底层进行操作。</li>
<li>原生方法总是比JavaScript写的东西要快。尽量使用原生方法。</li>
</ul>
<p>本书涵盖了很多技术和方法，如果将这些优化应用在哪些经常运行的代码上，你将会看到巨大的性能提升。</p>
<h2 id="第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能JavaScript应用程序"><a href="#第九章-Building-and-Deploying-High-Performance-JavaScript-Applications-创建并部署高性能JavaScript应用程序" class="headerlink" title="第九章    Building and Deploying High-Performance JavaScript Applications    创建并部署高性能JavaScript应用程序"></a>第九章    Building and Deploying High-Performance JavaScript Applications    创建并部署高性能JavaScript应用程序</h2><p>根据Yahoo!卓越性能团队在2007年进行的研究，40%-60%的Yahoo!用户没有使用缓存的经验，大约20%页面视图不使用缓存（<a href="https://yuiblog.com/blog/2007/01/04/performance-research-part-2/）。另外，由Yahoo!研究小组发现，并由Google的Steve" target="_blank" rel="noopener">https://yuiblog.com/blog/2007/01/04/performance-research-part-2/）。另外，由Yahoo!研究小组发现，并由Google的Steve</a> Souders所证实的一项最新研究表明，大约15%的美国大型网站所提供的内容没有压缩。</p>
<p>这些事实强调有必要确保哪些基于JavaScript的网页应用尽量高效地发布。虽然部分工作在设计开发过程中已经完成，但构建和部署过程也很重要且往往被忽视。如果在这个关键过程中不够小心，你应用程序的性能将受到影响，无论你怎么努力使它更快。</p>
<p>本章的目的是给你必要的知识，有效地组织并部署基于JavaScript的Web应用程序。一些概念使用Apache Ant进行说明，它是一个基于Java的构建工具，并很快成为开发网页应用程序的工业标准，在本章末尾，给出了一个用PHP5写的定制灵活的开发工具的例子。</p>
<p><strong>Apache Ant</strong></p>
<p><strong>Combining JavaScript Files 合并JavaScript文件</strong></p>
<p><strong>Preprocessing JavaScript Files 预处理JavaScript文件</strong></p>
<p><strong>JavaScript Minification    JavaScript紧凑</strong></p>
<p><strong>Buildtime Versus Runtime Build Process 开发过程中的编译时和运行时</strong></p>
<p><strong>JavaScript Compression JavaScript压缩</strong></p>
<p><strong>Caching JavaScript Files 缓存JavaScript文件</strong></p>
<p><strong>Working Around Caching Issues 关于缓存问题</strong></p>
<p><strong>Using a Content Delivery Network 使用内容传递网</strong></p>
<p><strong>Deploying JavaScript Resources 部署JavaScript资源</strong></p>
<p><strong>Agile JavaScript Build Process 灵巧的JavaScript开发过程</strong></p>
<p><strong>Summary 总结</strong></p>
<p>开发和部署过程对基于JavaScript的应用程序可以产生巨大影响，最重要的几个步骤如下：</p>
<ul>
<li>合并JavaScript文件，减少HTTP请求的数量</li>
<li>使用YUI压缩器紧凑处理JavaScript文件</li>
<li>以压缩形式提供JavaScript文件（gzip编码）</li>
<li>通过设置HTTP响应报文头使JavaScript文件可缓存，通过向文件名附加时间戳解决缓存问题</li>
<li>使用内容传递网络（CDN）提供JavaScript文件，CDN不仅可以提高性能，它还可以为你管理压缩和缓存</li>
</ul>
<p>所有这些步骤应当自动完成，不论是使用公开的开发工具诸如Apache Ant，还是使用自定义的开发工具以实现特定需求。如果你使这些开发工具为你服务，你可以极大改善哪些大量使用JavaScript代码的网页应用或网站的性能。</p>
<h2 id="第十章-Tools-工具"><a href="#第十章-Tools-工具" class="headerlink" title="第十章    Tools    工具"></a>第十章    Tools    工具</h2><p>当确定脚本加载和运行时的瓶颈所在时，合手的工具是必不可少的。许多浏览器厂商和大型网站分享了一些技术和工具，帮助开发者使网页更快，效率更高。本章关注于这些免费工具：</p>
<p><strong>Profiling 性能分析</strong></p>
<p><strong>Network analysis 网络分析</strong></p>
<p><strong>JavaScript Profiling JavaScript 性能分析</strong></p>
<p><strong>YUI Profiler YUI分析器</strong></p>
<p><strong>Anonymous Functions 匿名函数</strong></p>
<p><strong>Firebug</strong></p>
<p><strong>Console Panel Profiler 控制台面板分析器</strong></p>
<p><strong>Console API 终端API</strong></p>
<p><strong>Net Panel 网络面板</strong></p>
<p><strong>Internet Explorer Developer Tools IE开发人员工具</strong></p>
<p><strong>Safari Web Inspector Safari 网页监察器</strong></p>
<p><strong>Profiles Panel 分析面板</strong></p>
<p><strong>Resources Panel 资源面板</strong></p>
<p><strong>Chrome Developers Tools    Chrome开发人员工具</strong></p>
<p><strong>Script Blocking 脚本阻塞</strong></p>
<p><strong>Page Speed</strong></p>
<p><strong>Fiddler</strong></p>
<p><strong>YSlow</strong></p>
<p><strong>dynaTrace Ajax Edition Ajax版的dynaTrace</strong></p>
<p><strong>Summary 总结</strong></p>
<p>当网页或应用程序变慢时，分析网上传来的资源，分析脚本的运行性能，使你能够集中精力在那些需要努力优化的地方。</p>
<ul>
<li>使用网络分析器找出加载脚本和其他页面资源的瓶颈所在，这有助于决定哪些脚本需要延迟加载，或者进行进一步分析。</li>
<li>传统的智慧告诉我们应尽量减少HTTP请求的数量，尽量延迟加载脚本以使页面渲染速度更快，向用户提供更好的整体体验。</li>
<li>使用性能分析器找出脚本运行时速度慢的部分，检查每个函数所花费的时间，以及函数被调用的次数，通过调用栈自身提供的一些线索来找出哪些地方应当努力优化。</li>
<li>虽然花费时间和调用次数通常是数据中最有价值的点，还是应当仔细查看函数的调用过程，可能发现其它优化方法。</li>
</ul>
<p>这些工具在那些现代代码所要运行的编程环境中不再神秘。在开始优化工作之前使用它们，确保开发时间用在解决问题的刀刃上。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangXiaofei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangXiaofei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
