<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/JavaScript执行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/JavaScript执行机制/" itemprop="url">JavaScript执行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:33:44+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="这一次，彻底弄懂JavaScript执行机制"><a href="#这一次，彻底弄懂JavaScript执行机制" class="headerlink" title="这一次，彻底弄懂JavaScript执行机制"></a>这一次，彻底弄懂JavaScript执行机制</h1><p>本文的目的就是要保证你彻底弄懂javascript的执行机制，如果读完本文还不懂，可以揍我。。。。。。。。。。。</p>
<p>无论你是javascript新手还是老鸟，无论是面试求职，还是日常开发工作，我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。因为javascript是一门单线程语言，所以我们可以得出结论：</p>
<ul>
<li>javascript是按照语句出现的顺序执行的</li>
</ul>
<p>看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁，正因为js是一行一行执行的，所以我们以为js都是这样的：</p>
<pre><code>let a = &apos;1&apos;;
console.log(a);

let b = &apos;2&apos;;
console.log(b);
</code></pre><p>然而实际上js是这样的：</p>
<pre><code>setTimeout(function(){
  console.log(&apos;定时器开始啦&apos;)
});

new Promise(function(resolve){
  console.log(&apos;马上执行for循环啦&apos;);
  for(var i =0; i&lt;10000; i++){
    i == 99 &amp;&amp; resolve();
  }
}).then(function(){
  console.log(&apos;执行then函数啦&apos;)
});

console.log(&apos;代码执行结束&apos;);
</code></pre><p>依照js是按照语句出现的顺序执行这个理念，我自信的写下输出结果：</p>
<pre><code>//&quot;定时器开始啦&quot;
//&quot;马上执行for循环啦&quot;
//&quot;执行then函数啦&quot;
//&quot;代码执行结束&quot;
</code></pre><p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？</p>
<p>我们真的要彻底弄明白javascript的执行机制了。</p>
<h2 id="1-关于javascript"><a href="#1-关于javascript" class="headerlink" title="1.关于javascript"></a>1.关于javascript</h2><p>javascript是一门<strong>单线程</strong>语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的“多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p>
<h2 id="2-javascript事件循环"><a href="#2-javascript事件循环" class="headerlink" title="2.javascript事件循环"></a>2.javascript事件循环</h2><p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>导图要表达的内容用文字来表述的话：</p>
<ul>
<li>同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue哪里检查是否有等待被调用的函数。</p>
<p>说了这么多文字，不如直接一段代码更直白：</p>
<pre><code>let data = [];
$.ajax({
  url:www.javascript.com,
  data:data,
  success:() =&gt; {
    console.log(&apos;发送成功!&apos;);
  }
})
console.log(&apos;代码执行结束&apos;);
</code></pre><p>上面是一段简易的ajax请求代码：</p>
<ul>
<li>ajax进入Event Table，注册回调函数success。</li>
<li>执行console.log(‘代码执行结束’)。</li>
<li>ajax事件完成，回调函数success进入Event Queue。</li>
<li>主线程从Event Queue读取回调函数success并执行。</li>
</ul>
<p>相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：</p>
<p>setTimeout。</p>
<h2 id="3-又爱又恨的setTimeout"><a href="#3-又爱又恨的setTimeout" class="headerlink" title="3.又爱又恨的setTimeout"></a>3.又爱又恨的setTimeout</h2><p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<pre><code>setTimeout(() =&gt; {
  console.log(&apos;延时3秒&apos;);
},3000)
</code></pre><p>渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5,6秒才执行函数，这又咋回事啊？</p>
<p>先看一个例子：</p>
<pre><code>setTimeout(() =&gt; {
  task();
},3000)
console.log(&apos;执行console&apos;);
</code></pre><p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p>
<pre><code>// 执行console
// task()
</code></pre><p>去验证一下，结果正确！</p>
<p>然后我们修改一下前面得到代码：</p>
<pre><code>setTimeout(() =&gt; {
  task()
},3000)

sleep(10000000)

function sleep(delay) {
  var start = (new Date()).getTime();
  while ((new Date()).getTime() - start &lt; delay) {
    continue;
  }
}
</code></pre><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p>
<p>这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：</p>
<ul>
<li>task()进入Event Table并注册，计时仍在继续。</li>
<li>执行sleep函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li>
<li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。</li>
</ul>
<p>上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务（本例中为task()）加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p>
<p>我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p>
<p>答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p>
<pre><code>// 代码1
console.log(&apos;先执行这里&apos;);
setTimeout(() =&gt; {
  console.log(&apos;执行啦&apos;)
},0);

// 代码2
console.log(&apos;先执行这里&apos;);
setTimeout(() =&gt; {
  console.log(&apos;执行啦&apos;)
},3000);
</code></pre><p>代码1的输出结果是：</p>
<pre><code>// 先执行这里
// 执行啦
</code></pre><p>代码2的输出结果是：</p>
<pre><code>// 先执行这里
// ... 3s later
// 执行啦
</code></pre><p>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p>
<h2 id="4-又爱又恨的setInterval"><a href="#4-又爱又恨的setInterval" class="headerlink" title="4.又爱又恨的setInterval"></a>4.又爱又恨的setInterval</h2><p>上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出有时间间隔了。这句话请读者仔细品味。</p>
<h2 id="5-Promise与process-nextTick-callback"><a href="#5-Promise与process-nextTick-callback" class="headerlink" title="5.Promise与process.nextTick(callback)"></a>5.Promise与process.nextTick(callback)</h2><p>传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。</p>
<p>Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的Promsie。而process.nextTick(callback)类似node.js版的“setTimeout”，在事件循环的下一次循环中调用callback回调函数。</p>
<p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<ul>
<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。</p>
<p>事件循环的顺序，决定js代码的执行顺序。进入整体代码（宏任务）后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：</p>
<pre><code>setTimeout(function(){
  console.log(&apos;setTimeout&apos;);
})

new Promise(function(resolve){
  console.log(&apos;promise&apos;);
}).then(function(){
  console.log(&apos;then&apos;);
})

console.log(&apos;console&apos;);
</code></pre><ul>
<li>这段代码作为宏任务，进入主线程。</li>
<li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li>
<li>接下来遇到Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li>
<li>遇到console.log()，立即执行。</li>
<li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。</li>
<li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。</li>
<li>结束。</li>
</ul>
<p>事件循环，宏任务，微任务的关系如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p>
<pre><code>console.log(&apos;1&apos;);

setTimeout(function() {
  console.log(&apos;2&apos;);
  process.nextTick(function(){
    console.log(&apos;3&apos;);
  })
  new Promise(function(resolve){
    console.log(&apos;4&apos;);
    resolve();
  }).then(function(){
    console.log(&apos;5&apos;)
  })
})
process.nextTick(function(){
  console.log(&apos;6&apos;);
})
new Promise(function(resolve) {
  console.log(&apos;7&apos;);
  resolve();
}).then(function(){
  console.log(&apos;8&apos;)
})

setTimeout(function() {
  console.log(&apos;9&apos;);
  process.nextTick(function() {
    console.log(&apos;10&apos;);
  })
  new Promise(function(resolve) {
    console.log(&apos;11&apos;);
    resolve();
  }).then(function() {
    console.log(&apos;12&apos;)
  })
})
</code></pre><p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li>
<li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。</li>
<li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。</li>
<li>遇到Promise，new Promise直接执行，输出7。then被分发微任务Event Queue中。我们记为then1。</li>
<li><p>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。</p>
<pre><code>宏任务Event Queue        微任务Event Queue
  setTimeout1               process1
  setTimeout2                   then1
</code></pre></li>
<li><p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</p>
</li>
<li>我们发现了process1和then1两个微任务。</li>
<li>执行process1，输出6。</li>
<li>执行then1，输出8。</li>
</ul>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出1,7,6,8。那么第二轮时间循环从setTimeout1宏任务开始：</p>
<ul>
<li><p>首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4,then也分发到微任务Event Queue中，记为then2。</p>
<pre><code>宏任务Event Queue        微任务Event Queue
  setTimeout2              process2
</code></pre></li>
<li><p>第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。</p>
</li>
<li>输出3.</li>
<li>输出5.</li>
<li>第二轮事件循环结束，第二轮输出2,4,3,5.</li>
<li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li>
<li>直接输出9.</li>
<li>将process.nextTick()分发到微任务Event Queue中。记为process3。</li>
<li>直接执行new Promise，输出11。</li>
<li><p>将then分发到微任务Event Queue中，记为then3。</p>
<pre><code>宏任务Event Queue        微任务Event Queue
                            process3
                            then3
</code></pre></li>
<li><p>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</p>
</li>
<li>输出10。</li>
<li>输出12.</li>
<li>第三轮事件循环结束，第三轮输出9,11,10,12.</li>
</ul>
<p>整段代码，共进行了三次事件循环，完整的输出为1,7,6,8,2,4,3,5,9,11,10,12。</p>
<p>(请注意，node环境下的事件监听依赖libuv与前段环境不完全相同，输出顺序可能会有误差)</p>
<h2 id="6-写在最后"><a href="#6-写在最后" class="headerlink" title="6.写在最后"></a>6.写在最后</h2><p><strong>（1）js的异步</strong></p>
<p>我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方式去模拟的，牢牢把握住单线程这点非常重要。</p>
<p><strong>（2）事件循环Event Loop</strong></p>
<p>事件循环是js实现异步的一种方法，也是js的执行机制。</p>
<p><strong>（3）javascript的执行和运行</strong></p>
<p>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p>
<p><strong>（4）setImmediate</strong></p>
<p>微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。</p>
<p><strong>（5）最后的最后</strong></p>
<ul>
<li>javascript是一门单线程语言</li>
<li>Event Loop是javascript的执行机制</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Javascript面向对象编程（三）：非构造函数的继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Javascript面向对象编程（三）：非构造函数的继承/" itemprop="url">Javascript面向对象编程（三）：非构造函数的继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:33:00+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Javascript面向对象编程（三）：非构造函数的继承"><a href="#Javascript面向对象编程（三）：非构造函数的继承" class="headerlink" title="Javascript面向对象编程（三）：非构造函数的继承"></a>Javascript面向对象编程（三）：非构造函数的继承</h1><p>介绍不使用构造函数实现”继承”。</p>
<h2 id="一、什么是”非构造函数”的继承？"><a href="#一、什么是”非构造函数”的继承？" class="headerlink" title="一、什么是”非构造函数”的继承？"></a>一、什么是”非构造函数”的继承？</h2><p>比如，现在有一个对象，叫做”中国人”。</p>
<pre><code>　　var Chinese = {
　　　　nation:&apos;中国&apos;
　　};
</code></pre><p>还有一个对象，叫做”医生”。</p>
<pre><code>　　var Doctor ={
　　　　career:&apos;医生&apos;
　　}
</code></pre><p>请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。</p>
<h2 id="二、object-方法"><a href="#二、object-方法" class="headerlink" title="二、object()方法"></a>二、object()方法</h2><p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<pre><code>　　function object(o) {    
　　　　function F() {}    
　　　　F.prototype = o;    
　　　　return new F();    
　　}
</code></pre><p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<pre><code>var Doctor = object(Chinese);
</code></pre><p>然后，再加上子对象本身的属性：</p>
<pre><code>Doctor.career = &apos;医生&apos;;
</code></pre><p>这时，子对象已经继承了父对象的属性了。</p>
<pre><code>alert(Doctor.nation); //中国
</code></pre><h2 id="三、浅拷贝"><a href="#三、浅拷贝" class="headerlink" title="三、浅拷贝"></a>三、浅拷贝</h2><p>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：</p>
<pre><code>　　function extendCopy(p) {    
　　　　var c = {};    
　　　　for (var i in p) { 
　　　　　　c[i] = p[i];
　　　　}    
　　　　c.uber = p;    
　　　　return c;
　　}
</code></pre><p>使用的时候，这样写：</p>
<pre><code>　　var Doctor = extendCopy(Chinese);

　　Doctor.career = &apos;医生&apos;;

　　alert(Doctor.nation); // 中国
</code></pre><p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组。</p>
<pre><code>Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];
</code></pre><p>通过extendCopy()函数，Doctor继承了Chinese。</p>
<pre><code>var Doctor = extendCopy(Chinese);
</code></pre><p>然后，我们为Doctor的”出生地”添加一个城市：</p>
<pre><code>Doctor.birthPlaces.push(&apos;厦门&apos;);
</code></pre><p>发生了什么事？Chinese的”出生地”也被改掉了！</p>
<pre><code>　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门

　　alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门
</code></pre><p>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。</p>
<h2 id="四、深拷贝"><a href="#四、深拷贝" class="headerlink" title="四、深拷贝"></a>四、深拷贝</h2><p>所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。</p>
<pre><code>　　function deepCopy(p, c) {    
　　　　var c = c || {};    
　　　　for (var i in p) {    
　　　　　　if (typeof p[i] === &apos;object&apos;) {    
　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : {};    
　　　　　　　　deepCopy(p[i], c[i]);    
　　　　　　} else {    
　　　　　　　　　c[i] = p[i];    
　　　　　　}
　　　　}    
　　　　return c;
　　}
</code></pre><p>使用的时候这样写：</p>
<pre><code>var Doctor = deepCopy(Chinese);
</code></pre><p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：</p>
<pre><code>　　Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];

　　Doctor.birthPlaces.push(&apos;厦门&apos;);
</code></pre><p>这时，父对象就不会受到影响了。</p>
<pre><code>　　alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门

　　alert(Chinese.birthPlaces); //北京, 上海, 香港
</code></pre><p>目前，jQuery库使用的就是这种继承方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Javascript面向对象编程（二）：构造函数的继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Javascript面向对象编程（二）：构造函数的继承/" itemprop="url">Javascript面向对象编程（二）：构造函数的继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:31:52+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Javascript面向对象编程（二）：构造函数的继承"><a href="#Javascript面向对象编程（二）：构造函数的继承" class="headerlink" title="Javascript面向对象编程（二）：构造函数的继承"></a>Javascript面向对象编程（二）：构造函数的继承</h1><p>今天要介绍的是，对象之间的”继承”的五种方法。</p>
<p>比如，现在有一个”动物”对象的构造函数。</p>
<pre><code>　　function Animal(){    
　　　　this.species = &quot;动物&quot;;    
　　}
</code></pre><p>还有一个”猫”对象的构造函数。</p>
<pre><code>　　function Cat(name,color){    
　　　　this.name = name;    
　　　　this.color = color;    
　　}
</code></pre><p>怎样才能使”猫”继承”动物”呢？</p>
<h2 id="一、-构造函数绑定"><a href="#一、-构造函数绑定" class="headerlink" title="一、 构造函数绑定"></a>一、 构造函数绑定</h2><p>第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p>
<pre><code>　　function Cat(name,color){    
　　　　Animal.apply(this, arguments);    
　　　　this.name = name;    
　　　　this.color = color;    
　　}    
　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);    
　　alert(cat1.species); // 动物
</code></pre><h2 id="二、-prototype模式"><a href="#二、-prototype模式" class="headerlink" title="二、 prototype模式"></a>二、 prototype模式</h2><p>第二种方法更常见，使用prototype属性。</p>
<p>如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。</p>
<pre><code>　　Cat.prototype = new Animal();

　　Cat.prototype.constructor = Cat;

　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);

　　alert(cat1.species); // 动物
</code></pre><p>代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。</p>
<pre><code>Cat.prototype = new Animal();
</code></pre><p>它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？</p>
<pre><code>Cat.prototype.constructor = Cat;
</code></pre><p>原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。</p>
<pre><code>alert(Cat.prototype.constructor == Animal); //true
</code></pre><p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。</p>
<pre><code>alert(cat1.constructor == 
Cat.prototype.constructor); // true
</code></pre><p>因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！</p>
<pre><code>alert(cat1.constructor == Animal); // true
</code></pre><p>这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</p>
<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，</p>
<pre><code>o.prototype = {};
</code></pre><p>那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。</p>
<pre><code>o.prototype.constructor = o;
</code></pre><h2 id="三、-直接继承prototype"><a href="#三、-直接继承prototype" class="headerlink" title="三、 直接继承prototype"></a>三、 直接继承prototype</h2><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>
<p>现在，我们先将Animal对象改写：</p>
<pre><code>　　function Animal(){ }

　　Animal.prototype.species = &quot;动物&quot;;
</code></pre><p>然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。</p>
<pre><code>　　Cat.prototype = Animal.prototype;

　　Cat.prototype.constructor = Cat;

　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);

　　alert(cat1.species); // 动物
</code></pre><p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。</p>
<p>所以，上面这一段代码其实是有问题的。请看第二行</p>
<pre><code>Cat.prototype.constructor = Cat;
</code></pre><p>这一句实际上把Animal.prototype对象的constructor属性也改掉了！</p>
<pre><code>alert(Animal.prototype.constructor); // Cat
</code></pre><h2 id="四、-利用空对象作为中介"><a href="#四、-利用空对象作为中介" class="headerlink" title="四、 利用空对象作为中介"></a>四、 利用空对象作为中介</h2><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p>
<pre><code>　　var F = function(){};    
　　F.prototype = Animal.prototype;    
　　Cat.prototype = new F();    
　　Cat.prototype.constructor = Cat;
</code></pre><p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。</p>
<pre><code>alert(Animal.prototype.constructor); // Animal
</code></pre><p>我们将上面的方法，封装成一个函数，便于使用。</p>
<pre><code>　　function extend(Child, Parent) {    
　　　　var F = function(){};    
　　　　F.prototype = Parent.prototype;    
　　　　Child.prototype = new F();    
　　　　Child.prototype.constructor = Child;    
　　　　Child.uber = Parent.prototype;    
　　}
</code></pre><p>使用的时候，方法如下</p>
<pre><code>　　extend(Cat,Animal);    
　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);    
　　alert(cat1.species); // 动物
</code></pre><p>这个extend函数，就是YUI库如何实现继承的方法。</p>
<p>另外，说明一点，函数体最后一行</p>
<pre><code>Child.uber = Parent.prototype;
</code></pre><p>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<h2 id="五、-拷贝继承"><a href="#五、-拷贝继承" class="headerlink" title="五、 拷贝继承"></a>五、 拷贝继承</h2><p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。</p>
<pre><code>　　function Animal(){}    
　　Animal.prototype.species = &quot;动物&quot;;
</code></pre><p>然后，再写一个函数，实现属性拷贝的目的。</p>
<pre><code>　　function extend2(Child, Parent) {    
　　　　var p = Parent.prototype;    
　　　　var c = Child.prototype;    
　　　　for (var i in p) {    
　　　　　　c[i] = p[i];    
　　　　　　}    
　　　　c.uber = p;    
　　}
</code></pre><p>这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。</p>
<p>使用的时候，这样写：</p>
<pre><code>　　extend2(Cat, Animal);    
　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);    
　　alert(cat1.species); // 动物
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/JavaScript继承机制的设计思想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/JavaScript继承机制的设计思想/" itemprop="url">JavaScript继承机制的设计思想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:30:54+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript继承机制的设计思想"><a href="#JavaScript继承机制的设计思想" class="headerlink" title="JavaScript继承机制的设计思想"></a>JavaScript继承机制的设计思想</h1><p>我一直很难理解JavaScript语言的继承机制。</p>
<p>它没有“子类”和“父类”的概念，也没有“类”(class)和“实例”（intance）的区分，全靠一种很奇特的“原型链”（prototype chain）模式，来实现继承。</p>
<p>我花了很多时间，学习这个部分，还做了很多笔记。但是都属于强行记忆，无法从根本上理解。</p>
<p>直到昨天，我读到法国程序员Vjeux的解释，才恍然大悟，完全明白了JavaScript为什么这样设计。</p>
<p>下面，我尝试用自己的语言，来解释它的设计思想。彻底说明白prototype对象到底是怎么回事。其实根本就没那么复杂，真相非常简单。</p>
<h2 id="一、从古代说起"><a href="#一、从古代说起" class="headerlink" title="一、从古代说起"></a>一、从古代说起</h2><p>要理解JavaScript的设计思想，必须从它的诞生说起。</p>
<p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏“用户名”要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。</p>
<p>因此，网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。工程师Brendan Eich负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。</p>
<p>1994年正是面向对象编程（object-oriented programming）最兴盛的时期，C++是当时最流行的语言，而Java语言的1.0版即将于第二年退出，Sun公司正在大肆造势。</p>
<p>Brendan Eich无疑受到了影响，JavaScript里面所有的数据类型都是对象（object）,这一点与Java非常类似。但是，他随即就遇到了一个难题，到底要不要设计“继承”机制呢？</p>
<h2 id="二、Brendan-Eich的选择"><a href="#二、Brendan-Eich的选择" class="headerlink" title="二、Brendan Eich的选择"></a>二、Brendan Eich的选择</h2><p>如果真的是一种简易的脚本语言，其实不需要有“继承”机制。但是，JavaScript里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich最后还是设计了“继承”。</p>
<p>但是，他不打算引入“类”（class）的概念，因为一旦有了“类”，JavaScript就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。</p>
<p>他考虑到，C++和Java语言都使用new命令，生成实例。</p>
<p>C++的写法是：</p>
<pre><code>ClassName *object = new ClassName(param);
</code></pre><p>Java的写法是：</p>
<pre><code>Foo foo = new Foo();
</code></pre><p>因此，他就把new命令引入了JavaScript，用来从原型对象生成一个实例对象。但是，JavaScript没有“类”，怎么来表示原型对象呢？</p>
<p>这时，他想到C++和Java使用new命令时，都会调用“类”的构造函数（constructor）。他就做了一个简化的设计，在Javascript语言中，new命令后面跟的不是类，而是构造函数。</p>
<p>举例来说，现在有一个叫做DOG的构造函数，表示狗对象的原型。</p>
<pre><code>function DOG(name) {
    this.name = name;
}
</code></pre><p>对这个构造函数使用new，就会生成一个狗对象的实例。</p>
<pre><code>var dogA = new DOG(&apos;大毛&apos;);
alert(dogA.name); // 大毛
</code></pre><p>注意构造函数中的this关键字，它就代表了新创建的实例对象。</p>
<h2 id="三、new运算符的缺点"><a href="#三、new运算符的缺点" class="headerlink" title="三、new运算符的缺点"></a>三、new运算符的缺点</h2><p>用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。</p>
<p>比如，在DOG对象的构造函数中，设置一个实例对象的共有属性species。</p>
<pre><code>function DOG(name) {
    this.name = name;
    this.species = &apos;犬科&apos;;
}
</code></pre><p>然后，生成两个实例对象：</p>
<pre><code>var dogA = new DOG(&apos;大毛&apos;);
var dogB = new DOG(&apos;二毛&apos;);
</code></pre><p>这两个对象的species属性是独立的，修改其中一个，不会影响到另一个。</p>
<pre><code>dogA.species = &apos;猫科&apos;;
alert(dogB.species); // 显示“犬科”，不受dogA的影响
</code></pre><p>每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。</p>
<h2 id="四、prototype属性的引入"><a href="#四、prototype属性的引入" class="headerlink" title="四、prototype属性的引入"></a>四、prototype属性的引入</h2><p>考虑到这一点，Brandan Eich决定为构造函数设置一个prototype属性。</p>
<p>这个属性包含一个对象（以下简称“prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；哪些不需要共享的属性和方法，就放在构造函数里面。</p>
<p>实例对象一旦创建，将自动引入prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引入的。</p>
<p>还是以DOG构造函数为例，现在用prototype属性进行改写：</p>
<pre><code>function DOG(name) {
    this.name = name;
}
DOG.prototype = {species: &apos;犬科&apos;};
var dogA = new DOG(&apos;大毛&apos;);
var dogB = new DOG(&apos;二毛&apos;);

alert(dogA.species); // 犬科
alert(dogB.species); // 犬科
</code></pre><p>现在，species属性放在prototype对象里，是两个实例对象共享的。只要修改了prototype对象，就会同时影响到两个实例对象。</p>
<pre><code>DOG.prototype.species = &apos;猫科&apos;;
alert(dogA.species); // 猫科
alert(dogB.species); // 猫科
</code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像“继承”了prototype对象一样。</p>
<p>这就是Javacript继承机制的设计思想。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/JavaScript的this原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/JavaScript的this原理/" itemprop="url">JavaScript的this原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:29:38+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript的this原理"><a href="#JavaScript的this原理" class="headerlink" title="JavaScript的this原理"></a>JavaScript的this原理</h1><h2 id="一、问题的由来"><a href="#一、问题的由来" class="headerlink" title="一、问题的由来"></a>一、问题的由来</h2><p>学懂JavaScript语言，一个标志就是理解下面两种写法，可能有不一样的结果。</p>
<pre><code>var obj = {
    foo: function(){}
}
var foo = obj.foo;
// 写法一
obj.foo();
// 写法二
foo()
</code></pre><p>上面代码中，虽然obj.foo和foo指向同一个函数，但是执行结果可能不一样。请看下面的例子。</p>
<pre><code>var obj = {
    foo: function() {console.log(this.bar)},
    bar: 1
};
var foo = obj.foo;
var bar = 2;
obj.foo() // 1
foo() //2
</code></pre><p>这种差异的原因，就在于函数体内部使用了this关键字。很多教科书会告诉你，this指的是函数运行时所在的环境。对于obj.foo()来说，foo运行在obj环境，所以this指向obj；对于foo()来说，foo运行在全局环境，所以this指向全局环境。所以，两者的运行结果不一样。</p>
<p>这种解释没错，但是教科书往往不告诉你，为什么这样？也就是说，函数的运行环境到底是怎么决定的？举例来说，为什么obj.foo()就是在obj环境执行，而一旦var foo = obj.foo，foo()就变成在全局环境执行？</p>
<p>本文就来解释JavaScript这样处理的原理。理解了这一点，你就彻底理解this的作用。</p>
<h2 id="二、内存的数据结构"><a href="#二、内存的数据结构" class="headerlink" title="二、内存的数据结构"></a>二、内存的数据结构</h2><p>JavaScript语言之所以有this的设计，跟内存里面的数据结构有关系。</p>
<pre><code>var obj = {foo:5};
</code></pre><p>上面的代码将一个对象赋值给变量obj。JavaScript引擎会先在内存里面，生成一个对象{foo:5}，然后把这个对象的内存地址赋值给变量obj。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061801.png" alt=""></p>
<p>也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061802.png" alt=""></p>
<pre><code>{
    foo: {
        [[value]]: 5
        [[writable]]: true
        [[enumerable]]: true
        [[configurable]]: true
    }
}
</code></pre><p>注意，foo属性的值保存在属性描述对象的value属性里面。</p>
<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p>
<pre><code>var obj = { foo: function() {} };
</code></pre><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061803.png" alt=""></p>
<pre><code>{
    foo: {
        [[value]]: 函数的地址
        ...
    }
}
</code></pre><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p>
<pre><code>var f = function () {};
var obj = {f:f};

// 单独执行
f()

// obj环境执行
obj.f()
</code></pre><h2 id="四、环境变量"><a href="#四、环境变量" class="headerlink" title="四、环境变量"></a>四、环境变量</h2><p>JavaScript允许在函数体内部，引用当前环境的其他变量。</p>
<pre><code>var f = function () {
    console.log(x);
}
</code></pre><p>上面代码中，函数体里面使用了变量x。该变量由运行环境提供。</p>
<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>
<pre><code>var f = function () {
    console.log(this.x);
}
</code></pre><p>上面代码中，函数体里面的this.x就是指当前运行环境的x。</p>
<pre><code>var f = function() {
    console.log(this.x);
}

var x=1;
var obj = {
    f: f,
    x: 2,
};

//单独执行
f() //1

//obj环境执行
obj.f() //2
</code></pre><p>上面代码中，函数f在全局环境执行，this.x指向全局全局环境的x。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061804.png" alt=""></p>
<p>在obj环境执行，this.x指向obj.x。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018061805.png" alt=""></p>
<p>回到本文开头提出的问题，obj.foo()是通过obj找到foo，所以就是在obj环境执行。一旦var foo = obj.foo，变量foo就直接指向函数本身，所以foo()就变成在全局环境执行。</p>
<hr>
<p>Whenever a function is called, we must look at the immediate left side of the brackets / parentheses “()”. If on the left side of the parentheses we can see a reference, then the value of “this” passed to the function call is exactly of which that object belongs to, otherwise it is the global object.</p>
<hr>
<p>Javascript 是一个文本作用域的语言, 就是说, 一个变量的作用域, 在写这个变量的时候确定. this 关键字是为了在 JS 中加入动态作用域而做的努力. 所谓动态作用域, 就是说变量的作用范围, 是根据函数调用的位置而定的. 从这个角度来理解 this, 就简单的多.</p>
<p>this 是 JS 中的动态作用域机制, 具体来说有四种, 优先级有低到高分别如下:</p>
<ol>
<li><p>默认的 this 绑定, 就是说 在一个函数中使用了 this, 但是没有为 this 绑定对象. 这种情况下, 非严格默认, this 就是全局变量 Node 环境中的 global, 浏览器环境中的 window.</p>
</li>
<li><p>隐式绑定: 使用 obj.foo() 这样的语法来调用函数的时候, 函数 foo 中的 this 绑定到 obj 对象.</p>
</li>
<li><p>显示绑定: foo.call(obj, …), foo.apply(obj,[…]), foo.bind(obj,…)</p>
</li>
<li><p>构造绑定: new foo() , 这种情况, 无论 foo 是否做了绑定, 都要创建一个新的对象, 然后 foo 中的 this 引用这个对象.</p>
</li>
</ol>
<p>详见: Your Donot Know JS : this &amp; Object</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/JavaScript-Learn-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/JavaScript-Learn-2/" itemprop="url">JavaScript_Learn_2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:28:46+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript-DOM"><a href="#JavaScript-DOM" class="headerlink" title="JavaScript DOM"></a>JavaScript DOM</h1><h2 id="1-JavaScript的组成"><a href="#1-JavaScript的组成" class="headerlink" title="1.JavaScript的组成"></a>1.JavaScript的组成</h2><p>完整的JavaScript是由ECMAScript（语法）、Browser Objects(DOM、BOM)(特性)组成的。</p>
<h2 id="2-DOM查找方法"><a href="#2-DOM查找方法" class="headerlink" title="2.DOM查找方法"></a>2.DOM查找方法</h2><p>语法：document.getElementById(“id”)</p>
<p>功能：返回对拥有指定ID的第一个对象的引用</p>
<p>返回值：DOM对象</p>
<p>说明：id为DOM元素上id属性的值</p>
<h2 id="3-DOM查找方法（2）"><a href="#3-DOM查找方法（2）" class="headerlink" title="3.DOM查找方法（2）"></a>3.DOM查找方法（2）</h2><p>语法：document.getElementsByTagName(“tag”)</p>
<p>功能：返回一个对所有tag标签引用的集合</p>
<p>返回值：数组</p>
<p>说明：tag为要获取的标签名称</p>
<h2 id="4-设置元素样式"><a href="#4-设置元素样式" class="headerlink" title="4.设置元素样式"></a>4.设置元素样式</h2><p>语法：ele.style.styleName=styleValue</p>
<p>功能：设置ele元素的CSS样式</p>
<p>说明：</p>
<ol>
<li>ele为要设置样式的DOM对象</li>
<li>styleName为要设置的样式名称</li>
<li>styleValue为设置的样式值</li>
<li>styleName 不能使用”-“连字符形式font-size<br> 使用驼峰命名形式fontSize</li>
</ol>
<h2 id="5-innerHTML"><a href="#5-innerHTML" class="headerlink" title="5.innerHTML"></a>5.innerHTML</h2><p>语法：ele.innerHTML</p>
<p>功能：返回ele元素开始和结束标签之间的HTML</p>
<p>语法：ele.innerHTML=”html”</p>
<p>功能：设置ele元素开始和结束标签之间的HTML内容为html</p>
<p>innerHTML:获取和设置标签之间的文本和html内容</p>
<h2 id="6-className"><a href="#6-className" class="headerlink" title="6.className"></a>6.className</h2><p>语法：ele.className</p>
<p>功能：返回ele元素的class属性</p>
<p>语法：ele.className=”cls”</p>
<p>功能：设置ele元素的class属性为cls</p>
<p>ele.className是重新设置类，替换元素本身的class</p>
<h2 id="7-获取属性"><a href="#7-获取属性" class="headerlink" title="7.获取属性"></a>7.获取属性</h2><p>语法：ele.getAttribute(“attribute”)</p>
<p>功能：获取ele元素的attribute属性</p>
<p>说明：</p>
<ol>
<li>ele是要操作的dom对象</li>
<li><p>attribute是要获取的html属性（如：id、type）</p>
<p> 获取标签属性语法：</p>
<p> DOM对象.属性，如p.id</p>
</li>
</ol>
<h2 id="8-删除属性"><a href="#8-删除属性" class="headerlink" title="8.删除属性"></a>8.删除属性</h2><p>语法：ele.removeAttribute(“attribute”)</p>
<p>功能：删除ele上的attribute</p>
<p>说明：</p>
<ol>
<li>ele是要删除的dom对象</li>
<li>attribute是要删除的属性名称</li>
</ol>
<h2 id="9-什么是事件"><a href="#9-什么是事件" class="headerlink" title="9.什么是事件"></a>9.什么是事件</h2><p>事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。</p>
<h2 id="10-HTML事件"><a href="#10-HTML事件" class="headerlink" title="10.HTML事件"></a>10.HTML事件</h2><p>直接在HTML元素标签内添加事件，执行脚本。</p>
<p>语法：<tag 事件="执行脚本"></tag></p>
<p>功能：在HTML元素上绑定事件。</p>
<p>说明：执行脚本可以是一个函数的调用。</p>
<h2 id="11-鼠标事件"><a href="#11-鼠标事件" class="headerlink" title="11.鼠标事件"></a>11.鼠标事件</h2><ul>
<li>onload：页面加载时触发</li>
<li>onclick：鼠标点击时触发</li>
<li>onmouseover：鼠标滑过时触发</li>
<li>onmouseout：鼠标离开时触发</li>
<li>onfoucs：获得焦点时触发</li>
<li>onblur：失去焦点时触发</li>
<li>onchange：域的内容改变时发生</li>
</ul>
<h2 id="12-关于this指向"><a href="#12-关于this指向" class="headerlink" title="12.关于this指向"></a>12.关于this指向</h2><p>在事件触发的函数中，this是对该DOM对象的引用。</p>
<h2 id="13-DOM0级事件"><a href="#13-DOM0级事件" class="headerlink" title="13.DOM0级事件"></a>13.DOM0级事件</h2><p>语法：ele.事件=执行脚本</p>
<p>功能：在DOM对象上绑定事件</p>
<p>说明：执行脚本可以是一个匿名函数，也可以是一个函数的调用。</p>
<p><strong>不建议使用HTML事件原因</strong></p>
<ol>
<li>多元素绑定相同事件时，效率低。</li>
<li>不建议在HTML元素中写JavaScript代码。</li>
</ol>
<p>onfocus事件用于：</p>
<p>-input标签type为text、password</p>
<h2 id="14-鼠标事件"><a href="#14-鼠标事件" class="headerlink" title="14.鼠标事件"></a>14.鼠标事件</h2><ul>
<li>onsubmit：表单中的确认按钮被点击时发生</li>
<li>onmousedown：鼠标按钮在元素上按下时触发</li>
<li>onmouseover：在鼠标指针移动时发生</li>
<li>onmouseup：在元素上松开鼠标按钮时触发</li>
<li>onresize：当调整浏览器窗口的大小时触发</li>
<li>onscroll：拖动滚动条滚动时触发</li>
</ul>
<h2 id="15-键盘事件与keyCode属性"><a href="#15-键盘事件与keyCode属性" class="headerlink" title="15.键盘事件与keyCode属性"></a>15.键盘事件与keyCode属性</h2><p>onkeydown：在用户按下一个键盘按键时发生</p>
<p>onkeypress：在键盘按键被按下并释放一个键时发生</p>
<p>onkeyup：在键盘按键被松开时发生</p>
<p>keyCode：返回onkeypress、onkeydown或onkeyup事件触发的键的值的字符代码，或键的代码。</p>
<pre><code>event代表事件的状态，如触发event对象的元素、鼠标的位置及状态等
</code></pre><h2 id="16-什么是bom"><a href="#16-什么是bom" class="headerlink" title="16.什么是bom"></a>16.什么是bom</h2><pre><code>BOM(browser object model)浏览器对象模型
    浏览器    对象        模型
</code></pre><p>BOM对象有{window, navigator, screen, history, location, document, event}</p>
<h2 id="17-window"><a href="#17-window" class="headerlink" title="17.window"></a>17.window</h2><p>window是浏览器的一个实例，在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。</p>
<pre><code>Global --&gt;  全局对象

全局方法--- 脚本的任何一个地方都能调用的方法

所有的全局变量和全局方法都被归在window上    
</code></pre><h2 id="18-Window对象的方法"><a href="#18-Window对象的方法" class="headerlink" title="18.Window对象的方法"></a>18.Window对象的方法</h2><p>语法：window.alert(“content”)</p>
<p>功能：显示带有一段消息和一个确认按钮的警告框</p>
<p>语法：window.confirm(“message”)</p>
<p>功能：显示一个带有指定消息和OK及取消按钮的对话框</p>
<p>返回值(布尔值)：如果用户点击确定按钮，则confirm()返回true</p>
<p>如果用户点击取消按钮，则confirm()返回false</p>
<p>语法：window.prompt(“text,defaultText”)</p>
<p>参数说明：</p>
<p>text：要在对话框中显示的纯文本（而不是HTML格式的文本）</p>
<p>defaultText：默认的输入文本</p>
<p>返回值：如果用户单击提示框的取消按钮，则返回null</p>
<p>如果用户单击确认按钮，则返回输入字段当前显示的文本</p>
<h2 id="19-window对象"><a href="#19-window对象" class="headerlink" title="19.window对象"></a>19.window对象</h2><p>语法：window.open(pageURL,name,parameters)</p>
<p>功能：打开一个新的浏览器窗口或查找一个已命名的窗口</p>
<p>参数说明：</p>
<p>pageURL：子窗口路径</p>
<p>name：子窗口句柄（name声明了新窗口的名称，方便后期通过name对子窗口进行引用）</p>
<p>parameters：窗口参数(各参数用逗号分隔)</p>
<pre><code>width:窗口宽度    height:窗口高度
left:窗口X轴坐标        top:窗口Y轴坐标
toolbar:是否显示浏览器的工具栏
menubar:是否显示菜单栏
scrollbars:是否显示滚动条
location:是否显示地址字段
status:是否添加状态栏
</code></pre><p>语法：window.close()</p>
<p>功能：关闭浏览器窗口</p>
<p><strong>JavaScript是单线程语言，单线程就是所执行的代码必须按照顺序。</strong></p>
<h2 id="20-超时调用"><a href="#20-超时调用" class="headerlink" title="20.超时调用"></a>20.超时调用</h2><p>语法：setTimeout(code,millisec)</p>
<p>功能：在指定的毫秒数后调用函数或计算表达式</p>
<p>参数说明：</p>
<ol>
<li>code：要调用的函数或要执行的JavaScript代码串</li>
<li>millisec：在执行代码前需等待的毫秒数</li>
</ol>
<p>说明：setTimeout()只执行code一次。如果要多次调用，可以让code自身再次调用setTimeout()</p>
<p><strong>SetTimeout方法返回一个ID值通过它取消超时调用</strong></p>
<h2 id="21-清除超时调用"><a href="#21-清除超时调用" class="headerlink" title="21.清除超时调用"></a>21.清除超时调用</h2><p>语法：clearTimeout(id_of_settimeout)</p>
<p>功能：取消由setTimeout()方法设置的timeout</p>
<p>参数说明：</p>
<ol>
<li>id_of_settimeout：由setTimeout()返回的ID值，该值标识要取消的延迟执行代码块</li>
</ol>
<h2 id="22-间歇调用"><a href="#22-间歇调用" class="headerlink" title="22.间歇调用"></a>22.间歇调用</h2><p>语法：setTnterval(code,millisec)</p>
<p>功能：每隔指定的时间执行一次代码</p>
<p>参数说明：</p>
<ol>
<li>code：要调用的函数或要执行的代码串</li>
<li>millisec：周期性执行或调用code之间的时间间隔，以毫秒计</li>
</ol>
<h2 id="23-清除间歇调用"><a href="#23-清除间歇调用" class="headerlink" title="23.清除间歇调用"></a>23.清除间歇调用</h2><p>语法：clearInterval(id_of_setinterval)</p>
<p>功能：取消由setTnterval()方法设置的interval</p>
<p>参数说明：</p>
<ol>
<li>id_of_setinterval：由setInterval()返回的ID值</li>
</ol>
<h2 id="24-location对象"><a href="#24-location对象" class="headerlink" title="24.location对象"></a>24.location对象</h2><p>location对象提供了与当前窗口中加载的文档有关的信息，还提供了一些导航的功能，它既是window对象的属性，也是document对象的属性。</p>
<h2 id="25-location对象的常用属性"><a href="#25-location对象的常用属性" class="headerlink" title="25.location对象的常用属性"></a>25.location对象的常用属性</h2><p>语法：location.href</p>
<p>功能：返回当前加载页面的完整URL</p>
<p>说明：location.href与window.location.href等价</p>
<p>语法：location.hash</p>
<p>功能：返回URL中的hash(#号后跟零或多个字符)，如果不包含则返回空字符串。</p>
<p>语法：location.host</p>
<p>功能：返回服务器名称和端口号（如果有）</p>
<p>语法：location.hostname</p>
<p>功能：返回不带端口号的服务器名称。</p>
<p>语法：location.pathname</p>
<p>功能：返回URL中的目录和（或）文件名。</p>
<p>语法：location.port</p>
<p>功能：返回URL中指定的端口号，如果没有，返回空字符串。</p>
<p>语法：location.protocol</p>
<p>功能：返回页面使用的协议。</p>
<p>语法：location.search</p>
<p>功能：返回URL的查询字符串。这个空字符以问好开头。</p>
<h2 id="26-位置操作"><a href="#26-位置操作" class="headerlink" title="26.位置操作"></a>26.位置操作</h2><p>改变浏览器位置的方法：</p>
<pre><code>location.href属性
</code></pre><p>location对象其他属性也可改变URL：</p>
<pre><code>location.hash

location.search
</code></pre><h2 id="27-location-replace"><a href="#27-location-replace" class="headerlink" title="27.location.replace()"></a>27.location.replace()</h2><p>语法：location.replace(url)</p>
<p>功能：重新定向URL。</p>
<p>说明：使用location.replace不会再历史记录中生成新纪录。</p>
<h2 id="28-location-reload"><a href="#28-location-reload" class="headerlink" title="28.location.reload()"></a>28.location.reload()</h2><p>语法：location.reload()</p>
<p>功能：重新加载当前显示的页面。</p>
<p>说明：</p>
<ul>
<li>location.reload()有可能从缓存中加载</li>
<li>location.reload(true)从服务器重新加载</li>
</ul>
<p><strong>history对象保存了用户在浏览器中访问页面的历史记录</strong></p>
<h2 id="29-History历史对象"><a href="#29-History历史对象" class="headerlink" title="29.History历史对象"></a>29.History历史对象</h2><ul>
<li>语法：history.back()</li>
<li>功能：回到历史记录的上一步</li>
<li><p>说明：相当于使用了history.go(-1)</p>
</li>
<li><p>语法：location.forward()</p>
</li>
<li>功能：回到历史记录的下一步</li>
<li><p>说明：相当于使用了history.go(1)</p>
</li>
<li><p>语法：history.go(-n)</p>
</li>
<li>功能：回到历史记录的前n步</li>
<li>语法：history.go(n)</li>
<li>功能：回到历史记录的后n步</li>
</ul>
<p><strong>Screen对象包含有关客户端显示屏幕的信息</strong></p>
<h2 id="30-Screen对象属性"><a href="#30-Screen对象属性" class="headerlink" title="30.Screen对象属性"></a>30.Screen对象属性</h2><p>语法：screen.availWidth</p>
<p>功能：返回可用的屏幕宽度</p>
<p>语法：screen.availHeight</p>
<p>功能：返回可用的屏幕高度</p>
<ul>
<li>获取窗口文档显示区的高度和宽度，可以使用innerHeight和innerWidth</li>
<li>获取显示屏幕的高度和宽度，可以使用availHeight和availWidth</li>
</ul>
<h2 id="31-Navigator"><a href="#31-Navigator" class="headerlink" title="31.Navigator"></a>31.Navigator</h2><p>UserAgent：用来识别浏览器名称、版本、引擎以及操作系统等信息的内容。</p>
<p><strong>indexOf()方法返回某个指定的字符串值在字符串中首次出现的位置，如果没有出现过，返回-1</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/JavaScript-Learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/JavaScript-Learn/" itemprop="url">JavaScript_Learn</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:27:53+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-JavaScript的数据类型"><a href="#1-JavaScript的数据类型" class="headerlink" title="1.JavaScript的数据类型"></a>1.JavaScript的数据类型</h2><pre><code>ECMAScript =&gt; 
{简单数据类型(也称基本数据类型) =&gt; 
{Undefined、Null、Boolean、Number、String}
{复杂数据类型 =&gt; Object
</code></pre><h2 id="2-typeof"><a href="#2-typeof" class="headerlink" title="2.typeof"></a>2.typeof</h2><p>检测变量类型</p>
<h2 id="3-undefined"><a href="#3-undefined" class="headerlink" title="3.undefined"></a>3.undefined</h2><ul>
<li><p>undefined类型只有一个值，即特殊的undefined。</p>
<p>  说明：</p>
<pre><code>一般而言，不存在需要显式地把一个变量设置为undefined值的情况
</code></pre></li>
</ul>
<h2 id="4-null"><a href="#4-null" class="headerlink" title="4.null"></a>4.null</h2><p>1、null值表示一个空对象指针</p>
<p>2、如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。</p>
<pre><code>说明：undefined值是派生自null值的，所以undefined==null的返
回结果是true。
</code></pre><h2 id="5-Number"><a href="#5-Number" class="headerlink" title="5.Number"></a>5.Number</h2><ul>
<li>Number:表示整数和浮点数</li>
<li><p>NaN：即非数值（Not a Number）是一个特殊的数值</p>
<p>  说明：</p>
<pre><code>1. 任何涉及NaN的操作（例如NaN/10）都会返回NaN。

2. NaN与任何值都不相等，包括NaN本身。
</code></pre></li>
</ul>
<p>##6. isNaN() ##</p>
<ul>
<li>语法：isNaN(n)</li>
<li>功能：检测n是否是“非数值”</li>
<li>返回值：boolean</li>
<li>参数：参数n可以是任何类型</li>
</ul>
<p>说明：isNaN()对接收的数值，先尝试转换为数值，再检测是否为非数值。</p>
<h2 id="7-数值转换"><a href="#7-数值转换" class="headerlink" title="7.数值转换"></a>7.数值转换</h2><p>-有3个函数可以把非数值转换为数值：</p>
<p>{Number()    parseInt()    parseFloat()}</p>
<pre><code>说明：    
1.Number()可以用于任何数据类型    
2.parseInt()和parseFloat()则专门用于把字符串转换成数值。
</code></pre><h2 id="8-parseInt"><a href="#8-parseInt" class="headerlink" title="8.parseInt()"></a>8.parseInt()</h2><p>parseInt()：会忽略字符串前面的空格，直至找到第一个非空格字符。</p>
<pre><code>说明：
1、parseInt()：转换空字符串返回NaN。
2、parseInt()这个函数提供第二个参数：转换时使用的基数（即多少进制）
</code></pre><h2 id="9-parseFloat"><a href="#9-parseFloat" class="headerlink" title="9.parseFloat()"></a>9.parseFloat()</h2><p>parseFloat：从第一个字符开始解析每个字符，直至遇到一个无效的浮点数字符为止。</p>
<pre><code>说明：
除了第一个小数点有效外，parseFloat()与parseInt()的第二个区
别在于它始终都会忽略前导的零。
</code></pre><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（“”）或单引号（’’）表示。</p>
<h2 id="11-toString-与String"><a href="#11-toString-与String" class="headerlink" title="11.toString()与String()"></a>11.toString()与String()</h2><pre><code>语法：str.toString()
功能：将str转换为字符串
返回值：str的一个副本
参数：str是要转换的内容，可以是数值、布尔值、对象和字符串。
说明：在不知道要转换的值是不是null或undefined的情况下，还可
以使用String()函数，它能够将任何类型的值转换为字符串。
</code></pre><h2 id="12-Boolean"><a href="#12-Boolean" class="headerlink" title="12.Boolean"></a>12.Boolean</h2><p>用于表示真假的类型，即true表示真，false表示假</p>
<p><strong>类型转换</strong></p>
<p>1、处0之外的所有数字，转换为布尔型都为true</p>
<p>2、除””之外的所有字符，转换为布尔型都为true</p>
<p>3、null和undefined转换为布尔型为false</p>
<h2 id="13-什么是表达式"><a href="#13-什么是表达式" class="headerlink" title="13.什么是表达式"></a>13.什么是表达式</h2><p>将同类型的数据（如常量、变量、函数等），用运算符按一定的规则连接起来的、有意义的式子称为表达式。</p>
<h2 id="14-操作符的分类"><a href="#14-操作符的分类" class="headerlink" title="14.操作符的分类"></a>14.操作符的分类</h2><ol>
<li>算数操作符</li>
<li>逻辑操作符</li>
<li>赋值操作符</li>
<li>比较操作符</li>
<li>三元操作符</li>
</ol>
<h2 id="15-算数操作符"><a href="#15-算数操作符" class="headerlink" title="15.算数操作符"></a>15.算数操作符</h2><pre><code>+：加
-：减
*：乘
/：除
%：取余
</code></pre><p><strong>递增和递减</strong></p>
<ol>
<li>递增</li>
</ol>
<p>++a与a++都是对a进行递增的操作</p>
<p>区别：</p>
<p>++a先返回递增之后的a的值</p>
<p>a++先返回a的原值，再返回递增之后的值</p>
<p>2.递减同理</p>
<h2 id="16-赋值操作符"><a href="#16-赋值操作符" class="headerlink" title="16.赋值操作符"></a>16.赋值操作符</h2><p>简单赋值：=</p>
<p>复合赋值：+=、-=、*=、/=、%=</p>
<h2 id="17-比较操作符"><a href="#17-比较操作符" class="headerlink" title="17.比较操作符"></a>17.比较操作符</h2><pre><code>&gt;、&lt;、&gt;=、&lt;=、==、===、!=、!==
</code></pre><p>==：相等，只比较值是否相等</p>
<p>===：相等，比较值的同时比较数据类型是否相等</p>
<p>!=：不相等，比较值是否不相等</p>
<p>!==：不相等，比较值的同时比较数据类型是否不相等</p>
<p>返回值：<strong>boolean型</strong></p>
<h2 id="18-三元操作符"><a href="#18-三元操作符" class="headerlink" title="18.三元操作符"></a>18.三元操作符</h2><pre><code>语法：
    条件？执行代码1：执行代码2

说明：
    可代替简单的if语句，
    如果条件成立，执行代码1，否则执行代码2
</code></pre><h2 id="19-逻辑操作符"><a href="#19-逻辑操作符" class="headerlink" title="19.逻辑操作符"></a>19.逻辑操作符</h2><p>逻辑操作符：</p>
<p><strong>&amp;&amp;：与（只要有一个条件不成立，返回false）</strong></p>
<p>说明：在有一个操作数不是布尔值的情况，逻辑与操作就不一定返回值，此时它遵守下列规则：</p>
<ol>
<li>如果第一个操作数隐式类型转换后为true，则返回第二个操作数。</li>
<li>如果第一个操作数隐式类型转换后为false，则返回第一个操作数。</li>
<li>如果有一个操作数是null，则返回null</li>
<li>如果有一个操作数是NaN，则返回NaN</li>
<li>如果有一个操作数是undefined，则返回undefined  </li>
</ol>
<p><strong>||：或（只要有一个条件成立，则返回true）</strong></p>
<p>说明：在有一个操作数不是布尔值的情况，逻辑与操作就不一定返回值，此时它遵循下列规则：</p>
<ol>
<li>如果第一个操作数隐式类型转换后为true，则返回第一个操作数。</li>
<li>如果第一个操作数隐式类型转换后为false，则返回第二个操作数。</li>
<li>如果两个操作数是null，则返回null</li>
<li>如果两个操作数是NaN，则返回NaN</li>
<li>如果两个操作数是undefined，则返回undefined</li>
</ol>
<p><strong>! ：非</strong></p>
<p>说明：</p>
<ol>
<li>无论操作数是什么数据类型，逻辑非都会返回一个布尔值</li>
<li><p>！！同时使用两个逻辑非操作数时：</p>
<ul>
<li>第一个逻辑非操作会基于无论什么操作数返回一个布尔值</li>
<li>第二个逻辑非则对该布尔值求反</li>
</ul>
</li>
</ol>
<h2 id="20-if语句"><a href="#20-if语句" class="headerlink" title="20.if语句"></a>20.if语句</h2><p>语法一：</p>
<pre><code>if(condition) {
    statement1;
}
</code></pre><p>语法二：</p>
<pre><code>if(condition) {
    statemnet1;
} else {
    statement2;
}
</code></pre><p>语法三：</p>
<pre><code>if(condition) {
    statemnet1;
}else if(condition){
    statement2;
}...else{
    statement3;s
}
</code></pre><p><strong>// 总结重点</strong></p>
<pre><code>var str=&quot;abc123&quot;;
var num=parseInt(str);
if(num==NaN) {    // NaN和任何内容都不相等，包括它本身
    alert(NaN);
}else if(num==123) {
    alert(123);
}else if(typeof num==&quot;number&quot;){
    alert(&quot;num&quot;);
}else{
    alert(&quot;str&quot;);
}
// num
</code></pre><h2 id="21-alert"><a href="#21-alert" class="headerlink" title="21.alert()"></a>21.alert()</h2><p>语法：alert()</p>
<p>功能：弹出警告对话框</p>
<h2 id="22-prompt"><a href="#22-prompt" class="headerlink" title="22.prompt()"></a>22.prompt()</h2><p>语法：prompt()</p>
<p>功能：弹出输入框</p>
<p>返回值：</p>
<ol>
<li>点击确定，返回输入内容</li>
<li>点击取消，返回null</li>
</ol>
<h2 id="23-length"><a href="#23-length" class="headerlink" title="23.length"></a>23.length</h2><p>语法：string.length</p>
<p>功能：获取string字符串的长度</p>
<p>返回值：number</p>
<h2 id="24-获取星期"><a href="#24-获取星期" class="headerlink" title="24.获取星期"></a>24.获取星期</h2><p>语法：new Date().getDay()</p>
<p>功能：获取星期</p>
<p>返回值：number(0-6)</p>
<h2 id="25-switch语句"><a href="#25-switch语句" class="headerlink" title="25.switch语句"></a>25.switch语句</h2><p>语法：</p>
<pre><code>switch(expression){
    case value:statement
    break;
    case value:statement
    break;
    ......
    default:statement
}
</code></pre><h2 id="26-输出"><a href="#26-输出" class="headerlink" title="26.输出"></a>26.输出</h2><p>语法：document.write(“内容”)</p>
<p>功能：向浏览器输出内容</p>
<h2 id="27-for语句"><a href="#27-for语句" class="headerlink" title="27.for语句"></a>27.for语句</h2><p>语法：</p>
<pre><code>for(语句1:；语句2；语句3){
    被执行的代码块；
}
</code></pre><p>语句1：在循环（代码块）开始前执行</p>
<p>语句2：定义运行循环（代码块）的条件</p>
<p>语句3：在循环（代码块）已被执行之后执行</p>
<h2 id="28-嵌套"><a href="#28-嵌套" class="headerlink" title="28.嵌套"></a>28.嵌套</h2><p>当循环与循环发生嵌套时遵循下列规则：</p>
<ol>
<li>外层为假时内层不执行；</li>
<li>先执行外层再执行内层，直至内层的条件为假时再返回外层去执行。</li>
</ol>
<h2 id="30-while语句"><a href="#30-while语句" class="headerlink" title="30.while语句"></a>30.while语句</h2><p>语法：</p>
<pre><code>while(条件){
    需要执行的代码；
}
</code></pre><h2 id="31-do-while语句"><a href="#31-do-while语句" class="headerlink" title="31.do-while语句"></a>31.do-while语句</h2><p>语法：</p>
<pre><code>do{
    需要执行的代码；
}while(条件)
</code></pre><p>说明：这种语法的循环至少要被执行一次。</p>
<h2 id="32-for与while的区别"><a href="#32-for与while的区别" class="headerlink" title="32.for与while的区别"></a>32.for与while的区别</h2><pre><code>for：适合已知循环次数的循环体
while：适合未知循环次数的循环体
</code></pre><h2 id="33-break语句"><a href="#33-break语句" class="headerlink" title="33.break语句"></a>33.break语句</h2><p>break：立即退出循环</p>
<h2 id="34-continue语句"><a href="#34-continue语句" class="headerlink" title="34.continue语句"></a>34.continue语句</h2><p>continue：结束本次循环，继续开始下一次。</p>
<h2 id="35-函数的作用"><a href="#35-函数的作用" class="headerlink" title="35.函数的作用"></a>35.函数的作用</h2><p>通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。</p>
<h2 id="36-函数的定义"><a href="#36-函数的定义" class="headerlink" title="36.函数的定义"></a>36.函数的定义</h2><p>函数使用<strong>function</strong>声明，后跟一组参数以及函数体，语法如下：</p>
<pre><code>function functionName([arg0,arg1,...argn]){
    statements
}
</code></pre><p>说明：</p>
<ol>
<li>functionName是要定义的函数名，属于标识符</li>
<li>[]中的arg0,arg1,…argn为函数的参数</li>
<li>[]说明里面的内容不是必须的，它不是语法</li>
</ol>
<h2 id="37-函数的调用"><a href="#37-函数的调用" class="headerlink" title="37.函数的调用"></a>37.函数的调用</h2><p>语法：</p>
<p>函数名([arg1,arg2,…argn])</p>
<h2 id="38-函数的返回值"><a href="#38-函数的返回值" class="headerlink" title="38.函数的返回值"></a>38.函数的返回值</h2><p>任何函数通过<strong>return</strong>语句，后面跟着返回的值来实现返回值。</p>
<p>说明：</p>
<ol>
<li>函数会在执行完return语句之后停止并立即退出。</li>
<li>return语句也可以不带有任何返回值，用于提前停止函数执行又不需要返回值的情况。</li>
</ol>
<h2 id="39-arguments"><a href="#39-arguments" class="headerlink" title="39.arguments"></a>39.arguments</h2><p>ECMAScript中的参数在内部用数组来表示，在函数体内通过arguments对象来访问这个数组参数。</p>
<p>说明：</p>
<ol>
<li>arguments对象只是与数组相似，并不是Array的实例。</li>
<li>[]语法访问它的每一个元素。</li>
<li>length属性确定传递参数的个数。</li>
</ol>
<p>// 求任意一组数的平均值</p>
<pre><code>function getAvg(){
    // 多所有参数进行求和
    var sum=0,len=arguments.length,i;
    for(i=0;i&lt;len;i++){
        sum+=arguments[i];
    }
    console.log(sum);
}
getAvg(5,66,45,32,88,24,40)
</code></pre><h2 id="40-JavaScript中的内置对象"><a href="#40-JavaScript中的内置对象" class="headerlink" title="40.JavaScript中的内置对象"></a>40.JavaScript中的内置对象</h2><p>1、Array        2、String    3、Math    4、Date</p>
<h2 id="41-如何创建数组"><a href="#41-如何创建数组" class="headerlink" title="41.如何创建数组"></a>41.如何创建数组</h2><p>创建数组的基本方式有两种：</p>
<p>1、使用Array构造函数</p>
<p>语法：new Array()</p>
<pre><code>小括号()说明：
（1）预先知道数组要保存的项目数量
（2）向Array构造函数中传递数组应包含的项
</code></pre><p>2、使用数组字面量表示法</p>
<p>由一对包含数组项的方括号[]表示，多个数组项之间以逗号隔开。</p>
<h2 id="42-数组元素的读写"><a href="#42-数组元素的读写" class="headerlink" title="42.数组元素的读写"></a>42.数组元素的读写</h2><p>读取和设置值时，使用方括号[]并提供相应的索引</p>
<p>说明：索引是从0开始的正整数</p>
<h2 id="43-数组长度"><a href="#43-数组长度" class="headerlink" title="43.数组长度"></a>43.数组长度</h2><p>语法：array.length</p>
<p>功能：获取数组array的长度</p>
<p>返回值：number</p>
<p>说明：</p>
<ol>
<li>通过设置length可以从数组的末尾移除项或向数组中添加新项。</li>
<li>把一个值放在超出当前数组大小的位置上时，会重新计算数组长度值，长度值等于最后一项索引加1。</li>
</ol>
<p>数组的栈方法：</p>
<ol>
<li>push()</li>
<li>unshift()</li>
<li>pop()</li>
<li>shift()</li>
</ol>
<h2 id="44-push"><a href="#44-push" class="headerlink" title="44.push()"></a>44.push()</h2><p>语法：</p>
<p>arrayObject.push(newele1,newele2,…,neweX)</p>
<p>功能：</p>
<p>把它的参数顺序添加到arrayObject的尾部。</p>
<p>返回值：</p>
<p>把指定的值添加到数组后的新长度。</p>
<h2 id="45-unshift"><a href="#45-unshift" class="headerlink" title="45.unshift()"></a>45.unshift()</h2><p>语法：</p>
<p>arrayObject.unshift(newele1,newwlw2,…,neweX)</p>
<p>功能：</p>
<p>把它的参数顺序添加到arrayObject的开头。</p>
<p>返回值：</p>
<p>把指定的值添加到数组后的新长度。</p>
<h2 id="46-pop"><a href="#46-pop" class="headerlink" title="46.pop()"></a>46.pop()</h2><p>语法：</p>
<p>arrayObject.pop()</p>
<p>功能：</p>
<p>删除arrayObject的最后一个元素</p>
<p>返回值：</p>
<p>被删除的那个元素</p>
<h2 id="47-shift"><a href="#47-shift" class="headerlink" title="47.shift()"></a>47.shift()</h2><p>语法：</p>
<p>arrayObject.shift()</p>
<p>功能：</p>
<p>删除arrayObject中的第一个元素</p>
<p>返回值：</p>
<p>被删除的那个元素</p>
<h1 id="数组的转换方法和重排序方法"><a href="#数组的转换方法和重排序方法" class="headerlink" title="数组的转换方法和重排序方法"></a>数组的转换方法和重排序方法</h1><h2 id="48-join"><a href="#48-join" class="headerlink" title="48.join()"></a>48.join()</h2><p>语法：</p>
<p>arrayObject.join(separator)</p>
<p>功能：</p>
<p>用于把数组中的所有元素放入一个字符串。</p>
<p>返回值：</p>
<p>字符串。</p>
<h2 id="49-reverse"><a href="#49-reverse" class="headerlink" title="49.reverse()"></a>49.reverse()</h2><p>语法：</p>
<p>stringObject.reverse()</p>
<p>功能：</p>
<p>用于颠倒数组中元素的顺序。</p>
<p>返回值：</p>
<p>数组。</p>
<h2 id="50-sort"><a href="#50-sort" class="headerlink" title="50.sort()"></a>50.sort()</h2><p>语法：</p>
<p>arrayObject.sort(sortby)</p>
<p>功能：</p>
<p>用于对数组的元素进行排序。</p>
<p>返回值：数组。</p>
<p>说明：</p>
<ol>
<li>即使数组中的每一项都是数值，sort()方法比较的也是字符串。</li>
<li>sort()方法可以接受一个比较函数作为参数。</li>
</ol>
<h2 id="51-concat"><a href="#51-concat" class="headerlink" title="51.concat()"></a>51.concat()</h2><p>语法：</p>
<p>arrayObject.concat(arrayX,arrayX,…,arrayX)</p>
<p>功能：</p>
<p>用于连接两个或多个数组。</p>
<p>返回值：</p>
<p>数组。</p>
<h2 id="52-slice"><a href="#52-slice" class="headerlink" title="52.slice()"></a>52.slice()</h2><p>语法：</p>
<p>arrayObject.slice(start,end)</p>
<p>功能：</p>
<p>从已有的数组中返回选定的元素</p>
<p>参数：</p>
<ol>
<li>start（必需）规定从何处开始选取，如是负数，从数组尾部开始算起</li>
<li>end（可选）规定从何处结束选取，是数组片段结束处的数组下标</li>
</ol>
<p>说明：</p>
<ol>
<li>如没指定end，切分的数组包含从start到数组结束的所有元素。</li>
<li>如slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。</li>
</ol>
<p>返回值：数组</p>
<p>说明：</p>
<ol>
<li>Start和end指的是数组中索引值</li>
<li>截取从Start和end（不包含该元素）的元素，即从Start和end-1的元素</li>
</ol>
<p><strong>// 完成以下代码段，实现b数组对a数组的拷贝，方法越多越好</strong></p>
<pre><code>var a=[1,&quot;yes&quot;,3],
    b;

// 1、数组遍历，push
b = new Array();
for(var i=0;i&lt;a.length;i++){
    b.push(a[i]);
}

//2、concat()
b=[].concat(a);

//3、slice()
b=a.slice(0);
console.log(b);
</code></pre><h2 id="53-删除"><a href="#53-删除" class="headerlink" title="53.删除"></a>53.删除</h2><p>语法：</p>
<p>arrayObject.splice(index,count)</p>
<p>功能：</p>
<p>删除从index处开始的零个或多个元素。</p>
<p>返回值：</p>
<p>含有被删除的元素的数组。</p>
<p>说明：</p>
<p>count是要删除的项目数量，如果设置为0，则不会删除项目。</p>
<p>如果不设置，则删除从index开始的所有值。</p>
<h2 id="54-插入"><a href="#54-插入" class="headerlink" title="54.插入"></a>54.插入</h2><p>语法：</p>
<p>arrayObject.splice(index,0,item1,…,itemX)</p>
<p>功能：</p>
<p>在指定位置插入值</p>
<p>参数：</p>
<p>Index：起始位置</p>
<p>0：要删除的项数</p>
<p>item1…itemX：要插入的项</p>
<p>返回值：数组</p>
<h2 id="55。替换"><a href="#55。替换" class="headerlink" title="55。替换"></a>55。替换</h2><p>语法：</p>
<p>arrayObject.splice(index,count,item1,…,itemX)</p>
<p>功能：</p>
<p>在指定位置插入值，且同时删除任意数量的项</p>
<p>参数：</p>
<p>Index：起始位置</p>
<p>count：要删除的项数</p>
<p>item1…itemX：要插入的项</p>
<p>返回值：从原始数组中删除的项（如果没有删除任何项，则返回空数组）</p>
<h2 id="56-indexOf"><a href="#56-indexOf" class="headerlink" title="56.indexOf()"></a>56.indexOf()</h2><p>语法：</p>
<p>arrayObject.indexOf(searchvalue, startIndex)</p>
<p>功能：</p>
<p>从数组的开头（位置0）开始向后查找。</p>
<p>参数：</p>
<p>searchvalue：必需，要查找的项；</p>
<p>startIndex：可选，起点位置的索引。</p>
<p>返回值：</p>
<p>number,查找的项在数组中的位置，没有找到的情况下返回-1.</p>
<h2 id="57-lastIndexOf"><a href="#57-lastIndexOf" class="headerlink" title="57.lastIndexOf()"></a>57.lastIndexOf()</h2><p>语法：</p>
<p>arrayObject.lastIndexOf(searchvalue, startIndex)</p>
<p>功能：</p>
<p>从数组的末尾开始向前查找。</p>
<p>参数：</p>
<p>searchvalue：必需，要查找的项；</p>
<p>startIndex：可选，起点位置的索引。</p>
<p>返回值：</p>
<p>number，查找的项在数组中的位置，没有找到的情况下返回-1。</p>
<p><strong>说明</strong></p>
<ol>
<li>在比较第一个参数与数组中的每一项时，会使用全等操作符，即要求查找的项必须严格相等。</li>
<li>数组的位置方法是ECMAScript5为数组实例新增的，所以支持的浏览器只有：</li>
</ol>
<p>IE9+、Firefox2+、Safari3+、Opera9.5和Chrome。</p>
<pre><code>var nums=[1,7,5,7,8,1,6,9];
// 封装一个方法实现indexOf的功能
function ArrayIndexOf(arr,value) {
    // 检测value在arr中出现的位置
    for(var i=0;i&lt;arr.length;i++) {
        if(arr[i]===value) {
            return i;
        }
    }
    return -1;
}
ArrayIndexOf(nums,8)
</code></pre><h2 id="58-charAt-与charCodeAt"><a href="#58-charAt-与charCodeAt" class="headerlink" title="58.charAt()与charCodeAt()"></a>58.charAt()与charCodeAt()</h2><p>语法：</p>
<p>stringObject.charAt(index)</p>
<p>功能：</p>
<p>返回stringObject中index位置的字符。</p>
<p>语法：</p>
<p>stringObject.charCodeAt(index)</p>
<p>功能：</p>
<p>返回stringObject中index位置字符的字符编码。</p>
<p>说明：</p>
<p>ECMAScript5中可使用“方括号加字符索引”来访问字符串中特定的字符，但是IE7及更早的浏览器会返回undefined。</p>
<h2 id="59-indexOf"><a href="#59-indexOf" class="headerlink" title="59.indexOf()"></a>59.indexOf()</h2><p>语法：</p>
<p>stringObject.indexOf(“o”)</p>
<p>功能：</p>
<p>从一个字符串中搜索给定的字符串，返回子字符串的位置。</p>
<p>返回值：数值。</p>
<p>说明：如果没有找到该子字符串，则返回-1。</p>
<h2 id="60-lastIndexOf"><a href="#60-lastIndexOf" class="headerlink" title="60.lastIndexOf()"></a>60.lastIndexOf()</h2><p>语法：</p>
<p>stringObject.lastIndexOf(“o”)</p>
<p>功能：</p>
<p>从一个字符串中搜索给定的子字符串，返回子字符串的位置。</p>
<p>返回值：数值。</p>
<p>说明：如果没有找到该子字符串，则返回-1。</p>
<h1 id="字符串对象的截取方法"><a href="#字符串对象的截取方法" class="headerlink" title="字符串对象的截取方法"></a>字符串对象的截取方法</h1><h2 id="61-slice"><a href="#61-slice" class="headerlink" title="61.slice()"></a>61.slice()</h2><p>语法：</p>
<p>stringObject.slice(start,end)</p>
<p>功能：</p>
<p>截取子字符串。</p>
<p>参数说明：</p>
<p>1、start：必需，指定子字符串的开始位置。</p>
<p>2、end：可选，表示子字符串到哪里结束，end本身不在截取范围之内，省略时截取至字符串的末尾。</p>
<p>3、当参数为负数时，会将传入的负值与字符串的长度相加。</p>
<p>说明：</p>
<ol>
<li>最后一个参数省略时，截取到末尾。</li>
<li>参数为负数时，其值为字符串长度+该负数。</li>
<li>不包含最后参数本身。</li>
</ol>
<h2 id="62-substring"><a href="#62-substring" class="headerlink" title="62.substring()"></a>62.substring()</h2><p>说明：语法及功能同slice()完全一样。</p>
<p>区别在于：</p>
<ol>
<li>当参数为负数时，自动将参数转换为0。</li>
<li>substring()会将较小的数作为开始位置，将较大的数作为结束位置。</li>
</ol>
<h2 id="63-substr"><a href="#63-substr" class="headerlink" title="63.substr()"></a>63.substr()</h2><p>语法：</p>
<p>stringObject.substr(start,len)</p>
<p>功能：</p>
<p>截取子字符串。</p>
<p>参数说明：</p>
<ol>
<li>start：必需，指定子字符串的开始位置。</li>
<li>len：可选，表示截取的字符总数，省略时截取至字符串的末尾。</li>
<li>当start为负数时，会将传入的负数与字符串的长度相加。</li>
<li>当len为负数时，返回空字符串。</li>
</ol>
<h2 id="64-split"><a href="#64-split" class="headerlink" title="64.split()"></a>64.split()</h2><p>语法：</p>
<p>stringObject.split(separator)</p>
<p>功能：</p>
<p>把一个字符串分隔成字符串数组。</p>
<p>返回值：Array。</p>
<p>说明：</p>
<p>separator：必需，分隔符。</p>
<h2 id="65-replace"><a href="#65-replace" class="headerlink" title="65.replace()"></a>65.replace()</h2><p>语法：</p>
<p>stringObject.replace(regexp/substr,replacement)</p>
<p>功能：</p>
<p>在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<p>返回值：String</p>
<p>参数：</p>
<p>regexp：必需。规定子字符串或要替换的模式的RegExp对象。</p>
<p>replacement：必需。一个字符串值。</p>
<h2 id="66-toUpperCase-与toLowerCase"><a href="#66-toUpperCase-与toLowerCase" class="headerlink" title="66.toUpperCase()与toLowerCase()"></a>66.toUpperCase()与toLowerCase()</h2><p>语法：</p>
<p>stringObject.toUpperCase()</p>
<p>功能：把字符串转换为大写。</p>
<p>语法：</p>
<p>stringObject.toLowerCase()</p>
<p>功能：把字符串转换为小写。</p>
<h1 id="Math对象的方法"><a href="#Math对象的方法" class="headerlink" title="Math对象的方法"></a>Math对象的方法</h1><h2 id="67-Math-min"><a href="#67-Math-min" class="headerlink" title="67.Math.min()"></a>67.Math.min()</h2><p>语法：</p>
<p>Math.min(num1,num2…numN)</p>
<p>功能：</p>
<p>求一组数中的最小数。</p>
<p>返回值：Number。</p>
<h2 id="68-Math-max"><a href="#68-Math-max" class="headerlink" title="68.Math.max()"></a>68.Math.max()</h2><p>语法：</p>
<p>Math.max(num1,num2…numN)</p>
<p>功能：</p>
<p>求一组数中的最大数</p>
<p>返回值：Number。</p>
<h2 id="69-Math-ceil"><a href="#69-Math-ceil" class="headerlink" title="69.Math.ceil()"></a>69.Math.ceil()</h2><p>语法：</p>
<p>Math.ceil(num)</p>
<p>功能：</p>
<p>向上取整，即返回大于num的最小整数。</p>
<p>返回值：Number。</p>
<h2 id="70-Math-floor"><a href="#70-Math-floor" class="headerlink" title="70.Math.floor()"></a>70.Math.floor()</h2><p>语法：</p>
<p>Math.floor(num)</p>
<p>功能：</p>
<p>向下取整，返回num的整数部分。</p>
<p>返回值：Number。</p>
<h2 id="71-Math-round"><a href="#71-Math-round" class="headerlink" title="71.Math.round()"></a>71.Math.round()</h2><p>语法：</p>
<p>Math.round(num)</p>
<p>功能：</p>
<p>将数值四舍五入为最接近的整数。</p>
<p>返回值：Number。</p>
<h2 id="72-Math-abs"><a href="#72-Math-abs" class="headerlink" title="72.Math.abs()"></a>72.Math.abs()</h2><p>语法：</p>
<p>Math.abs(num)</p>
<p>功能：</p>
<p>返回num的绝对值。</p>
<p>返回值：Number。</p>
<h2 id="73-Math-random"><a href="#73-Math-random" class="headerlink" title="73.Math.random()"></a>73.Math.random()</h2><p>语法：</p>
<p>Math.random()</p>
<p>功能：</p>
<p>返回大于等于0小于1的一个随机数。</p>
<p>返回值：Number。</p>
<p>说明：</p>
<p>求n到m之间的随机整数的公式：</p>
<p>random=Math.floor(Math.random()*(m-n+1)+n);</p>
<h1 id="JavaScript中的date对象"><a href="#JavaScript中的date对象" class="headerlink" title="JavaScript中的date对象"></a>JavaScript中的date对象</h1><h2 id="74-如何创建一个日期对象"><a href="#74-如何创建一个日期对象" class="headerlink" title="74.如何创建一个日期对象"></a>74.如何创建一个日期对象</h2><p>语法：new Date();</p>
<p>功能：创建一个日期时间对象</p>
<p>返回值：不传参的情况下，返回当前的日期时间对象。</p>
<p>说明：</p>
<p>如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数或者是一组用逗号隔开的表示年月日时分秒的参数。</p>
<h2 id="75-获取年月日时分秒及星期的方法"><a href="#75-获取年月日时分秒及星期的方法" class="headerlink" title="75.获取年月日时分秒及星期的方法"></a>75.获取年月日时分秒及星期的方法</h2><ol>
<li>getFullYear()：返回4位数的年份</li>
<li>getMonth()：返回日期中的月份，返回值为0-11</li>
<li>getDate()：返回月份中的天数</li>
<li>getDay()：返回星期，返回值为0-6</li>
<li>getHours()：返回小时</li>
<li>getMinutes()：返回分</li>
<li>getSeconds()：返回秒</li>
<li>getTime()：返回表示日期的毫秒数</li>
</ol>
<h2 id="76-设置年月日时分秒及星期的方法"><a href="#76-设置年月日时分秒及星期的方法" class="headerlink" title="76.设置年月日时分秒及星期的方法"></a>76.设置年月日时分秒及星期的方法</h2><ol>
<li>setFullYear(year)：设置4位数的年份</li>
<li>setMonth(mon)：设置日期中的月份，从0开始，0表示1月</li>
<li>setDate()：设置日期</li>
<li>setDay()：设置星期，从0开始，0表示星期日</li>
<li>setHours()：设置小时</li>
<li>setMinutes()：设置分</li>
<li>setSeconds()：设置秒</li>
<li>setTime()：以毫秒数设置日期，会改变整个日期</li>
</ol>
<p>说明：</p>
<p>setMonth()方法用于设置月份。</p>
<p>注意：一月为0，十二月为11</p>
<pre><code>方法        参数        浏览器显示    实际月份        年份
</code></pre><p>setMonth(参数) 12为基数 参数/12,取余数 (数/12,取余数)+1 (数/12,取整)+当前年份</p>
<pre><code>例子        13          1            2           2017

setMonth(参数) 28   4       5           2018
</code></pre><p>注：当前年为2016</p>
<pre><code>// 创建一个日期时间对象
// 50天之后是星期
// 第一种做法
today.setDate(today.getDate() + 50);
console.log(today.getDay());

// 第二种做法
var weeks=[&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;]；
var year = today.getFullYear();
var month = today.getMonth();
var day = today.getDate();
// 创建了一个目标日期对象
var temp = new Date(year,month,day+50);
console.log(&apos;50天后的今天是：&apos;+temp.getFullYear()
+&apos;-&apos;+(temp.getMonth()+1)+&apos;-&apos;+temp.getDate()+&apos;-&apos;+&apos;星
期&apos;+weeks[temp.getDay()]);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Javascript-面向对象编程（一）：封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Javascript-面向对象编程（一）：封装/" itemprop="url">Javascript 面向对象编程（一）：封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:26:48+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Javascript-面向对象编程（一）：封装"><a href="#Javascript-面向对象编程（一）：封装" class="headerlink" title="Javascript 面向对象编程（一）：封装"></a>Javascript 面向对象编程（一）：封装</h1><p>学习Javascript，最难的地方是什么？</p>
<p>我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。</p>
<p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。</p>
<p>那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p>
<h2 id="一、-生成实例对象的原始模式"><a href="#一、-生成实例对象的原始模式" class="headerlink" title="一、 生成实例对象的原始模式"></a>一、 生成实例对象的原始模式</h2><p>假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。</p>
<pre><code>var Cat = {
　　　　name : &apos;&apos;,
　　　　color : &apos;&apos;
　　} 
</code></pre><p>现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。</p>
<pre><code>var cat1 = {}; // 创建一个空对象

　　　　cat1.name = &quot;大毛&quot;; // 按照原型对象的属性赋值

　　　　cat1.color = &quot;黄色&quot;;

　　 var cat2 = {};

　　　　cat2.name = &quot;二毛&quot;;

　　　　cat2.color = &quot;黑色&quot;;
</code></pre><p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<h2 id="二、-原始模式的改进"><a href="#二、-原始模式的改进" class="headerlink" title="二、 原始模式的改进"></a>二、 原始模式的改进</h2><p>我们可以写一个函数，解决代码重复的问题。</p>
<pre><code>function Cat(name,color) {

　　　　return {

　　　　　　name:name,

　　　　　　color:color

　　　　}

　　}
</code></pre><p>然后生成实例对象，就等于是在调用函数：</p>
<pre><code>var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);

　　var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);
</code></pre><p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h2 id="三、-构造函数模式"><a href="#三、-构造函数模式" class="headerlink" title="三、 构造函数模式"></a>三、 构造函数模式</h2><p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。</p>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p>
<p>比如，猫的原型对象现在可以这样写，</p>
<pre><code>　　function Cat(name,color){

　　　　this.name=name;

　　　　this.color=color;

　　}
</code></pre><p>我们现在就可以生成实例对象了。</p>
<pre><code>　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);

　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);

　　alert(cat1.name); // 大毛

　　alert(cat1.color); // 黄色
</code></pre><p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</p>
<pre><code>　　alert(cat1.constructor == Cat); //true

　　alert(cat2.constructor == Cat); //true
</code></pre><p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>
<pre><code>　　alert(cat1 instanceof Cat); //true

　　alert(cat2 instanceof Cat); //true
</code></pre><h2 id="四、构造函数模式的问题"><a href="#四、构造函数模式的问题" class="headerlink" title="四、构造函数模式的问题"></a>四、构造函数模式的问题</h2><p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>
<p>请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：</p>
<pre><code>　　function Cat(name,color){

　　　　this.name = name;

　　　　this.color = color;

　　　　this.type = &quot;猫科动物&quot;;

　　　　this.eat = function(){alert(&quot;吃老鼠&quot;);};

　　}
</code></pre><p>还是采用同样的方法，生成实例：</p>
<pre><code>　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);

　　var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;);

　　alert(cat1.type); // 猫科动物

　　cat1.eat(); // 吃老鼠
</code></pre><p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<pre><code>alert(cat1.eat == cat2.eat); //false
</code></pre><p>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p>
<h2 id="五、-Prototype模式"><a href="#五、-Prototype模式" class="headerlink" title="五、 Prototype模式"></a>五、 Prototype模式</h2><p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>
<pre><code>　　function Cat(name,color){

　　　　this.name = name;

　　　　this.color = color;

　　}

　　Cat.prototype.type = &quot;猫科动物&quot;;

　　Cat.prototype.eat = function(){alert(&quot;吃老鼠&quot;)};
</code></pre><p>然后，生成实例。</p>
<pre><code>　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);

　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);

　　alert(cat1.type); // 猫科动物

　　cat1.eat(); // 吃老鼠
</code></pre><p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</p>
<pre><code>alert(cat1.eat == cat2.eat); //true
</code></pre><h2 id="六、-Prototype模式的验证方法"><a href="#六、-Prototype模式的验证方法" class="headerlink" title="六、 Prototype模式的验证方法"></a>六、 Prototype模式的验证方法</h2><p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>
<p><strong>6.1 isPrototypeOf()</strong></p>
<p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>
<pre><code>　　alert(Cat.prototype.isPrototypeOf(cat1)); //true

　　alert(Cat.prototype.isPrototypeOf(cat2)); //true
</code></pre><p><strong>6.2 hasOwnProperty()</strong></p>
<p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</p>
<pre><code>　　alert(cat1.hasOwnProperty(&quot;name&quot;)); // true

　　alert(cat1.hasOwnProperty(&quot;type&quot;)); // false
</code></pre><p><strong>6.3 in运算符</strong></p>
<p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<pre><code>　　alert(&quot;name&quot; in cat1); // true

　　alert(&quot;type&quot; in cat1); // true
</code></pre><p>in运算符还可以用来遍历某个对象的所有属性。</p>
<pre><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1
[prop]); }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/HTML5阅读器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/HTML5阅读器/" itemprop="url">HTML5阅读器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:26:01+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用Base64格式的图片制作ICON"><a href="#使用Base64格式的图片制作ICON" class="headerlink" title="使用Base64格式的图片制作ICON"></a>使用Base64格式的图片制作ICON</h2><p>优势：</p>
<ul>
<li>Base64图片可以减少请求</li>
<li>加快首屏数据的显示速度</li>
<li>维护不太方便</li>
</ul>
<p>url(data:image/png;base64,{img_data})</p>
<p>base64格式图片生成</p>
<p>通过base64图片编辑器（可上网搜索），将图片拖放进去，即可生成base64格式。</p>
<h2 id="使用CSS3制作简单的ICON"><a href="#使用CSS3制作简单的ICON" class="headerlink" title="使用CSS3制作简单的ICON"></a>使用CSS3制作简单的ICON</h2><p>问题：不易于维护，存在兼容性问题</p>
<p>常用属性：</p>
<p>border-radius</p>
<p>box-shadow</p>
<p>transform</p>
<h2 id="使用viewport布局移动端页面"><a href="#使用viewport布局移动端页面" class="headerlink" title="使用viewport布局移动端页面"></a>使用viewport布局移动端页面</h2><p>使用viewport固定整个页面宽度</p>
<pre><code>&lt;meta name=&quot;viewport&quot; 
      content=&quot;width=device-width,
      initial-scale=1.0,
      maximum-scale=1.0,
      user-scalable=no&quot; /&gt;
</code></pre><h2 id="移动端性能陷阱和硬件加速"><a href="#移动端性能陷阱和硬件加速" class="headerlink" title="移动端性能陷阱和硬件加速"></a>移动端性能陷阱和硬件加速</h2><p>减少或避免repaint(页面重绘)，reflow(页面回流)</p>
<p>尽量缓存所有可以缓存的数据</p>
<p>使用CSS3 transform代替dom操作</p>
<ul>
<li><p>不要给非static定位元素增加CSS3动画</p>
</li>
<li><p>适当的使用硬件加速</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/HTML5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/HTML5/" itemprop="url">HTML5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:25:19+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML5本地存储"><a href="#HTML5本地存储" class="headerlink" title="HTML5本地存储"></a>HTML5本地存储</h2><ul>
<li><p>Storage</p>
<ul>
<li>sessionStorage<ul>
<li>session临时会话，从页面打开到页面关闭的时间段</li>
<li>窗口的临时存储，页面关闭，本地存储消失</li>
</ul>
</li>
<li>localStorage<ul>
<li>永久存储（可以手动删除数据）</li>
</ul>
</li>
</ul>
</li>
<li><p>Storage的特点</p>
<ul>
<li>存储量限制（5M）</li>
<li>客户端完成，不会请求服务器处  理</li>
<li>sessionStorage数据是不共享、localStorage共享</li>
</ul>
</li>
<li><p>Storage API</p>
<ul>
<li>setItem()：<ul>
<li>设置数据，key\value类型，类型都是字符串</li>
<li>可以用获取属性的形式操作</li>
</ul>
</li>
<li>getItem()：<ul>
<li>获取数据，通过key来获取到响应的value</li>
</ul>
</li>
<li>removeItem()：<ul>
<li>删除数据，通过key来删除相应的value</li>
</ul>
</li>
<li>clear()：<ul>
<li>删除全部存储的值</li>
</ul>
</li>
<li>例子：保存注册信息</li>
</ul>
</li>
<li><p>Storage API</p>
<ul>
<li>存储事件：<ul>
<li>当数据有修改或删除的情况下，就会触发storage事件</li>
<li>在对数据进行改变的窗口对象上是不会触发的</li>
<li>Key:修改或删除的key值，如果调用clear(),key为null</li>
<li>newValue：新设置的值，如果调用removeStorage(),key为null</li>
<li>oldValue：调用改变前的value值</li>
<li>storageArea：当前的storage对象</li>
<li>url：触发该脚本变化的文档的url</li>
<li>注：session同窗口才可以，例子：iframe操作</li>
</ul>
</li>
<li>例子：同步购物车</li>
</ul>
</li>
</ul>
<h2 id="HTML5语义化标签的兼容"><a href="#HTML5语义化标签的兼容" class="headerlink" title="HTML5语义化标签的兼容"></a>HTML5语义化标签的兼容</h2><p>兼容IE创建标签</p>
<pre><code>&lt;script&gt;
    document.createElement(&quot;header&quot;);
    document.createElement(&quot;footer&quot;);
    document.createElement(&quot;article&quot;);
&lt;/script&gt;
</code></pre><p>加上    </p>
<pre><code>display: block;
</code></pre><p>或者引入插件</p>
<pre><code>&lt;script src=&quot;html5shiv.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="HTML5表单验证反馈"><a href="#HTML5表单验证反馈" class="headerlink" title="HTML5表单验证反馈"></a>HTML5表单验证反馈</h2><ul>
<li>表单验证<ul>
<li>validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，一种验证失败返回false<ul>
<li>oText.addEventListener(“invalid”, fn1, false);</li>
<li>ev.preventDefault()</li>
<li>valueMissing：输入值为空时</li>
<li>typeMismatch：控件值与预期类型不匹配</li>
<li>patternMismatch：输入值不满足pattern正则</li>
<li>tooLong：超过maxLength最大限制</li>
<li>rangeUnderflow：验证的range最小值</li>
<li>rangeOverflow：验证的range最大值</li>
<li>stepMismatch：验证range的当前值是否符合min、max及step的规则</li>
<li>customError不符合自定义验证</li>
<li>setCustomValidity();自定义验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTML5新的选择器"><a href="#HTML5新的选择器" class="headerlink" title="HTML5新的选择器"></a>HTML5新的选择器</h2><ul>
<li>querySelector</li>
<li>querySelectorAll</li>
<li>getElementsByClassName</li>
</ul>
<p><strong>- 获取class列表属性</strong></p>
<ul>
<li>classList<ul>
<li>length：class的长度</li>
<li>add()：添加class方法</li>
<li>remove()：删除class方法</li>
<li>toggle()：切换class方法</li>
</ul>
</li>
</ul>
<p><strong>- JSON的新方法</strong></p>
<ul>
<li>parse()：把字符串转成json<ul>
<li>字符串中的属性要严格的加上引号</li>
</ul>
</li>
<li>stringify()：把json转化成字符串<ul>
<li>会自动的把双引号加上</li>
</ul>
</li>
<li>新方法与eval的区别</li>
<li>新方法的应用<ul>
<li>深度克隆新对象</li>
</ul>
</li>
<li>如何与其他浏览器做到兼容<ul>
<li><a href="http://www.json.org/去下载json2.js" target="_blank" rel="noopener">http://www.json.org/去下载json2.js</a></li>
</ul>
</li>
</ul>
<p>eval：可以解析任何字符串变成JS</p>
<p>parse：只能解析JSON形式的字符串变成JS（安全性要高一些）</p>
<h2 id="自定义数据与JS加载"><a href="#自定义数据与JS加载" class="headerlink" title="自定义数据与JS加载"></a>自定义数据与JS加载</h2><ul>
<li><p>data自定义数据</p>
<ul>
<li>dataset<ul>
<li>data-name：dataset.name</li>
<li>data-name-first：dataset.nameFirst</li>
</ul>
</li>
<li>Data数据在jquery mobile中有着重要作用</li>
</ul>
</li>
<li><p>延迟加载JS</p>
<ul>
<li>JS的加载会影响后面的内容加载<ul>
<li>很多浏览器都采用了并行加载JS，但还是会影响其他内容</li>
</ul>
</li>
<li>Html5的defer和async<ul>
<li>defer：延迟加载，会按顺序执行，在onload执行前被触发</li>
<li>async：异步加载，加载完就触发，有顺序问题</li>
</ul>
</li>
<li>Labjs库</li>
</ul>
</li>
</ul>
<h2 id="历史管理"><a href="#历史管理" class="headerlink" title="历史管理"></a>历史管理</h2><ul>
<li>历史管理<ul>
<li>onhashchange：改变hash值来管理</li>
<li>history：<ul>
<li>服务器下运行</li>
<li>pushState：三个参数：数据 标题(都没实现) 地址(可选)</li>
<li>popstate事件：读取数据 event.state</li>
<li>注意：网址是虚假的，需在服务器指定对应页面，不然刷新找不到页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>触发历史管理：</p>
<ol>
<li>通过跳转页面</li>
<li>hash</li>
<li>pushState</li>
</ol>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><ul>
<li><p>draggable：</p>
<ul>
<li>设置为true，元素就可以拖拽了</li>
</ul>
</li>
<li><p>拖放事件</p>
<ul>
<li>拖拽元素事件：事件对象为被拖拽元素<ul>
<li>dragstart，拖拽前触发</li>
<li>drag,拖拽前、拖拽结束之前，连续触发</li>
<li>dragend，拖拽结束触发</li>
</ul>
</li>
<li><p>目标元素事件：事件对象为目标元素</p>
<ul>
<li>dragenter，进入目标元素触发，相当于mouseover</li>
<li>dragover，进入目标、离开目标之间，连续触发</li>
<li>dragleave，离开目标元素触发，相当于mouseout</li>
<li>drop，在目标元素上释放鼠标触发</li>
</ul>
</li>
<li><p>事件的执行顺序：drop不触发的时候</p>
<ul>
<li>dragstart &gt; drag &gt; dragenter &gt; dragover &gt; dragleave &gt;dragend</li>
</ul>
</li>
<li>事件的执行顺序：drop触发的时候(dragover的时候阻止默认事件)<ul>
<li>dragstart &gt; drag &gt; dragenter &gt; dragover &gt; drop &gt; dragend</li>
</ul>
</li>
<li><p>不能释放的光标和能释放的光标不一样</p>
</li>
<li><p>解决火狐下的问题</p>
<ul>
<li>必须设置dataTransfer对象的setData方法才可以拖拽除图片外的其他标签</li>
</ul>
</li>
</ul>
</li>
<li><p>dataTransfer对象</p>
<ul>
<li>setData()：设置数据key和value(必须是字符串)</li>
<li><p>getData()：获取数据，根据key值，获取对应的value</p>
</li>
<li><p>effectAllowed</p>
<ul>
<li>effectAllowed：设置光标样式(none,copy,copyLink,copyMove,link,linkMove,move,all和uninitialized)</li>
</ul>
</li>
<li>setDragImage<ul>
<li>三个参数：指定的元素，坐标X，坐标Y</li>
</ul>
</li>
<li>files<ul>
<li>获取外部拖拽的文件，返回一个fileList列表</li>
<li>filesList下有个type属性，返回文件的类型</li>
</ul>
</li>
</ul>
</li>
<li><p>FileReader(读取文件信息)</p>
<ul>
<li>readAsDataURL<ul>
<li>参数为要读取的文件对象，将文件读取为DataUrl</li>
</ul>
</li>
<li>onload<ul>
<li>当读取文件成功完成的时候触发此事件</li>
<li>this.result，来获取读取的文件数据，如果是图片，将返回base64格式的图片数据</li>
</ul>
</li>
<li>实例<ul>
<li>拖拽删除列表</li>
<li>拖拽购物车</li>
<li>上传图片预览功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p> 标签</p>
<pre><code>&lt;canvas&gt;
不支持canvas的浏览器可以看到的内容
&lt;/canvas
</code></pre><ul>
<li><p>绘制环境</p>
<ul>
<li>getContext(‘2d’)：目前支持2d的场景</li>
</ul>
</li>
<li><p>绘制方块</p>
<ul>
<li>fillRect(L,T,W,H)：默认颜色是黑色</li>
<li>strokeRect(L,T,W,H)：带边框的方块<ul>
<li>默认一像素黑色边框，显示出来的不一样原因</li>
</ul>
</li>
</ul>
</li>
<li><p>设置绘图</p>
<ul>
<li>fillStyle：填充颜色(绘制canvas是有顺序的)</li>
<li>lineWidth：线宽度，是一个数值</li>
<li>strokeStyle：边线颜色</li>
</ul>
</li>
<li><p>边界绘制</p>
<ul>
<li>lineJoin：边界连接点样式<ul>
<li>miter(默认)、round(圆角)、bevel(斜角)</li>
</ul>
</li>
<li>lineCap：端点样式<ul>
<li>butt(默认)、round(圆角)、square(高度多出为宽一半的值)</li>
</ul>
</li>
</ul>
</li>
<li><p>绘制路径</p>
<ul>
<li>beginPath：开始绘制路径</li>
<li>closePath：结束绘制路径</li>
<li>moveTo：移动到绘制的新目标点</li>
<li>lineTo：新的目标点</li>
</ul>
</li>
<li><p>绘制路径_2</p>
<ul>
<li>stroke：画线，默认黑色</li>
<li>fill：填充，默认黑色</li>
<li>rect：矩形区域</li>
<li>clearRect：删除一个画布的矩形区域</li>
<li>save：保存路径</li>
<li>restore：恢复路径</li>
<li>小例子1：鼠标画线</li>
<li>小例子2：方块移动</li>
</ul>
</li>
<li><p>绘制圆</p>
<ul>
<li>arc(x,y,起始弧度,结束弧度,旋转方向)<ul>
<li>x,y：起始位置</li>
<li>弧度与角度的关系：弧度 = 角度*Math.PI/180</li>
<li>旋转方向：顺时针(默认：false)、逆时针(true)</li>
<li>例子：用arc去画个钟表</li>
</ul>
</li>
</ul>
</li>
<li><p>绘制其他曲线</p>
<ul>
<li>arcTo(x1,y1,x2,y2,r)<ul>
<li>第一组坐标、第二组坐标、半径</li>
</ul>
</li>
<li>guadraticCurveTo(x,dy,x1,y1)<ul>
<li>贝塞尔曲线：第一组控制点、第二组结束坐标</li>
</ul>
</li>
<li>bezierCurveTo(dx1,dy1,dx2,dy2,x1,y1)<ul>
<li>贝塞尔曲线：第一组控制点、第二组控制点、第三组结束坐标</li>
</ul>
</li>
</ul>
</li>
<li><p>变换</p>
<ul>
<li>translate<ul>
<li>偏移：从起始点为基准点，移动当前坐标位置</li>
</ul>
</li>
<li>rotate<ul>
<li>旋转：参数为弧度</li>
<li>例子：旋转的小方块</li>
</ul>
</li>
<li>scale<ul>
<li>缩放例子：旋转加缩放的小方块</li>
</ul>
</li>
</ul>
</li>
<li><p>插入图片</p>
<ul>
<li>等图片加载完，再执行canvas操作<ul>
<li>图片预加载：在onload中调用方法</li>
</ul>
</li>
<li>drawImage(oImg,x,y,w,h)<ul>
<li>oImg：当前图片x,y：坐标、w,h：宽高</li>
<li>例子：微博的图片旋转效果</li>
</ul>
</li>
</ul>
</li>
<li><p>设置背景</p>
<ul>
<li>createPattern(oImg,平铺方式)<ul>
<li>2参为：repeat、repeat-x、repeat-y、no-repeat</li>
</ul>
</li>
</ul>
</li>
<li><p>渐变</p>
<ul>
<li>createLinearGradient(x1,y1,x2,y2)<ul>
<li>线性渐变；</li>
<li>第一组参数：起始点坐标、第二组参数：结束点坐标</li>
<li>addColorStop(位置，颜色)添加渐变点</li>
</ul>
</li>
<li>createEadialGradient(x1,y1,r1,x2,y2,r2)<ul>
<li>放射性渐变；</li>
<li>参数：第一个圆的坐标，第二个圆的坐标和半径</li>
</ul>
</li>
</ul>
</li>
<li><p>文本</p>
<ul>
<li>strokeText(文字，x，y)<ul>
<li>文本边框</li>
</ul>
</li>
<li>fillText(文字,x,y)<ul>
<li>文字填充</li>
</ul>
</li>
<li>font<ul>
<li>文字大小：’60pximpact’</li>
</ul>
</li>
<li>textAlign<ul>
<li>默认是start跟left一样的效果end right center</li>
</ul>
</li>
<li>textBaseline<ul>
<li>文字上下的位置的方式默认：alphabetic</li>
</ul>
</li>
</ul>
</li>
<li><p>文本_2</p>
<ul>
<li>measureText()<ul>
<li>measureText(str).width：只有宽度，没有高度</li>
<li>例子：文字居中</li>
</ul>
</li>
</ul>
</li>
<li><p>阴影</p>
<ul>
<li>shadowOffsetX、shadowOffsetY<ul>
<li>X轴偏移、Y轴偏移</li>
</ul>
</li>
<li>shadowBlur<ul>
<li>高斯模糊值</li>
</ul>
</li>
<li>shadowColor<ul>
<li>阴影颜色</li>
</ul>
</li>
</ul>
</li>
<li><p>像素</p>
<ul>
<li>getImageData(x,y,w,h)<ul>
<li>获取图像数据</li>
</ul>
</li>
<li>putImageData(获取图像,x,y)<ul>
<li>设置新的图像数据</li>
</ul>
</li>
<li>属性<ul>
<li>width：一行的像素个数</li>
<li>Height：一列的像素个数</li>
<li>data：一个数组，包含每个像素的rgba四个值，注意每个值都在0~255之间的整数</li>
</ul>
</li>
</ul>
</li>
<li><p>像素_2</p>
<ul>
<li>createImageData(w,h)<ul>
<li>生成新的像素矩阵，初始值是全透明的黑色，即(0,0,0,0)</li>
<li>像素显字</li>
</ul>
</li>
<li>获取和设置指定坐标<ul>
<li>封装：getXY、setXY</li>
</ul>
</li>
<li>图片的像素操作<ul>
<li>必须是同源下</li>
<li>例子：反色、倒影、渐变等</li>
<li>例子：马赛克效果</li>
</ul>
</li>
</ul>
</li>
<li>合成<ul>
<li>全局阿尔法值<ul>
<li>globalAlpha</li>
</ul>
</li>
<li>覆盖合成<ul>
<li>源：新的图形</li>
<li>目标：已经绘制过的图形</li>
<li>globalCompositeOperation属性<ul>
<li>source-over  destination-over source-atop</li>
<li>destination-stop source-in destination-in</li>
<li>source-out destnation-out lighter</li>
<li>copy xor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>将画布导出为图像<ul>
<li>toDataURL<ul>
<li>火狐右键可以直接导出成图片</li>
</ul>
</li>
</ul>
</li>
<li>事件操作<ul>
<li>isPointInPath<ul>
<li>是否在点击范围内</li>
<li>jCanvaScript(canvas中的jquery):<ul>
<li><a href="http://jcscript.com/" target="_blank" rel="noopener">http://jcscript.com/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="跨文档消息通信"><a href="#跨文档消息通信" class="headerlink" title="跨文档消息通信"></a>跨文档消息通信</h2><p><strong>准备工作和同域下的窗口通信</strong></p>
<ul>
<li>postMessage对象<ul>
<li>接收消息的窗口对象.postMessage</li>
<li>一参：发送的数据，二参：接收的域</li>
<li>交互方式<ul>
<li>iframe：父页面：contentWindow、子页面：window.top</li>
<li>窗口页：父页面：window.open、子页面：window.opener</li>
</ul>
</li>
<li>接收事件<ul>
<li>message</li>
<li>ev.origin：发送数据来源的域</li>
<li>ev.data：发送的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>说明：postMessage：通过这个方法给另外一个窗口发送信息</p>
<p>说明2：iframe子页面操作父页面</p>
<pre><code>// parent =&gt; window 如果当前页面是顶级，没有被其他页面所包
含，那么parent就是当前页面的window对象，那么如果被包含了，则
parent就是包含当前页面的父级页面的window对象

window：当前窗口
parent：父级窗口
top：顶级窗口
</code></pre><p><strong>ajax跨域的问题和处理</strong></p>
<ul>
<li>XMLHttpRequest Level 2<ul>
<li>XMLHttpRequest改进版<ul>
<li>请求页面与数据页面必须属性不同的域</li>
<li>服务器要设置响应头信息</li>
<li>Origin值展现</li>
<li>IE：XDomainRequest</li>
<li>新的事件：onload等</li>
<li><a href="http://www.w3.org/TR/XMLHttpRequest2" target="_blank" rel="noopener">http://www.w3.org/TR/XMLHttpRequest2</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/cc288060(VS.85).aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/cc288060(VS.85).aspx</a></li>
</ul>
</li>
<li>进度事件<ul>
<li>upload.onprogress：上传</li>
<li>FormData对象</li>
<li>ev.total(已发送的总量)、ev.loaded(待发送的总量)</li>
<li>onprogress：下载</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>说明：在标准浏览器下，XMLHttpRequet对象已经是升级版本，支持了更多的特性，可以跨域了，但是，如果想实现跨域请求，还需要后端的相关配合才可以 </p>
<p><strong>ajax无刷新上传</strong></p>
<p>说明：我们是要通过ajax把oMyFile.files[0]数据发送给后端</p>
<p><strong>nodejs的安装搭建和一个简单http服务器的实现</strong></p>
<p><strong>websocket</strong></p>
<ul>
<li><p>互联网协议</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></li>
<li>TCP/IP协议<ul>
<li>定义了电子设备如何连入因特网，以及数据在它们之间传输的标准(如何传输)</li>
<li>传输数据(协议)类型：Email，www，FTP等</li>
<li>HTTP协议<ul>
<li>浏览器和万维网服务器之间相互通信的规则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议特点</p>
<ul>
<li>功能很强大</li>
<li>采用请求、响应模式，单项通信</li>
<li>短连接，响应完成连接就断开</li>
</ul>
</li>
<li><p>实时web交互</p>
<ul>
<li>股票、聊天室、网游等应用</li>
<li>如果实现实时应用？服务器推送</li>
</ul>
</li>
<li><p>什么是web socket？</p>
<ul>
<li>基于TCP的双向的、全双工的数据连接<ul>
<li>双向的：客户端、服务器端</li>
<li>全双工：数据的发送与接收，两者同步进行</li>
</ul>
</li>
<li>建立socket应用？<ul>
<li>服务器必须支持web socket.</li>
<li>Nodejs的简介<ul>
<li>Ryan Dahl基于GoogleV8引擎创建的一套用来编写高性能网络服务器的JavaScript工具包</li>
</ul>
</li>
<li>Nodejs：用js去写服务器应用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>nodejs-websocket服务器的创建和应用</strong></p>
<ul>
<li>Node.js<ul>
<li>安装node.js</li>
<li>转到项目目录</li>
<li>运行node scriptname.js</li>
<li>http服务器的创建</li>
<li>安装websocket模块npm install socket.io</li>
<li>websocket服务的创建</li>
</ul>
</li>
</ul>
<p><strong>HTML5之离线存储</strong></p>
<p><strong>applicationCache</strong></p>
<ul>
<li><p>离线应用是什么？</p>
<ul>
<li>乘坐飞机、手机信号弱、去演讲的时候，可能没有网络，这个时候就可以采用离线应用。</li>
<li>离线存储如何工作的？</li>
</ul>
</li>
<li><p>离线存储的好处？</p>
<ul>
<li>没网的时候，可以正常访问</li>
<li>快速响应页面，不必用多个HTTP占用资源带宽</li>
<li>缓存的可以是任何文件</li>
</ul>
</li>
<li><p>搭建离线应用程序</p>
<ol>
<li>服务器设置头信息：<ul>
<li>AddType text/cache-manifest.manifest</li>
</ul>
</li>
<li><p>html标签加：</p>
<ul>
<li>manifest=”xxxxx.manifest”</li>
</ul>
</li>
<li><p>写manifest文件：离线的清单列表</p>
<ul>
<li>先写：CACHE MANIFEST</li>
<li>FALLBACK:第一个网络地址没获取到，就走第二个缓存的</li>
<li>NWTWORK：无论缓存中存在与否，均从网络获取</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="HTML5之workers"><a href="#HTML5之workers" class="headerlink" title="HTML5之workers"></a>HTML5之workers</h2><p><strong>Web Workers</strong></p>
<ul>
<li><p>什么是worker？</p>
<ul>
<li>JS的单线程(放入UI队列的个数，利用定时器解决)</li>
<li>可以让web应用程序具备后台处理能力，对多线程的支持非常好。</li>
</ul>
</li>
<li><p>Worker API</p>
<ul>
<li>new Worker(‘后台处理的JS地址’)</li>
<li>利用postMessage传输数据</li>
<li>importScript(‘导入其他JS文件’)</li>
</ul>
</li>
<li><p>Worker运行环境</p>
<ul>
<li>navigator：appName、appVersion、userAgent、platform</li>
<li>location：所有属性都是只读的</li>
<li>self：指向全局worker对象</li>
<li>所有的ECMA对象，Object、Array、Date等</li>
<li>XMLHttpRequest构造器</li>
<li>setTimeout和setInterval方法</li>
<li>close()方法，立即停止worker方法</li>
<li>importScripts方法</li>
</ul>
</li>
</ul>
<h2 id="HTML5之一些小功能"><a href="#HTML5之一些小功能" class="headerlink" title="HTML5之一些小功能"></a>HTML5之一些小功能</h2><p><strong>HTML5其他功能</strong></p>
<ul>
<li><p>内容编辑</p>
<ul>
<li>contenteditable=”true”</li>
</ul>
</li>
<li><p>语言输入</p>
<ul>
<li><input type="text" x-webkit-speech="">
</li>
</ul>
</li>
<li><p>桌面提醒</p>
<ul>
<li>window.webkitNotifications.requestPermission();</li>
<li>statue=window.webkitNotifications.checkPermission();</li>
<li>var notification = window.webkitNotifications.createNotification(“[imgurl]”,”Title”,”Body”);</li>
<li>notification.show();</li>
</ul>
</li>
</ul>
<h2 id="html5播放器"><a href="#html5播放器" class="headerlink" title="html5播放器"></a>html5播放器</h2><p><strong>音频和视频</strong></p>
<ul>
<li><p>标签</p>
<ul>
<li>audio、video</li>
<li>source</li>
</ul>
</li>
<li><p>视频容器</p>
<ul>
<li>容器文件，类似于压缩了一组文件<ul>
<li>音频轨道</li>
<li>视频轨道</li>
<li>元数据：封面，标题，字幕等</li>
<li>格式：.avi、.flv、.mp4、.mkv、.ogv等</li>
</ul>
</li>
</ul>
</li>
<li><p>媒体元素</p>
<ul>
<li>controls：显示或隐藏用户控制界面</li>
<li>autoplay：媒体是否自动播放</li>
<li>loop：媒体是否循环播放</li>
<li>currentTime：开始到播放现在所用的时间</li>
<li>duration：媒体总时间(只读)</li>
<li>volume：0.0-1.0得到音量相对值</li>
<li>muted：是否静音</li>
<li>autobuffer：开始的时候是否缓冲加载，autoplay的时候，忽略此属性</li>
</ul>
</li>
<li><p>编解码器</p>
<ul>
<li>原始的视频容器非常大，添加需编码，播放需解码</li>
<li>音频编解码器<ul>
<li>AAC、MPEG-3、OggVorbis</li>
</ul>
</li>
<li>视频编解码器<ul>
<li>H.264、VP8、OggTheora</li>
</ul>
</li>
</ul>
</li>
<li><p>媒体元素_2</p>
<ul>
<li>paused：媒体是否暂停(只读)</li>
<li>ended：媒体是否播放完毕(只读)</li>
<li>error：媒体发生错误的时候，返回错误代码(只读)</li>
<li><p>currentSrc：以字符串的形式返回媒体地址(只读)</p>
</li>
<li><p>play()：媒体播放</p>
</li>
<li>pause()：媒体暂停</li>
<li>load()：重新加载媒体</li>
</ul>
</li>
<li><p>媒体元素_3</p>
<ul>
<li>loadstart progress suspend emptied stalled play pause loadedmetadata loadeddata waiting playing canplay canpalythrough seeking eeked timeupdate ended ratechange durationchange volumechange</li>
</ul>
</li>
<li><p>Video额外特性</p>
<ul>
<li>poster：视频播放前的预览图片</li>
<li>width、height：设置视频的尺寸</li>
<li><p>videoWidth、 videoHeight：视频的实际尺寸(只读)</p>
</li>
<li><p>例子：带声音的导航</p>
</li>
<li>例子：视频与canvas结合</li>
<li>例子：自制播放器</li>
<li><a href="http://www.alloyteam.com/wp-content/uploads/2012/03/playdemo/index.html" target="_blank" rel="noopener">http://www.alloyteam.com/wp-content/uploads/2012/03/playdemo/index.html</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangXiaofei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangXiaofei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
