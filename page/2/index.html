<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/白话js-this指向问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/白话js-this指向问题/" itemprop="url">白话js_this指向问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:41:46+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="白话js-this指向问题"><a href="#白话js-this指向问题" class="headerlink" title="白话js this指向问题"></a>白话js this指向问题</h2><p><strong>前言</strong></p>
<p>通过本文，你大概能了解this基础指向的问题，抛开例子去说this太虚幻，这里还是结合几篇博文做个整理，算是个人的记录了。</p>
<p>先说概念，this指向与申明无关，永远指向距离自己<strong>最近的最终调用者</strong>。我们从几种调用情况去理解，下面看看例子理解下：</p>
<p><strong>1.函数的直接调用</strong></p>
<pre><code>function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //undefined
    console.log(this); // window
}
a();
</code></pre><p>如上，我们申明一个函数，然后直接调用，a()前面没任何调用它的对象，这时候我们一般理解为被全局window对象调用，那我们就得去window去找age属性，很明显window没有，这里输出undefined。</p>
<p>我们改改代码，用window去调用函数a，同时定义a的age属性，如下：</p>
<pre><code>window.age = &apos;26&apos;;
function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //26
    console.log(this);//window
}
window.a();
</code></pre><p>那我们可以这样理解，<strong>针对函数调用</strong>，我们在一个函数内申明this，我们去看它最终是被谁调用，如果最终的调用前啥都没有，this就会指向window，这里只是针对js非严格模式。</p>
<pre><code>function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //undefined
    console.log(this); //window
}
function b() {
    a();
}
b();
</code></pre><p>你以为我说到这，函数调用的this问题就说完了？不存在的，死记硬背难啊，情况多变，<strong>为什么函数直接调用，前面啥都没有就指向window，为什么？</strong></p>
<p><strong>我再知乎看到一篇从函数调用原理讲this的文章，这里就引入下，</strong></p>
<p>函数一般常见三种调用方式，其实对于我是两种</p>
<p><strong>1.func(a,b)</strong> — 普通函数调用</p>
<p><strong>2.obj.child.method(context,a,b)</strong> — 调用对象内的某个方法，这个方法相当于对象的子属性</p>
<p><strong>3.func.call(context,a,b)</strong> — 这个我确实在调用中没怎么用过。</p>
<p>对于前两种，普通调用，对象属性的函数调用我们都常见，而第三种其实才是我们原本函数该有的调用，那我们这个this的讲解就偏偏与第三种有关系了。我们将前两者改写为第三种调用。</p>
<pre><code>func(a,b) ==&gt; func.call(undefined,a,b)
obj.child.method ==&gt; obj.child.method.call(obj.child,a,b)
//因为不确定obj里面的method是属于obj的属性还是obj child的属
性，再加个
obj.method ==&gt; obj.method.call(obj,a,b)
</code></pre><p>那我们就可以将所有的函数调用统一为 <strong>func.call(context,a,b)这一种</strong>，<strong>如果不是这一种，按照上面去改写，**</strong>其中context就是我们一直苦苦寻找的this**.</p>
<p>OK,上面是函数的普通调用，咱们来改写上面的例子。</p>
<pre><code>function a() {
    var age = &apos;25&apos;;
    console.log(this.age); //undefined
    console.log(this); // window
}
a(); //等价于a.call(undefined);
</code></pre><p>那按照我们上面说的，this应该是undefined啊，为毛是Window，这里又插入一个小规则</p>
<p><strong>如果你传的context为null或者undefined，那么window对象就是默认的context（严格模式下默认context是undefined）</strong></p>
<p>那这里我们就明白为啥普通函数直接调用，this指向window了。</p>
<p><strong>2.函数作为对象属性方法被调用</strong></p>
<p>怎么去解释，我们还是用上面函数调用的改写去理解，先看一个例子。</p>
<pre><code>var a = {
    age: &quot;29&quot;,
    fn:function() {
        console.log(this.age); // 29
    }
}
a.fn(); //等价于a.fn.call(a)
//参照obj.method ==&gt; obj.method.call(obj,a,b)来看
</code></pre><p>method fn是对象a的一个属性，照着上面的对等公式，最终this指向就是对象a自己，也验证了上面我们说的，this指向它最终的调用者。</p>
<p>再来看一个例子：</p>
<pre><code>var a = {
    age: 10,
    func:{
        age:12,
        fn:function() {
            console.log(this.age); //12
        }
    }
}
a.func.fn(); //等价于 a.method.fn.call(a.method)    
// 参照obj.child.method ==&gt; obj.child.method.call
(obj.child,a,b)来看
</code></pre><p>func是对象a的一个child属性，而方法fn包含在func内，所以参照这个例子，this指向了a.func，而a.func提供了age属性，这里就输出12了，问题不大吧？</p>
<p>那我们现在来融合函数调用与对象调用来看个例子：</p>
<pre><code>var a = {
    age: 10,
    func: {
        age: 12,
        fn: function() {
            console.log(this.age); // undefined
            console.log(this); // window
        }
    }
}
var j = a.func.fn;
j(); // 等价于window.j()或者j.call(undefined)
</code></pre><p>跟我读，this指向最终，且离自己最近的调用者，最终调用的是方法j()，按照改写说的通，按照我们说的方法前面啥都没有就是window也说的通，就是这个意思了。</p>
<h2 id="3-构造函数的调用"><a href="#3-构造函数的调用" class="headerlink" title="3.构造函数的调用"></a>3.构造函数的调用</h2><p>我们先来看个例子，当我们输出a.user，this指向了谁？</p>
<pre><code>function Fn() {
    this.age = 25;
}
var a = new Fn();
console.log(a.age); //25
</code></pre><p>先明白this指向谁，我们要弄懂什么是构造函数，new干嘛了？var a = new Fn()干嘛了？</p>
<p>构造函数就是初始化一个实例对象，当我们new Fn()其实就是将Fn()复制了一份，并作为对象返回，赋值给了变量a。</p>
<p>我们可以console a，得到的就是Fn()函数的实例，而且继承了Fn里面的age属性，所以此时this指向a，a里面有age属性。</p>
<p>我们来白话一遍，这样说，当我们用构造函数方法，this指向我们new出来返回的对象，就是复制Fn得到了一个Fn副本，this指向了Fn副本，而这个Fn副本被赋予给了变量a，于是this指向了a，这个Fn副本继承了原函数的属性，所以这里顺利的输出了25.(并不是复制了整个函数，这句话有问题，我暂时不理解)</p>
<h2 id="构造函数与return"><a href="#构造函数与return" class="headerlink" title="构造函数与return"></a>构造函数与return</h2><p><strong>我在上面说，构造函数this会指向new之后的实例（复制出来的副本），但如果在函数里有return，this指向可能会发生变化。</strong></p>
<pre><code>function Fn() {
    this.age = 17;
    return {age:18};
}
var a = new Fn();
console.log(a); // {age:18}
console.log(a.age); //18
</code></pre><p>很明显，return的对象赋值给了变量a，这里输出了18.再来看看这段代码：</p>
<pre><code>function Fn() {
    this.age = &apos;25&apos;;
    return function() {};
}
var a = new Fn();
console.log(a.age); // undefined
</code></pre><p>再来一段代码：</p>
<pre><code>function Fn() {
    this.age = 11;
    return 1;
}
var a = new Fn();
console.log(a.age); //11
</code></pre><p>我们可以做个大致判断，当在构造函数中return 一个对象时，this会指向这个对象，如上面的第一，第二段代码，但如果return的不是一个对象，那就不会改变this指向，还是指向new出来的实例。</p>
<p><strong>构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕后，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/安全限制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/安全限制/" itemprop="url">安全限制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:41:10+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h2><p>Ajax请求的URL使用的是相对路径。如果你把它改为’<a href="http://www.sina.com.cn/&#39;，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。" target="_blank" rel="noopener">http://www.sina.com.cn/&#39;，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。</a></p>
<p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</p>
<p>完全一致的意思是，域名要相同(<a href="http://www.example.com和example.com不同)，协议要相同(http和https不同)，端口号要相同(默认是:80端口，它和:8080就不同)。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。" target="_blank" rel="noopener">www.example.com和example.com不同)，协议要相同(http和https不同)，端口号要相同(默认是:80端口，它和:8080就不同)。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</a></p>
<p>那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有那么几种：</p>
<p>一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须跟安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</p>
<p>二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：</p>
<pre><code>&apos;/proxy?url=http://www.sina.com.cn&apos;
</code></pre><p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式的麻烦之处在于需要服务器端额外做开发。</p>
<p>第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;script src=&quot;http://example.com/abc.js&quot;&gt;&lt;/script&gt;
    ...
&lt;/head&gt;
&lt;body&gt;
...
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：</p>
<pre><code>foo(&apos;data&apos;);
</code></pre><p>这样一来，我们如果在页面中先准备好foo()函数，然后给页面动态加一个<script>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。</p>
<p>以163的股票查询URL为例，对于URL：<a href="http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回：">http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回：</a></p>
<pre><code>refreshPrice({&quot;0000001&quot;: {&quot;code&quot;: &quot;0000001&quot;, ...});
</code></pre><p>因此我们需要首先在页面中准备好回调函数：</p>
<pre><code>function refreshPrice(data) {
    var p = document.getElementById(&apos;test-jsonp&apos;);
    p.innerHTML = &apos;当前价格：&apos; + 
        data[&apos;0000001&apos;].name + &apos;:&apos; +
        data[&apos;0000001&apos;].price + &apos;;&apos; +
        data[&apos;1399001&apos;].name + &apos;:&apos; +
        data[&apos;1399001&apos;].price;
}
</code></pre><p>最后用getPrice()函数触发：<br>    function getPrice() {<br>        var js = document.createElement(‘script’),<br>            head = document.getElementByTagName(‘head’)[0];<br>        js.src = ‘<a href="http://api.money.126.net/data/">http://api.money.126.net/data/</a><br>        feed/0000001,139901?callback=refereshPrice’;<br>        head.appendChild(js);<br>    }</p>
<p>就完成了跨域加载数据。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<p>了解CORS前，我们先搞明白概念：</p>
<p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p>
<p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00143640805071744d58164a40e42ef92b9973824451595000/l" alt=""></p>
<p>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为<a href="http://my.com，或者是*，本次请求就可以成功。">http://my.com，或者是*，本次请求就可以成功。</a></p>
<p>可见，跨域是否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手里。</p>
<p>上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型仅限application/x-www-form-urlencoded、 multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom：12345），通常能满足90%的需求。</p>
<p>无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了第三方CDN上的字体文件时：</p>
<pre><code>/* CSS */
@font-face {
    font-family: &apos;FontAwesome&apos;;
    src: url(&apos;http://cdn.com/fonts/fontawesome.ttf&apos;)
    format(&apos;truetype&apos;);
}
</code></pre><p>如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。</p>
<p>对于PUT、DELETE以及其他类型如application/json的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>
<pre><code>OPTIONS /path/to/resource HTTP/1.1
Host: bar.com
Origin: http://my.com
Access-Control-Request-Method: POST
</code></pre><p>服务器必须响应并明确指出允许的Method：</p>
<pre><code>HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
Access-Control-Max-Age: 86400
</code></pre><p>浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>
<p>由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。</p>
</script></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/XMLHttpRequest杂记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/XMLHttpRequest杂记/" itemprop="url">XMLHttpRequest杂记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:40:34+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Server-sent events</strong></p>
<p>一个网页获取新的数据通常需要发送一个请求到服务器，也就是向服务器请求的页面。使用server-sent事件的方法，服务器可以在任何时刻向我们的web页面推送数据和信息。这些被推送进来的信息可以在这个页面上作为事件+data来处理。</p>
<h1 id="Using-XMLHttpRequest"><a href="#Using-XMLHttpRequest" class="headerlink" title="Using XMLHttpRequest"></a><strong>Using XMLHttpRequest</strong></h1><p>XMLHttpRequest让发送一个HTTP请求变得非常容易。你只需要简单的创建一个请求对象实例，打开一个URL，然后发送这个请求。当传输完毕后，结果的HTTP状态以及返回的响应内容也可以从请求对象中获取。</p>
<p><strong>请求类型</strong></p>
<p>通过XMLHttpRequest生成的请求可以有两种方式来获取数据，异步模式或同步模式。请求的类型是由这个XMLHttpRequest对象的open()方法的第三个参数async的值决定的。如果该参数的值为false，则该XMLHttpRequest请求以同步模式进行，否则该过程将以异步模式完成。</p>
<p><strong>处理响应</strong></p>
<p>W3C规范定义了XMLHttpRequest对象的几种类型的响应属性。这些属性告诉客户端关于XMLHttpRequest返回状态的重要信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Web前端开发最佳实践学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Web前端开发最佳实践学习笔记/" itemprop="url">Web前端开发最佳实践学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:40:00+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JavaScript是一种基于对象和事件驱动的客户端脚本语言，是页面实时动态交互的技术基础。"><a href="#JavaScript是一种基于对象和事件驱动的客户端脚本语言，是页面实时动态交互的技术基础。" class="headerlink" title="JavaScript是一种基于对象和事件驱动的客户端脚本语言，是页面实时动态交互的技术基础。"></a>JavaScript是一种基于对象和事件驱动的客户端脚本语言，是页面实时动态交互的技术基础。</h3><h5 id="JavaScript是非常灵活的脚本语言，包含了高阶函数、动态类型以及灵活的对象模型等强大的语言特性，当然，JavaScript的灵活性也可能导致代码不易维护。此外，浏览器的兼容性也增加了JavaScript编码的难度。同一个功能，可能在不同的浏览器中有不同的实现。例如，在IE浏览器中，事件绑定使用的是attachEvent-方法，但其他浏览器则使用的是addEventListener-方法。"><a href="#JavaScript是非常灵活的脚本语言，包含了高阶函数、动态类型以及灵活的对象模型等强大的语言特性，当然，JavaScript的灵活性也可能导致代码不易维护。此外，浏览器的兼容性也增加了JavaScript编码的难度。同一个功能，可能在不同的浏览器中有不同的实现。例如，在IE浏览器中，事件绑定使用的是attachEvent-方法，但其他浏览器则使用的是addEventListener-方法。" class="headerlink" title="JavaScript是非常灵活的脚本语言，包含了高阶函数、动态类型以及灵活的对象模型等强大的语言特性，当然，JavaScript的灵活性也可能导致代码不易维护。此外，浏览器的兼容性也增加了JavaScript编码的难度。同一个功能，可能在不同的浏览器中有不同的实现。例如，在IE浏览器中，事件绑定使用的是attachEvent()方法，但其他浏览器则使用的是addEventListener()方法。"></a>JavaScript是非常灵活的脚本语言，包含了高阶函数、动态类型以及灵活的对象模型等强大的语言特性，当然，JavaScript的灵活性也可能导致代码不易维护。此外，浏览器的兼容性也增加了JavaScript编码的难度。同一个功能，可能在不同的浏览器中有不同的实现。例如，在IE浏览器中，事件绑定使用的是attachEvent()方法，但其他浏览器则使用的是addEventListener()方法。</h5><h5 id="W3C制定的标准包括使用语言的规范、开发中使用的原则和解释引擎行为等，主要由3个部分组成：结构（Structure）标准、表现（Presentation-标准和行为（Behavior-标准。结构标准包括XML标准、XHTML标准和HTML标准，目前使用的标准版是HTML-4-01标准，HTML5是HTML和XHTML的最新标准，还没有发布最终版；表现标准主要指的是CSS样式标准，行为标准主要包括ECMAScript标准和DOM标准。ECMAScript是ECMA（European-Computer-Manufacturers-Assocation）制定的标准脚本语言（JavaScript）。DOM是文档对象模型（Document-Object-Model）的缩写，是一个中立于语言的应用程序接口，允许程序访问并更改页面的内容、结构和样式。"><a href="#W3C制定的标准包括使用语言的规范、开发中使用的原则和解释引擎行为等，主要由3个部分组成：结构（Structure）标准、表现（Presentation-标准和行为（Behavior-标准。结构标准包括XML标准、XHTML标准和HTML标准，目前使用的标准版是HTML-4-01标准，HTML5是HTML和XHTML的最新标准，还没有发布最终版；表现标准主要指的是CSS样式标准，行为标准主要包括ECMAScript标准和DOM标准。ECMAScript是ECMA（European-Computer-Manufacturers-Assocation）制定的标准脚本语言（JavaScript）。DOM是文档对象模型（Document-Object-Model）的缩写，是一个中立于语言的应用程序接口，允许程序访问并更改页面的内容、结构和样式。" class="headerlink" title="W3C制定的标准包括使用语言的规范、开发中使用的原则和解释引擎行为等，主要由3个部分组成：结构（Structure）标准、表现（Presentation)标准和行为（Behavior)标准。结构标准包括XML标准、XHTML标准和HTML标准，目前使用的标准版是HTML 4.01标准，HTML5是HTML和XHTML的最新标准，还没有发布最终版；表现标准主要指的是CSS样式标准，行为标准主要包括ECMAScript标准和DOM标准。ECMAScript是ECMA（European Computer Manufacturers Assocation）制定的标准脚本语言（JavaScript）。DOM是文档对象模型（Document Object Model）的缩写，是一个中立于语言的应用程序接口，允许程序访问并更改页面的内容、结构和样式。"></a>W3C制定的标准包括使用语言的规范、开发中使用的原则和解释引擎行为等，主要由3个部分组成：结构（Structure）标准、表现（Presentation)标准和行为（Behavior)标准。结构标准包括XML标准、XHTML标准和HTML标准，目前使用的标准版是HTML 4.01标准，HTML5是HTML和XHTML的最新标准，还没有发布最终版；表现标准主要指的是CSS样式标准，行为标准主要包括ECMAScript标准和DOM标准。ECMAScript是ECMA（European Computer Manufacturers Assocation）制定的标准脚本语言（JavaScript）。DOM是文档对象模型（Document Object Model）的缩写，是一个中立于语言的应用程序接口，允许程序访问并更改页面的内容、结构和样式。</h5><h5 id="head部分还会包含一些必要的meta标签是对HTML文档内容的描述，用来表明文档的编码、关键字、介绍、作者等信息。"><a href="#head部分还会包含一些必要的meta标签是对HTML文档内容的描述，用来表明文档的编码、关键字、介绍、作者等信息。" class="headerlink" title="head部分还会包含一些必要的meta标签是对HTML文档内容的描述，用来表明文档的编码、关键字、介绍、作者等信息。"></a>head部分还会包含一些必要的meta标签是对HTML文档内容的描述，用来表明文档的编码、关键字、介绍、作者等信息。</h5><p>示例代码：</p>
<ul>
<li><code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, web&quot; /&gt;</code></li>
<li><code>&lt;meta name=&quot;description&quot; content=&quot;一个展示HTML页面的例子&quot; /&gt;</code></li>
</ul>
<h5 id="HTML元素的内容模型定义了元素的结构，表明元素可以包含哪些内容以及元素可以有哪些属性。元素可以包含的内容包含其他元素和字符，但是也有一些元素是空元素，即不能包含任何内容，这些元素对应的HTML标签也称为自闭和标签，下面列出了HTML中所有的自闭和标签：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr"><a href="#HTML元素的内容模型定义了元素的结构，表明元素可以包含哪些内容以及元素可以有哪些属性。元素可以包含的内容包含其他元素和字符，但是也有一些元素是空元素，即不能包含任何内容，这些元素对应的HTML标签也称为自闭和标签，下面列出了HTML中所有的自闭和标签：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr" class="headerlink" title="HTML元素的内容模型定义了元素的结构，表明元素可以包含哪些内容以及元素可以有哪些属性。元素可以包含的内容包含其他元素和字符，但是也有一些元素是空元素，即不能包含任何内容，这些元素对应的HTML标签也称为自闭和标签，下面列出了HTML中所有的自闭和标签：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr"></a>HTML元素的内容模型定义了元素的结构，表明元素可以包含哪些内容以及元素可以有哪些属性。元素可以包含的内容包含其他元素和字符，但是也有一些元素是空元素，即不能包含任何内容，这些元素对应的HTML标签也称为自闭和标签，下面列出了HTML中所有的自闭和标签：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</h5><h3 id="下面介绍一些常用的meta"><a href="#下面介绍一些常用的meta" class="headerlink" title="下面介绍一些常用的meta"></a>下面介绍一些常用的meta</h3><pre><code>(1)设置IE浏览器的兼容模式
从IE8浏览器开始支持一种设置页面兼容模式的meta类型，示例代码如下：
</code></pre><p><code>&lt;meta http-equiv=&quot;X-UA-Compatiable&quot; content=&quot;IE=8&quot;/&gt;</code></p>
<pre><code>(2)设置页面在移动设备中的显示
一般针对移动设备优化的网页都会添加如下一条meta设置，使得网页在移动设备中显示正常，设置的代码类似如下的代码语句：
</code></pre><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maxinum-scale=1&quot;/&gt;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Web安全-XSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Web安全-XSS/" itemprop="url">Web安全-XSS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:39:16+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解XSS的攻击方式"><a href="#理解XSS的攻击方式" class="headerlink" title="理解XSS的攻击方式"></a>理解XSS的攻击方式</h2><ol>
<li>反射型</li>
</ol>
<p>发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。</p>
<p>构建Node应用，演示反射型XSS攻击</p>
<ol start="2">
<li>存储型</li>
</ol>
<p>存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码</p>
<h2 id="掌握XSS的防御措施"><a href="#掌握XSS的防御措施" class="headerlink" title="掌握XSS的防御措施"></a>掌握XSS的防御措施</h2><p><strong>编码</strong></p>
<pre><code>对用户输入的数据进行HTML Entity编码

    字符                    十进制            转义字符

    &quot;                    &amp;#34;            &amp;quot;
    &amp;                    &amp;#38;            &amp;amp;
    &lt;                    &amp;#60;            &amp;lt;        
    &gt;                   &amp;#62;           &amp;gt;
不断开空格(non-breaking  &amp;#160;            &amp;nbsp;
space)
</code></pre><p><strong>过滤</strong></p>
<p>移除用户上传的DOM属性，如onerror等</p>
<p>移除用户上传的Style节点、Script节点、Iframe节点等</p>
<p><strong>校正</strong></p>
<p>避免直接对HTML Entity解码</p>
<p>使用DOM Parse转换，校正不配对的DOM标签</p>
<p><strong>实战</strong></p>
<p>通过构建Node服务和建立一个评论功能，实例演示XSS的攻击及防御</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Web-Worker使用教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Web-Worker使用教程/" itemprop="url">Web_Worker使用教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:38:39+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Web-Worker-使用教程"><a href="#Web-Worker-使用教程" class="headerlink" title="Web Worker 使用教程"></a>Web Worker 使用教程</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>JavaScript语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核CPU的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker的作用，就是为JavaScript创造多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行。在主线程运行的同时，Worker线程在后台运行，两者互不干扰。等到Worker线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被Worker线程负担了，主线程（通常负责UI交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了Worker比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p><strong>Web Worker有以下几个使用注意点。</strong></p>
<p>(1) 同源限制</p>
<p>分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>(2) DOM限制</p>
<p>Worker线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的DOM对象，也无法使用document、window、parent这些对象。但是，Worker线程可以navigator对象和location对象。</p>
<p>(3) 通信联系</p>
<p>Worker线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>(4) 脚本限制</p>
<p>Worker线程不能执行alert()方法和confirm()方法，但可以使用XMLHttpRequest对象发出AJAX请求。</p>
<p>(5) 文件限制</p>
<p>Worker线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>
<h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><p>2.1 主线程</p>
<p>主线程采用new命令，调用Worker()构造函数，新建一个Worker()线程。</p>
<pre><code>var worker = new Worker(&apos;work.js&apos;)
</code></pre><p>Worker()构造函数的参数是一个脚本文件，该文件就是Worker线程所要执行的任务。由于Worker不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker就会默默地失败。</p>
<p>然后，主线程调用worker.postMessage()方法，向Worker发消息。</p>
<pre><code>worker.postMessage(&apos;Hello World&apos;);
worker.postMessage({method: &apos;echo&apos;, args: [&apos;Work&apos;]});
</code></pre><p>worker.postMessage()方法的参数，就是主线程传给Worker的数据。它可以是各种数据类型，包括二进制数据。</p>
<p>接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。</p>
<pre><code>worker.onmessage = function(event) {
    console.log(&apos;Received message&apos; + event.data);
    doSomething();
}

function doSomething() {
    // 执行任务
    worker.postMessage(&apos;Work done!&apos;);
}
</code></pre><p>上面代码中，事件对象的data属性可以获取Worker发来的数据。</p>
<p>Worker完成任务以后，主线程就可以把它关掉。</p>
<pre><code>worker.terminate()
</code></pre><p>2.2 Worker线程</p>
<p>Worker线程内部需要有一个监听函数，监听message事件。</p>
<pre><code>self.addEventListener(&apos;message&apos;, function (e){
    self.postMessage(&apos;You said: &apos; + e.data);
}, false)
</code></pre><p>上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>
<pre><code>// 写法一
this.addEventListener(&apos;message&apos;, function (e){
    this.postMessage(&apos;You said：&apos; + e.data);
}, false);

// 写法二
addEventListener(&apos;message&apos;, function (e){
    postMessage(&apos;You said：&apos; + e.data);
}, false);
</code></pre><p>除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。</p>
<p>根据主线程发来的数据，Worker线程可以调用不同的方法，下面是一个例子。</p>
<pre><code>self.addEventListener(&apos;message&apos;, function(e){
    var data = e.data;
    switch (data.cmd) {
        case &apos;start&apos;:
            self.postMesage(&apos;WORKER START: &apos; + data.msg);
            break;
        case &apos;stop&apos;:
            self.postMessage(&apos;WORKER STOPPED: &apos; + data.msg);
            self.close(); // Terminate the worker.
            break;
        default:
            self.postMessage(&apos;Unknown command: &apos; + data.msg)
    };
}, false);
</code></pre><p>上面代码中，self.close()用于在Worker内部关闭自身。</p>
<p>2.3 Worker 加载脚本</p>
<p>Worker内部如果要加载其他脚本，有一个专门的方法importScripts()。</p>
<pre><code>importScripts(&apos;script1.js&apos;);
</code></pre><p>该方法可以同时加载多个脚本。</p>
<pre><code>importScripts(&apos;scripts1.js&apos;, &apos;sctipt2.js&apos;);
</code></pre><p>2.4 错误处理</p>
<p>主线程可以监听Worker是否发生错误。如果发生错误，Worker会触发主线程的error事件。</p>
<pre><code>worker.onerror(function (event) {
    console.log([
        &apos;ERROR: Line&apos;, e.lineno, &apos;in&apos;, e.filename, &apos;:&apos;, e.message
    ].join(&apos;&apos;));
});

// 或者
worker.addEventListener(&apos;error&apos;, function(event){
 // ...
})
</code></pre><p>Worker内部也可以监听error事件。</p>
<p>2.5 关闭Worker</p>
<p>使用完毕，为了节省系统资源，必须关闭    Worker。</p>
<pre><code>// 主线程
worker.terminate();

// Worker线程
self.close();
</code></pre><h2 id="三、数据通信"><a href="#三、数据通信" class="headerlink" title="三、数据通信"></a>三、数据通信</h2><p>前面说过，主线程与Worker之间的通信内容，可以是文本，也可以是对象。需要注意是是，这种通信是拷贝关系，即是传值而不是传址，Worker对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给Worker，后者再将它还原。</p>
<p>主线程与Worker之间也可以交换二进制数据，比如File、Blob、ArrayBuffer等类型，也可以在线程之间发送。下面是一个例子。</p>
<pre><code>// 主线程
var uInt8Array = new Unit8Array(new ArrayBuffer(10));
for (var i = 0; i &lt; uInt8Array.length; ++i) {
    uInt8Array[i] = i * 2; // [0,2,4,6,8,...]
}
worker.postMessage(uInt8Array);

// Worker 线程
self.onmessage = function(e){
    var uInt8Array = e.data;
    postMesage(&apos;Inside worker.js: uInt8Array.toString() =&apos; 
    + uInt8Array.toString());
    postMessage(&apos;Inside worker.js: uInt8Array.byteLength =
     &apos; + uInt8Array.byteLength);
}
</code></pre><p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向Worker发送一个500MB文件，默认情况下浏览器会生成一个原文件拷贝。为了解决这个问题，JavaScript允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给Worker，对于影像处理、声音处理、3D运算等就非常方便了，不会产生性能负担。</p>
<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>
<p>// Transferable Objects格式<br>worker.postMessage(arrayBuffer, [arrayBuffer]);</p>
<p>// 例子<br>var ab = new ArrayBuffer(1);<br>worker.postMessage(ab, [ab]);</p>
<h2 id="四、-同页面的Web-Worker"><a href="#四、-同页面的Web-Worker" class="headerlink" title="四、 同页面的Web Worker"></a>四、 同页面的Web Worker</h2><p>通常情况下，Worker载入的是一个单独的JavaScript脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>
<pre><code>&lt;!DOCTYPE html&gt;
  &lt;body&gt;
    &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt;
      addEventListener(&apos;message&apos;, function () {
        postMessage(&apos;some message&apos;);
      }, false);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>上面是一段嵌入网页的脚本，注意必须指定<scipt>标签的type属性是一个浏览器不认识的值，上例是app/worker。</scipt></p>
<p>然后，读取这一段嵌入页面的脚本，用Worker来处理。</p>
<pre><code>var blob = new Blob([document.querySelector(&apos;#worker&apos;).textContent]);
var url = window.URL.createObjectURL(blob);
var worker = new Worker(url);

worker.onmessage = function (e) {
    // e.data === &apos;some message&apos;
}
</code></pre><p>上面代码中，先将嵌入网页的脚本代码，转为一个二进制对象，然后为这个二进制对象生成URL，再让Worker加载这个URL。这样就做到了，主线程和Worker的代码都在同一个网页上面。</p>
<h2 id="五、-实例：Worker线程完成轮询"><a href="#五、-实例：Worker线程完成轮询" class="headerlink" title="五、 实例：Worker线程完成轮询"></a>五、 实例：Worker线程完成轮询</h2><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在Worker里面。</p>
<pre><code>function createWorker(f) {
    var blob = new Blob([&apos;(&apos; + f.toString() +&apos;)()&apos;]);
    var url = window.URL.createObjectURL(blob);
    var worker = new Worker(url);
    return worker;
}

var pollingWorker = createWorker(function(e){
    var cache;

    function compare(new , old) {...};

    setInterval(function(){
        fetch(&apos;/my-api-endpoint&apos;).then(function (res){
            var data = res.json();

            if (!compare(data, cache)){
                cache = data;
                self.postMessage(data);
            }
        })
    }, 1000)
})

pollingWorker.onmessage = function() {
    // render data
}

pollingWorker.postMessage(&apos;init&apos;);
</code></pre><p>上面代码中，Worker每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>
<h2 id="六、实例：Worker新建Worker"><a href="#六、实例：Worker新建Worker" class="headerlink" title="六、实例：Worker新建Worker"></a>六、实例：Worker新建Worker</h2><p>Worker线程内部还能再新建Worker线程（目前只有Firefox浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个Worker。</p>
<p>主线程代码如下。</p>
<pre><code>var worker = new Worker(&apos;worker.js&apos;);
worker.onmessage = function(event) {
    document.getElementById(&apos;result&apos;).textContent = event.data;
}
</code></pre><p>Worker线程代码如下。</p>
<pre><code>// worker.js

// settings
var num_workers = 10;
var items_per_worker = 1000000;

// start the workers
var result = 0;
var pending_workers = num_workers;
for (var i=0; i&lt; num_workers; i+=1) {
    var worker = new Worker(&apos;core.js&apos;);
    worker.postMessage(i * items_per_worker);
    worker.postMessage((i+1) * items_per_worker);
    worker.onmessage = storeResult;
}

// handle the results
function storeResult(event) {
    result += event.data;
    pending_workers -= 1;
    if(pending_workers &lt; =0){
        postMessage(result); // finished!
    }
}
</code></pre><p>上面代码中，Worker线程内部新建了10个Worker线程，并且依次向这10个Worker发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p>
<pre><code>// core.js
var start;
onmessage = getStart;
function getStart(event){
    start = event.data;
    onmessage = getEnd;
}

var end;
function getEnd(event){
    end = event.data;
    onmessage = null;
    work();
}

function work(){
    var result = 0;
    for (var i = start; i &lt; end; i+= 1) {
        // perform some complex calculation here
        result +=1;
    }
    postMessage(result);
    close();
}
</code></pre><h2 id="七、API"><a href="#七、API" class="headerlink" title="七、API"></a>七、API</h2><p>7.1 主线程</p>
<p>浏览器原生提供Worker()构造函数，用来供主线程生成Worker线程。</p>
<pre><code>var myWorker = new Worker(jsUrl, options);
</code></pre><p>Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载JS脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定Worker的名称，用来区分多个Worker线程。</p>
<pre><code>// 主线程
var myWorker = new Worker(&apos;worker.js&apos;, { name: &apos;myWorker&apos;});

// Worker 线程
self.name // myWorker
</code></pre><p>Worker()构造函数返回一个Worker线程对象，用来供主线程操作Worker。Worker线程对象的属性和方法如下。</p>
<ul>
<li>Worker.onerror：指定error事件的监听函数。</li>
<li>Worker.onmessage：指定message事件的监听函数，发送过来的数据在Event.data属性中。</li>
<li>Worker.onmessageerror：指定messageerror事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>Worker.postMessage()：向Worker线程发送消息。</li>
<li>Worker.terminate()：立即终止Worker线程。</li>
</ul>
<p>7.2 Worker线程</p>
<p>Web Worker有自己的全局对象，不是主线程的window，而是一个专门为Worker定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。</p>
<p>Worker线程有一些自己的全局属性和方法。</p>
<ul>
<li>self.name：Worker的名字。该属性只读，由构造函数指定。</li>
<li>self.onmessage：指定message事件的监听函数。</li>
<li>self.onmessageerror：指定messageerror事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>self.close()：关闭Worker线程。</li>
<li>self.postMessage()：向产生这个Worker线程发送消息。</li>
<li>self.importScripts()：加载JS脚本。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/vue/" itemprop="url">vue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:38:00+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>轻量级的前端界面框架</p>
<p>数据渲染 / 数据同步</p>
<p>组件化 / 模块化</p>
<p>其他功能：路由，ajax，数据流</p>
<h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><p>data不应该用引用赋值，应该使用函数返回，这样每次改变只改变当前的data返回</p>
<p>Vue基本概念</p>
<pre><code>全局api
实例选项
实例属性/方法
指令
内置组件
</code></pre><p>三、全局api</p>
<p>v-for：可以数组也可对象</p>
<pre><code>components: {
    componentA: componentA
}
</code></pre><hr>
<pre><code>Vue.set  =&gt;  vm.$set

代替

vm.items[indexOfItem] = newValue
vm.items.length = newLength
</code></pre><p>总结</p>
<pre><code>单文件组件
文本渲染 - v-html，{{}}，v-text
列表渲染 - 数组，对象
列表数据的同步更新
</code></pre><p><strong>v-bind</strong></p>
<pre><code>绑定class：v-bind:class=&quot;className&quot;;

:class=&quot;[classA, {&apos;red-font&apos;: hasError}]&quot;

className: {
    &apos;red-font&apos;: true,
    &apos;blue-font&apos;: false
}

className: [&apos;red-font&apos;, &apos;big-font&apos;]
</code></pre><p>总结</p>
<pre><code>v-bind动态绑定标签属性
v-bind可简写为：
使用v-bind绑定class和内联样式
使用v-if，v-show，v-else进行条件渲染
</code></pre><p><strong>v-model</strong></p>
<pre><code>v-model.lazy    输入完成触发
       .number  输入值的类型为number typeof
       .trim    去空格
</code></pre><p>总结</p>
<pre><code>v-on，@，methods事件绑定
v-on修饰符可以指定键盘事件
v-model表单数据模型双向绑定
</code></pre><p><strong>watch</strong></p>
<pre><code>watch: {
    myVal: function (val, oldVal) {
        // val 新值
        // oldVal 旧值
    }
}
</code></pre><p>总结</p>
<pre><code>computed选项 - 计算属性
通过调用方法来计算属性
watch选项 - 监听属性变化
</code></pre><p><strong>component</strong></p>
<pre><code>&lt;p :is=&quot;com-a&quot;&gt;&lt;/p&gt;

可以切换组件
</code></pre><p>组件交互的三种方式</p>
<pre><code>通过props
emit事件
slot插槽
</code></pre><p>总结</p>
<pre><code>使用组件树设计项目，配置文件链接各个组件 - 命名转换，动态
组件
父组件向内传递属性 - 动态属性
子组件向外发布事件
slot插槽传递模板 - 具名slot
</code></pre><p><strong>vue一些高级功能</strong></p>
<pre><code>过渡
自定义指令
mixins
插件
</code></pre><p>vue高级功能 - 过渡/动画</p>
<pre><code>CSS过渡
JS过渡
</code></pre><p>css阶段类名</p>
<p>Vue高级功能 - 自定义指令</p>
<p><strong>Vue-cli</strong></p>
<p>初始化一个Vue项目</p>
<pre><code>Vue-cli - vue官方提供的脚手架工具
</code></pre><p>使用vue-cli的优势</p>
<pre><code>成熟的vue项目架构设计
本地测试服务器
集成打包上线方案
</code></pre><p>用变量导出</p>
<pre><code>export { moduleA } from ...
</code></pre><p>总结</p>
<pre><code>单文件组件 - *.vue
使用vue-cli初始化项目
vue-cli项目用到的es6语法
</code></pre><p><strong>vue-router</strong></p>
<pre><code>编程式导航
定义式导航
</code></pre><p>总结</p>
<pre><code>路由map，路由视图，路由导航
路由参数，嵌套路由
命名路由和命名视图
重定向
</code></pre><p><strong>实战</strong></p>
<p>总结</p>
<pre><code>了解vue可以做什么 - 数据渲染，前端模块化，路由
熟悉vuejs的接口功能 - 指令的用法，选项的用法
了解vue组件 - 组件的交互
了解vue工程化方案 - 单文件组件webpack测试数据
</code></pre><p>总结</p>
<pre><code>vue项目的搭建流程
使用ajax请求后端数据
组件的设计与交互
路由，子路由
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/require和import详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/require和import详解/" itemprop="url">require和import详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:37:15+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JS模块化编程是前端小伙伴必不可少的知识。</p>
<h2 id="1-require"><a href="#1-require" class="headerlink" title="1 require"></a>1 require</h2><p>特点：</p>
<ul>
<li>1.运行时加载</li>
<li>2.拷贝到本页面</li>
<li>3.全部引入</li>
</ul>
<p><strong>1.1 CommonJS</strong></p>
<p>Node.js就是用CommonJS思想。在CommonJS中，有一个全局性方法require()，用于加载模块。</p>
<p>1.1.1 用法</p>
<pre><code>var math = require(&apos;math&apos;);
math.add(2, 3);

var math = require(&apos;math&apos;);
const Math = new math(2, 3)
Math.add();
</code></pre><p>1.1.2 模块写法</p>
<p>模块写法分exports和module.exports。</p>
<pre><code>exports.add = (x,y) =&gt; x+y;

module.exports = class math {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }

    add() {
        return x+y;
    }
};
</code></pre><h2 id="1-2-AMD"><a href="#1-2-AMD" class="headerlink" title="1.2 AMD"></a>1.2 AMD</h2><p>require.js和cujo.js就是用AMD思想。</p>
<p>AMD是“Asynchronous Module Definition”的缩写，意思就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所以依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>第二行math.add(2,3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在哪里等。这对服务器不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于“假死”状态。因此，浏览器端的模块，不能采用“同步加载”（synchronous），只能采用“异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p>1.2.1 用法</p>
<pre><code>// require([module], callback);
require([&apos;math&apos;], function (math) {
    &amp;emsp;math.add(2, 3);
});
</code></pre><p>1.2.1 模块写法</p>
<p>define(id?, dependencies?, factory)</p>
<ul>
<li>id: 字符串，模块名称(可选)</li>
<li>dependencies：是我们要载入的依赖模块(可选),使用相对路径。注意是数组格式</li>
<li>factory: 工厂方法，返回一个模块函数</li>
</ul>
<p>一个模块不依赖其他模块写法</p>
<pre><code>// math.js
define(function () {
    var add = function(x,y) {
        return x+y;
    };
    return {
        add: add
    };
});
</code></pre><p>模块还依赖其他模块</p>
<pre><code>define([&apos;a&apos;,&apos;b&apos;], function(a,b){
    function foo(){
        a.doSomething(); // 依赖前置，提前执行
        b.doSomething();
    }
    return {
        foo: foo
    };
});

当require()函数加载上面这个模块的时候，就会先加载Lib.js文件。
</code></pre><h2 id="1-3-CMD"><a href="#1-3-CMD" class="headerlink" title="1.3 CMD"></a>1.3 CMD</h2><p>sea.js就是用CMD思想。 CMD是“Common Module Definition”的缩写。类似于requirejs，但是sea.js是依赖就近，延迟执行，requirejs是依赖前置，提前执行。</p>
<p>1.3.1 用法</p>
<pre><code>seajs.config({
    alias: {
        &apos;jquery&apos;: &apos;http://modules.seajs.org/
        jquery/1.7.2/jquery.js&apos;
    }
});

seajs.use([&apos;./hello&apos;, &apos;jquery&apos;], function(hello, $) {
    $(&apos;#beautiful-sea&apos;).click(hello.sayHello);
});
</code></pre><p>1.3.1 模块写法</p>
<pre><code>define(function(require, exports, module) {
    var $ = require(&apos;jquery&apos;);

    exports.sayHello = function() {
        $(&apos;#hello&apos;).toggle(&apos;show&apos;);
    };
    var b = require(&quot;b&quot;);
    b.doSomething(); // 依赖就近，延迟执行
});
</code></pre><h2 id="2-import"><a href="#2-import" class="headerlink" title="2 import"></a>2 import</h2><p>特点：</p>
<ul>
<li>1.编译时加载</li>
<li>2.只引用定义</li>
<li>3.按需加载</li>
</ul>
<p>|||||</p>
<pre><code>可对比require的特点，发现import完胜require，推荐用import取代require
</code></pre><p>2.1.1 用法</p>
<p>import有两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入），以及import()。</p>
<pre><code>import defaultMember from &quot;module-name&quot;;
import * as name from &quot;module-name&quot;;
import { member } from &quot;module-name&quot;;
import { member as alias } from &quot;module-name&quot;;
import { member1, member2 } from &quot;module-name&quot;;
import { member1, member2 as alias2, [...] } from 
&quot;module-name&quot;;
import defaultMember, { member [, [...]] } from 
&quot;module-name&quot;;
import defaultMember, * as name from &quot;module-name&quot;;
import &quot;module-name&quot;;
</code></pre><ul>
<li>name - 从将要导入模块中收到的导出值的名称</li>
<li>member, memberN - 从导出模块，导入指定名称的多个成员</li>
<li>defaultMember - 从导出模块，导入默认导出成员</li>
<li>alias,aliasN - 别名，对指定导入成员进行的重命名</li>
<li>module-name - 要导入的模块。是一个文件名</li>
<li>as - 重命名导入成员名称（“标识符”）</li>
<li>from - 从已经存在的模块、脚本文件等导入</li>
</ul>
<p><strong>import()</strong></p>
<p>import()返回一个Promise对象。</p>
<pre><code>// 报错
if (x === 2) {
    import MyModual from &apos;./myModual&apos;;
}
</code></pre><p>引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。没办法像require那样根据条件动态加载。于是<a href="https://github.com/tc39/proposal-dynamic-import" title="提案" target="_blank" rel="noopener">https://github.com/tc39/proposal-dynamic-import</a>引入import()函数，编译时分析if语句，完成动态加载。</p>
<pre><code>if(x === 2) {
    import(&apos;myModual&apos;).then((MyModual) =&gt; {
        new MyModual();
    })
}
</code></pre><p>2.2.1 模块写法</p>
<p>export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。</p>
<pre><code>export { name1, name2, ..., nameN };
export { variable1 as name1, variable2 as name2, ...,
 nameN };
export let name1, name2, ..., nameN; // also var
export let name1 = ..., name2 = ..., ..., nameN; // 
also var, const

export default expression;
export default function (...) { ... } // also class,
 function*
export default function name1(...) { ... } // also 
class, function*
export { name1 as default, ... };

export * from ...;
export { name1, name2, ..., nameN } from ...;
export { import1 as name1, import2 as name2, ..., 
nameN } from ...;
</code></pre><ul>
<li>name1…nameN - 导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块使用*import引用</li>
<li>default - 设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入</li>
<li><ul>
<li>继承模块并导出继承模块所有的方法和属性</li>
</ul>
</li>
<li>as - 重命名导出“标识符”</li>
<li>from - 从已经存在的模块、脚本文件…导出</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/MVC-MVP和MVVM的图示/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/MVC-MVP和MVVM的图示/" itemprop="url">MVC,MVP和MVVM的图示</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:36:19+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>复杂的软件必须有清晰合理的架构，否则无法开发和维护。</p>
<p>MVC(Model-View-Controller)是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的MVP和MVVM架构的区别就不容易了。</p>
<p>昨天晚上，我读了《Scaling Isomorphic Javascript Code》，突然意识到，它们的区别非常简单。我用几段话，就可以说清。</p>
<h2 id="一、MVC"><a href="#一、MVC" class="headerlink" title="一、MVC"></a>一、MVC</h2><p>MVC模式的意思是，软件可以分成三个部分。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020104.png" alt=""></p>
<ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Controller）：业务逻辑</li>
<li>模型（Model）：数据保存</li>
</ul>
<p>各部分之间的通信方式如下。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt=""></p>
<ul>
<li><ol>
<li>View传送指令到Controller</li>
</ol>
</li>
<li><ol start="2">
<li>Controller完成业务逻辑后，要求Model改变状态</li>
</ol>
</li>
<li><ol start="3">
<li>Model将新的数据发送到View，用户得到反馈</li>
</ol>
</li>
</ul>
<p>所有通信都是单向的。</p>
<p>二、互动模式</p>
<p>接受用户指令时，MVC可以分成两种方式。一种是通过View接受指令，传递给Controller。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020106.png" alt=""></p>
<p>另一种是直接通过controller接受指令。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020107.png" alt=""></p>
<p>三、实例：Backbone</p>
<p>实际项目往往采用更灵活的方式，以Backbone.js为例。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020108.png" alt=""></p>
<ol>
<li>用户可以向View发送指令（DOM事件），再由View直接要求Model改变状态。</li>
<li>用户也可以直接向Controller发送指令（改变URL触发hashChange事件），再由Controller发送给View。</li>
<li>Controller非常薄，只起到路由的作用，而View非常厚，业务逻辑都部署在View。所以，Backbone索性取消了Controller，只保留一个Router(路由器)。</li>
</ol>
<h2 id="四、MVP"><a href="#四、MVP" class="headerlink" title="四、MVP"></a>四、MVP</h2><p>MVP模式将Controller改名为Presenter，同时改变了通信方向。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt=""></p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View与Model不发生联系，都通过presenter传递。</li>
<li>View非常薄，不部署任何业务逻辑，称为“被动视图”（Passive View）,即没有任何主动性，而Presenter非常厚，所有逻辑都部署在哪里。</li>
</ol>
<h2 id="五、MVVM"><a href="#五、MVVM" class="headerlink" title="五、MVVM"></a>五、MVVM</h2><p>MVVM模式将Presenter改名为ViewModel，基本上与MVP模式完全一致。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt=""></p>
<p>唯一的区别是，它采用双向绑定（data-binding）:View的变动，自动反映在ViewModel，反之亦然。Angular和Ember都采用这种模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/js的原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/js的原型链/" itemprop="url">js的原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:35:23+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在js中，大部分东西都是对象，数组是对象，函数是对象，对象更加是对象。<strong>不管我们给数组和函数定义什么内容，它们总是有一些相同的方法和属性。</strong>比如说hasOwnProperty()，toString()等：</p>
<pre><code>chrome控制台可看出
</code></pre><p><strong>这说明一个对象所拥有的属性不仅仅是它本身拥有的属性，它还会从其他对象中继承一些属性。当js在一个对象中找不到需要的属性时，它会到这个对象的父对象上去找，以此类推，这就构成了对象的原型链。</strong>理解js的原型链对使用js的对象非常有帮助。</p>
<p>chrome强大的控制台可以显示出每一个对象所有的属性！包括prototype、<em>proto</em>、constructor等，你可以自己试试！</p>
<p>让我们通过一个例子由浅入深地理解原型链：</p>
<p>function Foo(_name) {<br>    this.name = _name;<br>}<br>Foo.prototype.show = function() {<br>    console.log(‘I am’, this.name);<br>};<br>var f1 = new Foo(‘obj1’);<br>var f2 = new Foo(‘obj2’);</p>
<p>f1.show(); // I am obj1<br>f2.show(); // I am obj2</p>
<p>这是我们经常使用的创建对象的方式，将共同的方法放到Foo.prototype中，所有实例都共有这个方法了。</p>
<hr>
<p>我们定义的show函数在Foo.prototype中，当我们执行f1.show()时，js发现f1本身没有show这个属性，所以它就到f1的原型（也就是<em>proto</em>指向的对象）去找，找到了就可以调用。</p>
<pre><code>注：每个对象都有一个方法hasOwnProperty()来检查对象本身是否有
某个属性，如果有则返回true;如果这个属性在它的原型链上或原型链
上都没有，则返回false；
</code></pre><p>总结为四点：</p>
<p>1.所有函数都有一个prototype指针，指向原型对象，如图中的Foo的prototype指针。prototype指针的意义是，当我们使用这个构造函数new出新对象的时候，新对象的原型是谁。</p>
<p>2.构造函数的prototype所指向的原型对象有一个constructor指针，指回构造函数。如图中Foo.prototype的constructor指针指向Foo。constructor指针有助于我们找到一个对象的构造函数是谁。</p>
<p>3.<em>proto</em>每个对象都有，js在new一个对象的时候，会将它的<em>proto</em>指向构造函数的prototype指向的那个对象。f1、f2这些实例对象的<em>proto</em>都指向了Foo.prototype。</p>
<p>4.如果一个对象的<em>proto</em>指向了另一个对象，那么前者就继承了后者的所有属性。</p>
<pre><code>请注意_poto_与prototype的区别！_proto_才是真正连接原型链的
东西，而prototype只是构造函数的一个指针属性而已。
</code></pre><p><strong>以下展示了js原生对象的继承关系是怎么样的。</strong></p>
<p>我们先看看Foo的原型吧！Foo是一个函数，它的构造函数是js内部的function Function()，Function的prototype指向了一个对象Function.prototype，因此Foo的<em>proto</em>就指向了Function.prototype，如图。</p>
<pre><code>所有的函数都以function Function()为构造函数，因此，所有函数
（包括function Function()和function Object()）的_proto_
都指向Function.prototype这个对象，这个对象中定义了所有函数
都共有的方法，比如call()、apply()等。
</code></pre><p>我们继续深入下去，Function.prototype这个对象，它就是一个普通的对象，它的构造函数是js内置的function Object()，function Object()的prototype指向Object.prototype，因此Function.prototype.<em>proto</em>就指向Object.prototype，这个对象中定义了所有对象共有的属性，比如我们之前说的hasOwnPrototype()和toString()等。</p>
<pre><code>同理，Foo.prototype和其他自定义的对象也是_proto_指向
Object.prototype对象，就不需要说明了。
</code></pre><p>Object.prototype就是原型链的终点了，它的<em>proto</em>是null，js查找属性时，如果到这里还没有找到，那就是undefined了。</p>
<p>到这里就不难理解为什么我们说在js中，函数也是对象了，它就是继承自对象的！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangXiaofei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangXiaofei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
