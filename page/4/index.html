<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/HTML5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/HTML5/" itemprop="url">HTML5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:25:19+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML5本地存储"><a href="#HTML5本地存储" class="headerlink" title="HTML5本地存储"></a>HTML5本地存储</h2><ul>
<li><p>Storage</p>
<ul>
<li>sessionStorage<ul>
<li>session临时会话，从页面打开到页面关闭的时间段</li>
<li>窗口的临时存储，页面关闭，本地存储消失</li>
</ul>
</li>
<li>localStorage<ul>
<li>永久存储（可以手动删除数据）</li>
</ul>
</li>
</ul>
</li>
<li><p>Storage的特点</p>
<ul>
<li>存储量限制（5M）</li>
<li>客户端完成，不会请求服务器处  理</li>
<li>sessionStorage数据是不共享、localStorage共享</li>
</ul>
</li>
<li><p>Storage API</p>
<ul>
<li>setItem()：<ul>
<li>设置数据，key\value类型，类型都是字符串</li>
<li>可以用获取属性的形式操作</li>
</ul>
</li>
<li>getItem()：<ul>
<li>获取数据，通过key来获取到响应的value</li>
</ul>
</li>
<li>removeItem()：<ul>
<li>删除数据，通过key来删除相应的value</li>
</ul>
</li>
<li>clear()：<ul>
<li>删除全部存储的值</li>
</ul>
</li>
<li>例子：保存注册信息</li>
</ul>
</li>
<li><p>Storage API</p>
<ul>
<li>存储事件：<ul>
<li>当数据有修改或删除的情况下，就会触发storage事件</li>
<li>在对数据进行改变的窗口对象上是不会触发的</li>
<li>Key:修改或删除的key值，如果调用clear(),key为null</li>
<li>newValue：新设置的值，如果调用removeStorage(),key为null</li>
<li>oldValue：调用改变前的value值</li>
<li>storageArea：当前的storage对象</li>
<li>url：触发该脚本变化的文档的url</li>
<li>注：session同窗口才可以，例子：iframe操作</li>
</ul>
</li>
<li>例子：同步购物车</li>
</ul>
</li>
</ul>
<h2 id="HTML5语义化标签的兼容"><a href="#HTML5语义化标签的兼容" class="headerlink" title="HTML5语义化标签的兼容"></a>HTML5语义化标签的兼容</h2><p>兼容IE创建标签</p>
<pre><code>&lt;script&gt;
    document.createElement(&quot;header&quot;);
    document.createElement(&quot;footer&quot;);
    document.createElement(&quot;article&quot;);
&lt;/script&gt;
</code></pre><p>加上    </p>
<pre><code>display: block;
</code></pre><p>或者引入插件</p>
<pre><code>&lt;script src=&quot;html5shiv.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="HTML5表单验证反馈"><a href="#HTML5表单验证反馈" class="headerlink" title="HTML5表单验证反馈"></a>HTML5表单验证反馈</h2><ul>
<li>表单验证<ul>
<li>validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，一种验证失败返回false<ul>
<li>oText.addEventListener(“invalid”, fn1, false);</li>
<li>ev.preventDefault()</li>
<li>valueMissing：输入值为空时</li>
<li>typeMismatch：控件值与预期类型不匹配</li>
<li>patternMismatch：输入值不满足pattern正则</li>
<li>tooLong：超过maxLength最大限制</li>
<li>rangeUnderflow：验证的range最小值</li>
<li>rangeOverflow：验证的range最大值</li>
<li>stepMismatch：验证range的当前值是否符合min、max及step的规则</li>
<li>customError不符合自定义验证</li>
<li>setCustomValidity();自定义验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTML5新的选择器"><a href="#HTML5新的选择器" class="headerlink" title="HTML5新的选择器"></a>HTML5新的选择器</h2><ul>
<li>querySelector</li>
<li>querySelectorAll</li>
<li>getElementsByClassName</li>
</ul>
<p><strong>- 获取class列表属性</strong></p>
<ul>
<li>classList<ul>
<li>length：class的长度</li>
<li>add()：添加class方法</li>
<li>remove()：删除class方法</li>
<li>toggle()：切换class方法</li>
</ul>
</li>
</ul>
<p><strong>- JSON的新方法</strong></p>
<ul>
<li>parse()：把字符串转成json<ul>
<li>字符串中的属性要严格的加上引号</li>
</ul>
</li>
<li>stringify()：把json转化成字符串<ul>
<li>会自动的把双引号加上</li>
</ul>
</li>
<li>新方法与eval的区别</li>
<li>新方法的应用<ul>
<li>深度克隆新对象</li>
</ul>
</li>
<li>如何与其他浏览器做到兼容<ul>
<li><a href="http://www.json.org/去下载json2.js" target="_blank" rel="noopener">http://www.json.org/去下载json2.js</a></li>
</ul>
</li>
</ul>
<p>eval：可以解析任何字符串变成JS</p>
<p>parse：只能解析JSON形式的字符串变成JS（安全性要高一些）</p>
<h2 id="自定义数据与JS加载"><a href="#自定义数据与JS加载" class="headerlink" title="自定义数据与JS加载"></a>自定义数据与JS加载</h2><ul>
<li><p>data自定义数据</p>
<ul>
<li>dataset<ul>
<li>data-name：dataset.name</li>
<li>data-name-first：dataset.nameFirst</li>
</ul>
</li>
<li>Data数据在jquery mobile中有着重要作用</li>
</ul>
</li>
<li><p>延迟加载JS</p>
<ul>
<li>JS的加载会影响后面的内容加载<ul>
<li>很多浏览器都采用了并行加载JS，但还是会影响其他内容</li>
</ul>
</li>
<li>Html5的defer和async<ul>
<li>defer：延迟加载，会按顺序执行，在onload执行前被触发</li>
<li>async：异步加载，加载完就触发，有顺序问题</li>
</ul>
</li>
<li>Labjs库</li>
</ul>
</li>
</ul>
<h2 id="历史管理"><a href="#历史管理" class="headerlink" title="历史管理"></a>历史管理</h2><ul>
<li>历史管理<ul>
<li>onhashchange：改变hash值来管理</li>
<li>history：<ul>
<li>服务器下运行</li>
<li>pushState：三个参数：数据 标题(都没实现) 地址(可选)</li>
<li>popstate事件：读取数据 event.state</li>
<li>注意：网址是虚假的，需在服务器指定对应页面，不然刷新找不到页面</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>触发历史管理：</p>
<ol>
<li>通过跳转页面</li>
<li>hash</li>
<li>pushState</li>
</ol>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><ul>
<li><p>draggable：</p>
<ul>
<li>设置为true，元素就可以拖拽了</li>
</ul>
</li>
<li><p>拖放事件</p>
<ul>
<li>拖拽元素事件：事件对象为被拖拽元素<ul>
<li>dragstart，拖拽前触发</li>
<li>drag,拖拽前、拖拽结束之前，连续触发</li>
<li>dragend，拖拽结束触发</li>
</ul>
</li>
<li><p>目标元素事件：事件对象为目标元素</p>
<ul>
<li>dragenter，进入目标元素触发，相当于mouseover</li>
<li>dragover，进入目标、离开目标之间，连续触发</li>
<li>dragleave，离开目标元素触发，相当于mouseout</li>
<li>drop，在目标元素上释放鼠标触发</li>
</ul>
</li>
<li><p>事件的执行顺序：drop不触发的时候</p>
<ul>
<li>dragstart &gt; drag &gt; dragenter &gt; dragover &gt; dragleave &gt;dragend</li>
</ul>
</li>
<li>事件的执行顺序：drop触发的时候(dragover的时候阻止默认事件)<ul>
<li>dragstart &gt; drag &gt; dragenter &gt; dragover &gt; drop &gt; dragend</li>
</ul>
</li>
<li><p>不能释放的光标和能释放的光标不一样</p>
</li>
<li><p>解决火狐下的问题</p>
<ul>
<li>必须设置dataTransfer对象的setData方法才可以拖拽除图片外的其他标签</li>
</ul>
</li>
</ul>
</li>
<li><p>dataTransfer对象</p>
<ul>
<li>setData()：设置数据key和value(必须是字符串)</li>
<li><p>getData()：获取数据，根据key值，获取对应的value</p>
</li>
<li><p>effectAllowed</p>
<ul>
<li>effectAllowed：设置光标样式(none,copy,copyLink,copyMove,link,linkMove,move,all和uninitialized)</li>
</ul>
</li>
<li>setDragImage<ul>
<li>三个参数：指定的元素，坐标X，坐标Y</li>
</ul>
</li>
<li>files<ul>
<li>获取外部拖拽的文件，返回一个fileList列表</li>
<li>filesList下有个type属性，返回文件的类型</li>
</ul>
</li>
</ul>
</li>
<li><p>FileReader(读取文件信息)</p>
<ul>
<li>readAsDataURL<ul>
<li>参数为要读取的文件对象，将文件读取为DataUrl</li>
</ul>
</li>
<li>onload<ul>
<li>当读取文件成功完成的时候触发此事件</li>
<li>this.result，来获取读取的文件数据，如果是图片，将返回base64格式的图片数据</li>
</ul>
</li>
<li>实例<ul>
<li>拖拽删除列表</li>
<li>拖拽购物车</li>
<li>上传图片预览功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p> 标签</p>
<pre><code>&lt;canvas&gt;
不支持canvas的浏览器可以看到的内容
&lt;/canvas
</code></pre><ul>
<li><p>绘制环境</p>
<ul>
<li>getContext(‘2d’)：目前支持2d的场景</li>
</ul>
</li>
<li><p>绘制方块</p>
<ul>
<li>fillRect(L,T,W,H)：默认颜色是黑色</li>
<li>strokeRect(L,T,W,H)：带边框的方块<ul>
<li>默认一像素黑色边框，显示出来的不一样原因</li>
</ul>
</li>
</ul>
</li>
<li><p>设置绘图</p>
<ul>
<li>fillStyle：填充颜色(绘制canvas是有顺序的)</li>
<li>lineWidth：线宽度，是一个数值</li>
<li>strokeStyle：边线颜色</li>
</ul>
</li>
<li><p>边界绘制</p>
<ul>
<li>lineJoin：边界连接点样式<ul>
<li>miter(默认)、round(圆角)、bevel(斜角)</li>
</ul>
</li>
<li>lineCap：端点样式<ul>
<li>butt(默认)、round(圆角)、square(高度多出为宽一半的值)</li>
</ul>
</li>
</ul>
</li>
<li><p>绘制路径</p>
<ul>
<li>beginPath：开始绘制路径</li>
<li>closePath：结束绘制路径</li>
<li>moveTo：移动到绘制的新目标点</li>
<li>lineTo：新的目标点</li>
</ul>
</li>
<li><p>绘制路径_2</p>
<ul>
<li>stroke：画线，默认黑色</li>
<li>fill：填充，默认黑色</li>
<li>rect：矩形区域</li>
<li>clearRect：删除一个画布的矩形区域</li>
<li>save：保存路径</li>
<li>restore：恢复路径</li>
<li>小例子1：鼠标画线</li>
<li>小例子2：方块移动</li>
</ul>
</li>
<li><p>绘制圆</p>
<ul>
<li>arc(x,y,起始弧度,结束弧度,旋转方向)<ul>
<li>x,y：起始位置</li>
<li>弧度与角度的关系：弧度 = 角度*Math.PI/180</li>
<li>旋转方向：顺时针(默认：false)、逆时针(true)</li>
<li>例子：用arc去画个钟表</li>
</ul>
</li>
</ul>
</li>
<li><p>绘制其他曲线</p>
<ul>
<li>arcTo(x1,y1,x2,y2,r)<ul>
<li>第一组坐标、第二组坐标、半径</li>
</ul>
</li>
<li>guadraticCurveTo(x,dy,x1,y1)<ul>
<li>贝塞尔曲线：第一组控制点、第二组结束坐标</li>
</ul>
</li>
<li>bezierCurveTo(dx1,dy1,dx2,dy2,x1,y1)<ul>
<li>贝塞尔曲线：第一组控制点、第二组控制点、第三组结束坐标</li>
</ul>
</li>
</ul>
</li>
<li><p>变换</p>
<ul>
<li>translate<ul>
<li>偏移：从起始点为基准点，移动当前坐标位置</li>
</ul>
</li>
<li>rotate<ul>
<li>旋转：参数为弧度</li>
<li>例子：旋转的小方块</li>
</ul>
</li>
<li>scale<ul>
<li>缩放例子：旋转加缩放的小方块</li>
</ul>
</li>
</ul>
</li>
<li><p>插入图片</p>
<ul>
<li>等图片加载完，再执行canvas操作<ul>
<li>图片预加载：在onload中调用方法</li>
</ul>
</li>
<li>drawImage(oImg,x,y,w,h)<ul>
<li>oImg：当前图片x,y：坐标、w,h：宽高</li>
<li>例子：微博的图片旋转效果</li>
</ul>
</li>
</ul>
</li>
<li><p>设置背景</p>
<ul>
<li>createPattern(oImg,平铺方式)<ul>
<li>2参为：repeat、repeat-x、repeat-y、no-repeat</li>
</ul>
</li>
</ul>
</li>
<li><p>渐变</p>
<ul>
<li>createLinearGradient(x1,y1,x2,y2)<ul>
<li>线性渐变；</li>
<li>第一组参数：起始点坐标、第二组参数：结束点坐标</li>
<li>addColorStop(位置，颜色)添加渐变点</li>
</ul>
</li>
<li>createEadialGradient(x1,y1,r1,x2,y2,r2)<ul>
<li>放射性渐变；</li>
<li>参数：第一个圆的坐标，第二个圆的坐标和半径</li>
</ul>
</li>
</ul>
</li>
<li><p>文本</p>
<ul>
<li>strokeText(文字，x，y)<ul>
<li>文本边框</li>
</ul>
</li>
<li>fillText(文字,x,y)<ul>
<li>文字填充</li>
</ul>
</li>
<li>font<ul>
<li>文字大小：’60pximpact’</li>
</ul>
</li>
<li>textAlign<ul>
<li>默认是start跟left一样的效果end right center</li>
</ul>
</li>
<li>textBaseline<ul>
<li>文字上下的位置的方式默认：alphabetic</li>
</ul>
</li>
</ul>
</li>
<li><p>文本_2</p>
<ul>
<li>measureText()<ul>
<li>measureText(str).width：只有宽度，没有高度</li>
<li>例子：文字居中</li>
</ul>
</li>
</ul>
</li>
<li><p>阴影</p>
<ul>
<li>shadowOffsetX、shadowOffsetY<ul>
<li>X轴偏移、Y轴偏移</li>
</ul>
</li>
<li>shadowBlur<ul>
<li>高斯模糊值</li>
</ul>
</li>
<li>shadowColor<ul>
<li>阴影颜色</li>
</ul>
</li>
</ul>
</li>
<li><p>像素</p>
<ul>
<li>getImageData(x,y,w,h)<ul>
<li>获取图像数据</li>
</ul>
</li>
<li>putImageData(获取图像,x,y)<ul>
<li>设置新的图像数据</li>
</ul>
</li>
<li>属性<ul>
<li>width：一行的像素个数</li>
<li>Height：一列的像素个数</li>
<li>data：一个数组，包含每个像素的rgba四个值，注意每个值都在0~255之间的整数</li>
</ul>
</li>
</ul>
</li>
<li><p>像素_2</p>
<ul>
<li>createImageData(w,h)<ul>
<li>生成新的像素矩阵，初始值是全透明的黑色，即(0,0,0,0)</li>
<li>像素显字</li>
</ul>
</li>
<li>获取和设置指定坐标<ul>
<li>封装：getXY、setXY</li>
</ul>
</li>
<li>图片的像素操作<ul>
<li>必须是同源下</li>
<li>例子：反色、倒影、渐变等</li>
<li>例子：马赛克效果</li>
</ul>
</li>
</ul>
</li>
<li>合成<ul>
<li>全局阿尔法值<ul>
<li>globalAlpha</li>
</ul>
</li>
<li>覆盖合成<ul>
<li>源：新的图形</li>
<li>目标：已经绘制过的图形</li>
<li>globalCompositeOperation属性<ul>
<li>source-over  destination-over source-atop</li>
<li>destination-stop source-in destination-in</li>
<li>source-out destnation-out lighter</li>
<li>copy xor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>将画布导出为图像<ul>
<li>toDataURL<ul>
<li>火狐右键可以直接导出成图片</li>
</ul>
</li>
</ul>
</li>
<li>事件操作<ul>
<li>isPointInPath<ul>
<li>是否在点击范围内</li>
<li>jCanvaScript(canvas中的jquery):<ul>
<li><a href="http://jcscript.com/" target="_blank" rel="noopener">http://jcscript.com/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="跨文档消息通信"><a href="#跨文档消息通信" class="headerlink" title="跨文档消息通信"></a>跨文档消息通信</h2><p><strong>准备工作和同域下的窗口通信</strong></p>
<ul>
<li>postMessage对象<ul>
<li>接收消息的窗口对象.postMessage</li>
<li>一参：发送的数据，二参：接收的域</li>
<li>交互方式<ul>
<li>iframe：父页面：contentWindow、子页面：window.top</li>
<li>窗口页：父页面：window.open、子页面：window.opener</li>
</ul>
</li>
<li>接收事件<ul>
<li>message</li>
<li>ev.origin：发送数据来源的域</li>
<li>ev.data：发送的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>说明：postMessage：通过这个方法给另外一个窗口发送信息</p>
<p>说明2：iframe子页面操作父页面</p>
<pre><code>// parent =&gt; window 如果当前页面是顶级，没有被其他页面所包
含，那么parent就是当前页面的window对象，那么如果被包含了，则
parent就是包含当前页面的父级页面的window对象

window：当前窗口
parent：父级窗口
top：顶级窗口
</code></pre><p><strong>ajax跨域的问题和处理</strong></p>
<ul>
<li>XMLHttpRequest Level 2<ul>
<li>XMLHttpRequest改进版<ul>
<li>请求页面与数据页面必须属性不同的域</li>
<li>服务器要设置响应头信息</li>
<li>Origin值展现</li>
<li>IE：XDomainRequest</li>
<li>新的事件：onload等</li>
<li><a href="http://www.w3.org/TR/XMLHttpRequest2" target="_blank" rel="noopener">http://www.w3.org/TR/XMLHttpRequest2</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/cc288060(VS.85).aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/cc288060(VS.85).aspx</a></li>
</ul>
</li>
<li>进度事件<ul>
<li>upload.onprogress：上传</li>
<li>FormData对象</li>
<li>ev.total(已发送的总量)、ev.loaded(待发送的总量)</li>
<li>onprogress：下载</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>说明：在标准浏览器下，XMLHttpRequet对象已经是升级版本，支持了更多的特性，可以跨域了，但是，如果想实现跨域请求，还需要后端的相关配合才可以 </p>
<p><strong>ajax无刷新上传</strong></p>
<p>说明：我们是要通过ajax把oMyFile.files[0]数据发送给后端</p>
<p><strong>nodejs的安装搭建和一个简单http服务器的实现</strong></p>
<p><strong>websocket</strong></p>
<ul>
<li><p>互联网协议</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></li>
<li>TCP/IP协议<ul>
<li>定义了电子设备如何连入因特网，以及数据在它们之间传输的标准(如何传输)</li>
<li>传输数据(协议)类型：Email，www，FTP等</li>
<li>HTTP协议<ul>
<li>浏览器和万维网服务器之间相互通信的规则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议特点</p>
<ul>
<li>功能很强大</li>
<li>采用请求、响应模式，单项通信</li>
<li>短连接，响应完成连接就断开</li>
</ul>
</li>
<li><p>实时web交互</p>
<ul>
<li>股票、聊天室、网游等应用</li>
<li>如果实现实时应用？服务器推送</li>
</ul>
</li>
<li><p>什么是web socket？</p>
<ul>
<li>基于TCP的双向的、全双工的数据连接<ul>
<li>双向的：客户端、服务器端</li>
<li>全双工：数据的发送与接收，两者同步进行</li>
</ul>
</li>
<li>建立socket应用？<ul>
<li>服务器必须支持web socket.</li>
<li>Nodejs的简介<ul>
<li>Ryan Dahl基于GoogleV8引擎创建的一套用来编写高性能网络服务器的JavaScript工具包</li>
</ul>
</li>
<li>Nodejs：用js去写服务器应用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>nodejs-websocket服务器的创建和应用</strong></p>
<ul>
<li>Node.js<ul>
<li>安装node.js</li>
<li>转到项目目录</li>
<li>运行node scriptname.js</li>
<li>http服务器的创建</li>
<li>安装websocket模块npm install socket.io</li>
<li>websocket服务的创建</li>
</ul>
</li>
</ul>
<p><strong>HTML5之离线存储</strong></p>
<p><strong>applicationCache</strong></p>
<ul>
<li><p>离线应用是什么？</p>
<ul>
<li>乘坐飞机、手机信号弱、去演讲的时候，可能没有网络，这个时候就可以采用离线应用。</li>
<li>离线存储如何工作的？</li>
</ul>
</li>
<li><p>离线存储的好处？</p>
<ul>
<li>没网的时候，可以正常访问</li>
<li>快速响应页面，不必用多个HTTP占用资源带宽</li>
<li>缓存的可以是任何文件</li>
</ul>
</li>
<li><p>搭建离线应用程序</p>
<ol>
<li>服务器设置头信息：<ul>
<li>AddType text/cache-manifest.manifest</li>
</ul>
</li>
<li><p>html标签加：</p>
<ul>
<li>manifest=”xxxxx.manifest”</li>
</ul>
</li>
<li><p>写manifest文件：离线的清单列表</p>
<ul>
<li>先写：CACHE MANIFEST</li>
<li>FALLBACK:第一个网络地址没获取到，就走第二个缓存的</li>
<li>NWTWORK：无论缓存中存在与否，均从网络获取</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="HTML5之workers"><a href="#HTML5之workers" class="headerlink" title="HTML5之workers"></a>HTML5之workers</h2><p><strong>Web Workers</strong></p>
<ul>
<li><p>什么是worker？</p>
<ul>
<li>JS的单线程(放入UI队列的个数，利用定时器解决)</li>
<li>可以让web应用程序具备后台处理能力，对多线程的支持非常好。</li>
</ul>
</li>
<li><p>Worker API</p>
<ul>
<li>new Worker(‘后台处理的JS地址’)</li>
<li>利用postMessage传输数据</li>
<li>importScript(‘导入其他JS文件’)</li>
</ul>
</li>
<li><p>Worker运行环境</p>
<ul>
<li>navigator：appName、appVersion、userAgent、platform</li>
<li>location：所有属性都是只读的</li>
<li>self：指向全局worker对象</li>
<li>所有的ECMA对象，Object、Array、Date等</li>
<li>XMLHttpRequest构造器</li>
<li>setTimeout和setInterval方法</li>
<li>close()方法，立即停止worker方法</li>
<li>importScripts方法</li>
</ul>
</li>
</ul>
<h2 id="HTML5之一些小功能"><a href="#HTML5之一些小功能" class="headerlink" title="HTML5之一些小功能"></a>HTML5之一些小功能</h2><p><strong>HTML5其他功能</strong></p>
<ul>
<li><p>内容编辑</p>
<ul>
<li>contenteditable=”true”</li>
</ul>
</li>
<li><p>语言输入</p>
<ul>
<li><input type="text" x-webkit-speech="">
</li>
</ul>
</li>
<li><p>桌面提醒</p>
<ul>
<li>window.webkitNotifications.requestPermission();</li>
<li>statue=window.webkitNotifications.checkPermission();</li>
<li>var notification = window.webkitNotifications.createNotification(“[imgurl]”,”Title”,”Body”);</li>
<li>notification.show();</li>
</ul>
</li>
</ul>
<h2 id="html5播放器"><a href="#html5播放器" class="headerlink" title="html5播放器"></a>html5播放器</h2><p><strong>音频和视频</strong></p>
<ul>
<li><p>标签</p>
<ul>
<li>audio、video</li>
<li>source</li>
</ul>
</li>
<li><p>视频容器</p>
<ul>
<li>容器文件，类似于压缩了一组文件<ul>
<li>音频轨道</li>
<li>视频轨道</li>
<li>元数据：封面，标题，字幕等</li>
<li>格式：.avi、.flv、.mp4、.mkv、.ogv等</li>
</ul>
</li>
</ul>
</li>
<li><p>媒体元素</p>
<ul>
<li>controls：显示或隐藏用户控制界面</li>
<li>autoplay：媒体是否自动播放</li>
<li>loop：媒体是否循环播放</li>
<li>currentTime：开始到播放现在所用的时间</li>
<li>duration：媒体总时间(只读)</li>
<li>volume：0.0-1.0得到音量相对值</li>
<li>muted：是否静音</li>
<li>autobuffer：开始的时候是否缓冲加载，autoplay的时候，忽略此属性</li>
</ul>
</li>
<li><p>编解码器</p>
<ul>
<li>原始的视频容器非常大，添加需编码，播放需解码</li>
<li>音频编解码器<ul>
<li>AAC、MPEG-3、OggVorbis</li>
</ul>
</li>
<li>视频编解码器<ul>
<li>H.264、VP8、OggTheora</li>
</ul>
</li>
</ul>
</li>
<li><p>媒体元素_2</p>
<ul>
<li>paused：媒体是否暂停(只读)</li>
<li>ended：媒体是否播放完毕(只读)</li>
<li>error：媒体发生错误的时候，返回错误代码(只读)</li>
<li><p>currentSrc：以字符串的形式返回媒体地址(只读)</p>
</li>
<li><p>play()：媒体播放</p>
</li>
<li>pause()：媒体暂停</li>
<li>load()：重新加载媒体</li>
</ul>
</li>
<li><p>媒体元素_3</p>
<ul>
<li>loadstart progress suspend emptied stalled play pause loadedmetadata loadeddata waiting playing canplay canpalythrough seeking eeked timeupdate ended ratechange durationchange volumechange</li>
</ul>
</li>
<li><p>Video额外特性</p>
<ul>
<li>poster：视频播放前的预览图片</li>
<li>width、height：设置视频的尺寸</li>
<li><p>videoWidth、 videoHeight：视频的实际尺寸(只读)</p>
</li>
<li><p>例子：带声音的导航</p>
</li>
<li>例子：视频与canvas结合</li>
<li>例子：自制播放器</li>
<li><a href="http://www.alloyteam.com/wp-content/uploads/2012/03/playdemo/index.html" target="_blank" rel="noopener">http://www.alloyteam.com/wp-content/uploads/2012/03/playdemo/index.html</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/ES6-Learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/ES6-Learn/" itemprop="url">ES6_Learn</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:24:32+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-默认参数"><a href="#1-默认参数" class="headerlink" title="1.默认参数"></a>1.默认参数</h2><pre><code>ES5
function hello(txt){
    txt = txt || &apos;hello world&apos;
}

ES6
function hello(txt=&apos;hello world&apos;){
}
</code></pre><h2 id="2-字符串模板"><a href="#2-字符串模板" class="headerlink" title="2.字符串模板"></a>2.字符串模板</h2><pre><code>ES5
var compiled = _.template(&quot;hello: &lt;%= name %&gt;&quot;);
compiled({name: &apos;moe&apos;});
ES6
var name=&apos;moe&apos;;
var txt=`hello ${name}`
</code></pre><h2 id="3-ES6项目构建"><a href="#3-ES6项目构建" class="headerlink" title="3.ES6项目构建"></a>3.ES6项目构建</h2><p><strong>基础架构</strong></p>
<p>业务逻辑—–》(页面、交互)</p>
<p>自动构建—-》(编译、辅助)—-》(自动刷新、文件合并、资源压缩)</p>
<p>服务接口—-》(数据、接口)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/apply-bind-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/apply-bind-call/" itemprop="url">apply-bind-call</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:23:41+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="call-方法调用一个函数，其具有一个指定的this值和分别地提供的参数-参数的列表-。"><a href="#call-方法调用一个函数，其具有一个指定的this值和分别地提供的参数-参数的列表-。" class="headerlink" title="call()方法调用一个函数，其具有一个指定的this值和分别地提供的参数(参数的列表)。"></a>call()方法调用一个函数，其具有一个指定的this值和分别地提供的参数(参数的列表)。</h2><p><strong>注意</strong>：该方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。</p>
<p><strong>语法</strong></p>
<p>fun.call(thisArg, arg1, arg2, …)</p>
<p><strong>参数</strong></p>
<p>thisArg</p>
<pre><code>在fun函数运行时指定的this值。需要注意的是，指定的this值并不一

定是该函数执行时真正的this值，如果这个函数处于非严格模式下，

则指定为null何undefined的this值会自动指向全局对象(浏览器中

就是window对象)，同时值为原始值（数字，字符串，布尔值）的

this会指向该原始值的自动包装对象。
</code></pre><p>arg1, arg2,…</p>
<pre><code>指定的参数列表。
</code></pre><p><strong>描述</strong></p>
<p>可以让call()中的对象调用当前对象所拥有的function。你可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它(而不是在新对象中再写一次这个方法)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Angular/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Angular/" itemprop="url">Angular</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:22:44+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="angular-cli修改端口号-angular-2"><a href="#angular-cli修改端口号-angular-2" class="headerlink" title="angular-cli修改端口号[angular 2]"></a>angular-cli修改端口号[angular 2]</h2><h5 id="找到node-modules-angular-cli-lib-config-schema-json"><a href="#找到node-modules-angular-cli-lib-config-schema-json" class="headerlink" title="找到node_modules\@angular\cli\lib\config\schema.json"></a>找到node_modules\@angular\cli\lib\config\schema.json</h5><h3 id="default值就是默认的端口号"><a href="#default值就是默认的端口号" class="headerlink" title="default值就是默认的端口号"></a>default值就是默认的端口号</h3><p>“serve”: {<br> “description”: “Properties to be passed to the serve command”,<br> “type”: “object”,<br> “properties”: {<br>  “port”: {<br>  “description”: “The port the application will be served on”,<br>  “type”: “number”,<br>  “default”: 4200<br>  },<br>  “host”: {<br>  “description”: “The host the application will be served on”,<br>  “type”: “string”,<br>  “default”: “localhost”<br>  }<br> }<br> }<br>}</p>
<h4 id="也可以通过命令行方式修改，如："><a href="#也可以通过命令行方式修改，如：" class="headerlink" title="也可以通过命令行方式修改，如："></a>也可以通过命令行方式修改，如：</h4><h6 id="ng-serve-–port-4100"><a href="#ng-serve-–port-4100" class="headerlink" title="ng serve –port 4100"></a>ng serve –port 4100</h6>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Angualr-4教学-Lazy-Loading共用模组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Angualr-4教学-Lazy-Loading共用模组/" itemprop="url">Angualr 4教学- Lazy Loading共用模组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:21:23+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Angualr-4教学-Lazy-Loading共用模组"><a href="#Angualr-4教学-Lazy-Loading共用模组" class="headerlink" title="Angualr 4教学- Lazy Loading共用模组"></a>Angualr 4教学- Lazy Loading共用模组</h2><p>当Angular 4开始拆分模组后，会有一些Component、Pipe、Directive、Service需要共用，此时就可以建立一个共用模组，包含这些可被共用的内容。</p>
<p>本篇将介绍Angular4（Angular 2)的Lazy Loading共用模组。</p>
<p>#File Structure</p>
<p>此范例我建了两个Module及一个Pipe档案架构如下：</p>
<pre><code>index.html
app/
main.ts
app.routes.ts
# ...
first/
components
# ...
first.module.ts
second/
components/
# ...
second.module.ts
shared/
pipes/
localization.pipe.ts
</code></pre><p>#Declarations</p>
<p>如果只是要在其中一个Module使用LocalizationPipe，可以在NgModule定义中的declarations加入LocalizationPipe。如下：</p>
<pre><code>// ...
@NgModule ({
imports: [
RouterModule.forChild(routes)
],
declarations: [
LocalizationPipe,
RouteUtil.getComponents(routes)
],
exports: [
RouterModule
]
})
export class FirstModule { }
</code></pre><p>若使用如上述方法在FirstModule及SecondModule加入LocalizationPipe，则会发生错误。<br>先被载入的模组会正常，当载入第二个模组时就会出错。错误讯息如下：</p>
<pre><code>Error: Type e is part of the declarations of 2     
modules: e and e! Please consider moving e to a higher
module that imports e and e. You can also create a new
NgModule that exports and includes e then import that
NgModule in e and e.
</code></pre><p>#建立共用模组</p>
<p>在使用Lazy Loading时，同样的Declaration不能被重复定义在不同的Module。要避免此问题的话，需要另外建立一个公共的Module，给其他Module载入。如下：</p>
<p>shared\shared.module.ts</p>
<pre><code>// ...
@NgModule ({
imports: [
],
declarations: [
LocalizationPipe
]
})
export class SharedModule { }
</code></pre><p>在FirstModule及SecondModule载入SharedModule。如下：</p>
<pre><code>// ...
@MhModule ({
imports: [
RouterModule.forChild(routes),
SharedModule
],
declarations: [
RouteUtil.getComponent(routes)
],
exports: [
RouterModule
]
})
export class FirstModule { }
</code></pre><p>如此一来，就可在不同的Module共用LocalizationPipe。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Ajax原理和封装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Ajax原理和封装/" itemprop="url">Ajax原理和封装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:20:12+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ul>
<li>什么是Ajax<ul>
<li>Asynchronous JavaScript an XML(异步JavaScript和XML)<ul>
<li>节省用户操作，时间，提高用户体验，减少数据请求</li>
<li>传输获取数据</li>
</ul>
</li>
</ul>
</li>
<li>使用Ajax<ul>
<li>使用ajax获取某一文本文件的内容</li>
</ul>
</li>
<li>Ajax过程详解<ul>
<li>创建对象XMLHttpRequest()<ul>
<li>Date()对象</li>
<li>ActiveXObject(‘Nicrosoft.XMLHTTP’)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<pre><code>表单：数据的提交
    action：数据提交的地址，默认是当前页面
    method：数据提交的方式，默认是get方式
        1.get
            -把数据名称和数据值用=连接，如果有多个的话，那么它会把多个
            数据组合用&amp;进行连接，然后把数据放在url?后面传到指定页面
            -url长度限制的原因，我们不要通过get方式传递过多的数据
        2.post
            -理论上无限制
    enctype：提交的数据的格式，默认application/x-www-form-
    urlencoded格式 

阻塞 -》 同步    
非阻塞 -》 异步
setTimeout(function(){
    alert(2);
}, 200);
</code></pre><ul>
<li>请求状态监控<ul>
<li>onreadystatechange事件<ul>
<li>readyState属性：请求状态<ul>
<li>0（初始化）还没有调用open()方法</li>
<li>1（载入）已调用send()方法，正在发送请求</li>
<li>2（载入完成）send()方法完成，已收到全部响应内容</li>
<li>3（解析）正在解析响应内容</li>
<li>4（完成）响应内容解析完成，可以在客户端调用了</li>
</ul>
</li>
<li>status属性：服务器(请求资源)的状态</li>
<li>返回的内容<ul>
<li>responseText：返回以文本形式存放的内容</li>
<li>responseXML：返回XML形式的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>编写Ajax<ul>
<li>发送请求(get和post的区别)<ul>
<li>send(要发送的数据)：发送请求<ul>
<li>中文编码</li>
<li>缓存</li>
<li>POST:setRequestHeader(类型，内容)：设置请求头</li>
<li>“Content-Type”:”application/x-www-form-urlencode”</li>
</ul>
</li>
</ul>
</li>
<li>数据类型(返回数据的处理)<ul>
<li>服务器返回给咱们的真正数据</li>
<li>XML、HTML、JSON<ul>
<li>JSON的写法</li>
<li>Eval解析JSON的时候需要注意的地方</li>
<li>JSON.parse()：字符串解析成对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>get和post<ul>
<li>乱码：编码encodeURI</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/AJAX跨域解决方案JSONP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/AJAX跨域解决方案JSONP/" itemprop="url">AJAX跨域解决方案JSONP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:18:24+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AJAX-跨域解决之JSONP"><a href="#AJAX-跨域解决之JSONP" class="headerlink" title="AJAX-跨域解决之JSONP"></a>AJAX-跨域解决之JSONP</h1><ul>
<li>跨域的问题<ul>
<li>域：域名</li>
<li>跨域请求（访问）：一个域名下的文件请求另外一个域名下的资源，就产生了跨域</li>
</ul>
</li>
<li>跨域的解决<ul>
<li>Jsonp：json with padding<ul>
<li><ol>
<li>script标签</li>
</ol>
</li>
<li><ol start="2">
<li>用script标签加载资源是没有跨域问题的</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>跨域：跨域名</p>
<p>一个域名下的文件去请求了和他不一样的域名下的资源文件，那么就会产生跨域请求</p>
<p>说明：</p>
<p>在资源加载进来之前定义好一个函数，这个函数接受一个参数（数据），函数里面利用这个参数做一些事情</p>
<p>然后需要的时候通过script标签加载对应远程文件资源，当远程的文件资源被加载进来的时候，就会去执行我们前面定义好的函数，并且把数据当作这个函数的参数传入进去</p>
<ul>
<li><p><script>标签</p>
<ul>
<li>src的作用：加载（包含指定的外部文件）<ul>
<li>可以跨域包含</li>
<li>被包含的资源可以是任何类型的文件(可以是txt，php等)</li>
<li>他只关注被包含的文件的内容是否是合法的JS</li>
</ul>
</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>定义函数</li>
<li>包含外部文件，在被包含的文件中执行调用定义好的函数</li>
<li>参数的（数据）的实现<ul>
<li>问题：包含就调用，通过动态创建<script>实现按需调用</li>
<li>问题：包含动态文件时可以通过一个接口实现按需生成调用函数名称</li>
</ul>
</li>
</ul>
</li>
<li><p>JSONP的封装</p>
</li>
<li><p>实例</p>
<ul>
<li>百度（淘宝）搜索下来提示</li>
<li>126天气预报</li>
<li>（选）豆瓣</li>
</ul>
</li>
<li><p>AJAX+JSONP的封装</p>
</li>
</ul>
</script></p></li></ul>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Ajax/" itemprop="url">Ajax</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:15:57+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a><strong>Ajax</strong></h1><p>(异步JavaScript和XML)Asynchronous JavaScript + XML,其本身不是一种新技术，而是一个在2005年被xxx提出的新术语，用来描述一种使用现有技术集合的’新’方法，包括：HTML or  XHTML,Cascading Style Sheets,JavaScript,The Document Object Model,XML,XSLT.以及最重要的XMLHttpRequest object。当使用结合了这些技术的AJAX模型以后，网页程序能够快速地将渐步更新呈现在用户界面上，不需要重新（刷新）整个页面。这使得程序能够更快地回应用户的操作。</p>
<p>尽管X在Ajax中代表XML，但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。JSON和XML都被用于在Ajax模型中打包信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/JS-深拷贝与浅拷贝的区别，实现深拷贝的几种方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/JS-深拷贝与浅拷贝的区别，实现深拷贝的几种方法/" itemprop="url">[JS]深拷贝与浅拷贝的区别，实现深拷贝的几种方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-25T14:10:22+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</p>
<p>此篇文章中也会简单阐述到<strong>栈堆</strong>，<strong>基本数据类型</strong>与<strong>引用数据类型</strong>，因为这些概念能更好的让你理解深拷贝与浅拷贝。</p>
<p>我们来举个浅拷贝例子：</p>
<pre><code>let a=[0,1,2,3,4],
    b=a;
console.log(a===b);
a[0]=1;
console.log(a,b);
</code></pre><p>嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。</p>
<p>那么这里，就得引入基本数据类型与引用数据类型的概念了。</p>
<p>面试常问，基本数据类型有哪些，number,string,boolean,null,undefined五类。</p>
<p>引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等。</p>
<p>而这两类数组存储分别是这样的：</p>
<p><strong>a.基本类型–名值存储在栈内存中</strong>，例如let a=1;</p>
<p>当你b=a复制时，栈内存会新开辟一个内存，例如这样：</p>
<p>所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。</p>
<p><strong>b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，</strong>我们以上面浅拷贝的例子画个图：</p>
<p>当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。</p>
<p>而当我们<strong>a[0]=1</strong>时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。</p>
<p>那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了</p>
<p><strong>1.我们怎么去实现深拷贝呢，这里可以递归递归去复制所有层级属性。</strong></p>
<p>那么我们封装一个深拷贝的函数</p>
<pre><code>function deepClone(obj) {
    let objClone = Array.isArray(obj) ? [] : {};
    if(obj &amp;&amp; typeof obj===&quot;object&quot;) {
        for(key in obj) {
            if(obj.hasOwnProperty(key)){
                //判断obj子元素是否为对象，如果是，递归复制
                if(obj[key]&amp;&amp;typeof obj[key]===&quot;object&quot;) {
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);
</code></pre><p>跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。<br>这里再次强调，深拷贝，是拷贝对象各个层级的属性，可以看个例子。JQ里有一个extend方法也可以拷贝对象，我们来看看</p>
<pre><code>let a=[1,2,3,4],
    b=a.slice();
a[0]=2;
console.log(a,b);
</code></pre><p>那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改</p>
<pre><code>let a=[0,1,[2,3],4],
    b=a.slice();
a[0]=1;
a[2][0]=1;
console.log(a,b);
</code></pre><p>拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。</p>
<p>第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。</p>
<p>同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。</p>
<p><strong>2.除了递归，我们还可以借用JSON对象的parse和stringify</strong></p>
<pre><code>function deepClone(obj) {
    let _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}
let a=[0,1,[2,3],4],
    b=deepClone(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);
</code></pre><p>可以看到，这下b是完全不受a的影响了。</p>
<p>附带说下，JSON.stringify与JSON.parse除了实现深拷贝，还能结合localStorage实现对象数组存储。</p>
<p><strong>3.除了上面两种方法之外，我们还可以借用JQ的extend方法。</strong></p>
<p><strong>$.extend([deep],target,object1 [,objectN ])</strong></p>
<p><strong>deep</strong>表示是否深拷贝，为true为深拷贝，为false，则为浅拷贝</p>
<p><strong>target Object</strong>类型 目标对象，其他对象的成员属性将被附加到该对象上。</p>
<p><strong>obejct1 objectN</strong>可选。Object类型第一个以及第N个被合并的对象。</p>
<pre><code>let a=[0,1,[2,3],4],
    b=$.extend(true,[],a);
a[0]=1;
a[2][0]=1;
console.log(a,b);
</code></pre><p>可以看到，效果与上面方法一样，只是需要依赖JQ库。</p>
<p>说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/ES6入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangXiaofei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/ES6入门/" itemprop="url">ES6入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-10T21:49:07+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-let-命令"><a href="#1-let-命令" class="headerlink" title="1. let 命令"></a>1. let 命令</h2><p><strong>不存在变量提升</strong></p>
<p><strong>暂时性死区</strong></p>
<p>：暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只要等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<p><strong>不允许重复声明</strong></p>
<h2 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2.块级作用域"></a>2.块级作用域</h2><p><strong>为什么需要块级作用域？</strong></p>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<p><strong>ES6 的块级作用域</strong></p>
<p><strong>块级作用域与函数声明</strong></p>
<h2 id="3-const命令"><a href="#3-const命令" class="headerlink" title="3. const命令"></a>3. const命令</h2><p><strong>基本用法</strong></p>
<p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须初始化，不能留到以后赋值。</p>
<p><strong>本质</strong></p>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<p>常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p>
<h2 id="ES6声明变量的六种方法"><a href="#ES6声明变量的六种方法" class="headerlink" title="ES6声明变量的六种方法"></a>ES6声明变量的六种方法</h2><p>ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。</p>
<p><strong>4.顶层对象的属性</strong></p>
<p>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</p>
<p>为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<p><strong>5.global对象</strong></p>
<p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>
<ul>
<li><p>浏览器里面，顶层对象是window，但Node和Web Worker没有window。</p>
</li>
<li><p>浏览器和Web Worker里面，self也指向顶层对象，但是Node没有self。</p>
</li>
<li><p>Node里面，顶层对象是global，但其他环境都不支持。</p>
</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是由局限性。</p>
<ul>
<li><p>全局环境中，this会返回顶层对象，但是，Node模块和ES6模块中，this返回的是当前模块。</p>
</li>
<li><p>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</p>
</li>
<li><p>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP(Content Security Policy，内容安全策略)，那么eval、new Function这些方法都可能无法使用。</p>
</li>
</ul>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="1-数组的解构赋值"><a href="#1-数组的解构赋值" class="headerlink" title="1.数组的解构赋值"></a>1.数组的解构赋值</h2><p><strong>基本用法</strong></p>
<p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这种称为解构（Destructuring）。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p><strong>默认值</strong></p>
<p>解构赋值允许指定默认值</p>
<p>ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<p>如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<h2 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。</p>
<p>对象的解构也可以指定默认值</p>
<p>默认值生效的条件是，对象的属性值严格等于undefined</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<h2 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<h2 id="4-数组和布尔值的解构赋值"><a href="#4-数组和布尔值的解构赋值" class="headerlink" title="4.数组和布尔值的解构赋值"></a>4.数组和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<h2 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p>
<h2 id="6-圆括号问题"><a href="#6-圆括号问题" class="headerlink" title="6.圆括号问题"></a>6.圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<p><strong>不能使用圆括号的情况</strong></p>
<p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<p>（2）函数参数</p>
<p>（3）赋值语句的模式</p>
<p><strong>可以使用圆括号的情况</strong></p>
<p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<h2 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h2><p>变量的解构赋值用途很多。</p>
<p>（1）交换变量的值</p>
<p>（2）从函数返回多个值</p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<p>（3）函数参数的定义</p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<p>（4）提取JSON数据</p>
<p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<p>（5）函数参数的默认值</p>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p>（6）遍历Map解构</p>
<p>任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<p>（7）输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><p>ES6加强了对Unicode的支持，并且扩展了字符串对象。</p>
<h2 id="1-字符的Unicode表示法"><a href="#1-字符的Unicode表示法" class="headerlink" title="1.字符的Unicode表示法"></a>1.字符的Unicode表示法</h2><p>JavaScript允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。</p>
<p>但是，这种表示法只限于码点在\u0000 ~ \uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<p>ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<h2 id="2-codePointAt"><a href="#2-codePointAt" class="headerlink" title="2.codePointAt()"></a>2.codePointAt()</h2><p>JavaScript内部，字符以UTF-16的格式存储，每个字符固定为2个字节。对于那些需要4个字节存储的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。</p>
<p>对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6提供了codePointAt方法，能够正确处理4个字节存储的字符，返回一个字符的码点。</p>
<p>codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单的方法。</p>
<h2 id="3-String-fromCodePoint"><a href="#3-String-fromCodePoint" class="headerlink" title="3.String.fromCodePoint()"></a>3.String.fromCodePoint()</h2><p>ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。</p>
<p>ES6提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p>
<p>如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p>
<h2 id="4-字符串的遍历器接口"><a href="#4-字符串的遍历器接口" class="headerlink" title="4.字符串的遍历器接口"></a>4.字符串的遍历器接口</h2><p>ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。</p>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<h2 id="5-at"><a href="#5-at" class="headerlink" title="5.at()"></a>5.at()</h2><p>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</p>
<p>目前，有一个提案，提出字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。<br>这个方法可以通过垫片库实现。</p>
<h2 id="6-normalize"><a href="#6-normalize" class="headerlink" title="6.normalize()"></a>6.normalize()</h2><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如ö（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音字符的合成，两个字符合成一个字符，比如o（\u004F）和ν（\u030C）合成ö（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。</p>
<p>JavaScript将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为相同的形式，这称为Unicode正规化。</p>
<p>normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。</p>
<ul>
<li><p>NFC，默认参数，表示“标准等价合成”（Normalization From Canonical Composition）,返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</p>
</li>
<li><p>NFD，表示“标准等价分解”（Normalization From Canonical Decomposition）,即在标准等价的前提下，返回合成字符分解的多个简单字符。</p>
</li>
<li><p>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition）,返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文）。</p>
</li>
<li><p>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition）,即在兼容等价的前提下，返回合成字符分解的多个简单字符。</p>
</li>
</ul>
<p>不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。</p>
<p>7.includes(),startsWith(),endsWith()</p>
<p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<pre><code>- includes():返回布尔值，表示是否找到了参数字符串。
- startsWith():返回布尔值，表示参数字符串是否在原字符串的头部。
- endsWith():返回布尔值，表示参数字符串是否在原字符串的尾部。
</code></pre><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<p>使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<h2 id="8-repeat"><a href="#8-repeat" class="headerlink" title="8.repeat()"></a>8.repeat()</h2><p>repeat方法返回一个新字符串，表示将原字符串重新n次</p>
<p>参数如果是小数，会被取整。</p>
<p>如果repeat的参数是负数或者Infinity，会报错。</p>
<p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。</p>
<p>参数NaN等同于0。</p>
<p>如果repeat的参数是字符串，则会先转换成数字。</p>
<h2 id="9-padStart-，padEnd"><a href="#9-padStart-，padEnd" class="headerlink" title="9.padStart()，padEnd()"></a>9.padStart()，padEnd()</h2><p>ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<p>padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<p>如果省略第二个参数，默认使用空格补全长度。</p>
<p>padStart的常见用途是为数值补全指定位数。</p>
<p>另一个用途是提示字符串格式。</p>
<h2 id="10-matchAll"><a href="#10-matchAll" class="headerlink" title="10.matchAll()"></a>10.matchAll()</h2><p>matchAll方法返回一个正则表达式在当前字符串的所有匹配。</p>
<h2 id="11-模板字符串"><a href="#11-模板字符串" class="headerlink" title="11.模板字符串"></a>11.模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<p>如果你不想要这个换行，可以使用trim方法消除它。</p>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。</p>
<p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p>
<p>模板字符串之中还能调用函数。</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<p>模板字符串甚至还能嵌套。</p>
<h2 id="12-实例：模板编译"><a href="#12-实例：模板编译" class="headerlink" title="12.实例：模板编译"></a>12.实例：模板编译</h2><h2 id="13-标签模板"><a href="#13-标签模板" class="headerlink" title="13.标签模板"></a>13.标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>如果模板字符串里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<p>模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<h2 id="14-String-raw"><a href="#14-String-raw" class="headerlink" title="14.String.raw()"></a>14.String.raw()</h2><p>ES6还为原生的String对象，提供了一个raw方法。</p>
<p>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<p>如果原字符串的斜杠已经转义，那么String.raw会进行再次转义。</p>
<p>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</p>
<h2 id="15-模板字符串的限制"><a href="#15-模板字符串的限制" class="headerlink" title="15.模板字符串的限制"></a>15.模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p>举例来说，标签模板里面可以嵌入LaTEX语言。</p>
<h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><h2 id="1-RegExp构造函数"><a href="#1-RegExp构造函数" class="headerlink" title="1.RegExp构造函数"></a>1.RegExp构造函数</h2><p>在ES5中，RegExp构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag)。</p>
<p>第二种情况是，参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝。</p>
<p>但是，ES5不允许此时使用第二个参数添加修饰符，否则会报错。</p>
<p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<h2 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2.字符串的正则方法"></a>2.字符串的正则方法</h2><p>字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。</p>
<p>ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全部定义在RegExp对象上。</p>
<pre><code>- String.prototype.match调用RegExp.prototype

[Symbol.match]

-String.prototype.replace调用RegExp.prototype

[Symbol.replace]

-String.prototype.search调用RegExp.prototype

[Symbol.search]

-String.prototype.split调用RegExp.prototype

[Symbol.split]
</code></pre><h2 id="3-u修饰符"><a href="#3-u修饰符" class="headerlink" title="3.u修饰符"></a>3.u修饰符</h2><p>ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>
<p><strong>（1）点字符</strong></p>
<p>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。</p>
<p><strong>（2）Unicode字符表示法</strong></p>
<p>ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<p><strong>（3）量词</strong></p>
<p>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。</p>
<p><strong>（4）预定义模式</strong></p>
<p>u修饰符也影响到预定义模式，是否正确识别码点大于0xFFFF的Unicode字符。</p>
<p>\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0XFFFF的Unicode字符。</p>
<p>（5）i修饰符</p>
<p>有些Unicode字符的编码不同，但是字型很相近，比如，\u0048与\u212A都是大写的K</p>
<p>不加u修饰符，就无法识别非规范的K字符。</p>
<h2 id="4-RegExp-prototype-unicode属性"><a href="#4-RegExp-prototype-unicode属性" class="headerlink" title="4.RegExp.prototype.unicode属性"></a>4.RegExp.prototype.unicode属性</h2><p>正则实例对象新增unicode属性，表示是否设置了u修饰符。</p>
<p>正则表达式是否设置了u修饰符，可以从unicode属性看出来。</p>
<h2 id="5-y修饰符"><a href="#5-y修饰符" class="headerlink" title="5.y修饰符"></a>5.y修饰符</h2><p>除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</p>
<p>y修饰符的作用域g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的含义。</p>
<h2 id="6-RegExp-prototype-sticky属性"><a href="#6-RegExp-prototype-sticky属性" class="headerlink" title="6.RegExp.prototype.sticky属性"></a>6.RegExp.prototype.sticky属性</h2><p>与y修饰符相匹配，ES6的正则实例对象多了sticky属性，表示是否设置了y修饰符。</p>
<h2 id="7-RegExp-prototype-flags属性"><a href="#7-RegExp-prototype-flags属性" class="headerlink" title="7.RegExp.prototype.flags属性"></a>7.RegExp.prototype.flags属性</h2><p>ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<h2 id="8-s修饰符：dotAll模式"><a href="#8-s修饰符：dotAll模式" class="headerlink" title="8.s修饰符：dotAll模式"></a>8.s修饰符：dotAll模式</h2><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的UTF-16字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>
<pre><code>- U+000A 换行符（\n）
- U+000D 回车符（\r）
- U+2028 行分隔符（line separator）
- U+2029 段分隔符（paragraph separator）
</code></pre><p>ES2018引入s修饰符，使得.可以匹配任意单个字符。</p>
<p>这被称为doAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个doAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。</p>
<p>/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。</p>
<h2 id="9-后行断言"><a href="#9-后行断言" class="headerlink" title="9.后行断言"></a>9.后行断言</h2><p>JavaScript语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead）,不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018引入后行断言，V8引擎4.9版（Chrome 62）已经支持。</p>
<p>“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p>
<p>“先行断言”括号之中的部分(?=%)，是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。“后行否定断言”则与“先行否定断言”相反，x只要不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。</p>
<p>“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。</p>
<p>。。。。。。</p>
<h2 id="10-Unicode属性类"><a href="#10-Unicode属性类" class="headerlink" title="10.Unicode属性类"></a>10.Unicode属性类</h2><p>ES2018引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合Unicode某种属性的所有字符。</p>
<p>Unicode属性类要指定属性名和属性值。</p>
<p>对于某些属性，可以只写属性名，或者只写属性值。</p>
<p>。。。。。。。。。。。</p>
<h2 id="11-具名组匹配"><a href="#11-具名组匹配" class="headerlink" title="11.具名组匹配"></a>11.具名组匹配</h2><p><strong>简介</strong></p>
<p>正则表达式使用圆括号进行组匹配。</p>
<p>正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。</p>
<p>。。。。。。。。。。。</p>
<p><strong>解构赋值和替换</strong></p>
<p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<p><strong>引用</strong></p>
<p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</p>
<h2 id="12-String-prototype-matchAll"><a href="#12-String-prototype-matchAll" class="headerlink" title="12.String.prototype.matchAll"></a>12.String.prototype.matchAll</h2><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。</p>
<p>。。。。。。。。。。。。</p>
<h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h2 id="1-二进制和八进制表示法"><a href="#1-二进制和八进制表示法" class="headerlink" title="1.二进制和八进制表示法"></a>1.二进制和八进制表示法</h2><p>ES6提供了二进制和八进制数值的新方法，分别用前缀0b（或0B）和0o（或0o）表示。</p>
<p>从ES5开始，在严格模式之中八进制就不再允许使用前缀0表示，ES6进一步明确，要使用前缀0o表示。</p>
<p>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</p>
<h2 id="2-Number-isFinite-，Number-isNaN"><a href="#2-Number-isFinite-，Number-isNaN" class="headerlink" title="2.Number.isFinite()，Number.isNaN()"></a>2.Number.isFinite()，Number.isNaN()</h2><p>ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。</p>
<p>Number.isFinite()用来检查一个数值是否为有限的(finite)，即不是Infinity。</p>
<p>注意，如果参数类型不是数值，Number.isFinite一律返回false。</p>
<p>Number.isNaN()用来检查一个值是否为NaN。</p>
<p>如果参数类型不是NaN，Number.isNaN一律返回false。</p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false，Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p>
<h2 id="3-Number-parseInt-，Number-parseFloat"><a href="#3-Number-parseInt-，Number-parseFloat" class="headerlink" title="3.Number.parseInt()，Number.parseFloat()"></a>3.Number.parseInt()，Number.parseFloat()</h2><p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>
<h2 id="4-Number-isInteger"><a href="#4-Number-isInteger" class="headerlink" title="4.Number.isInteger()"></a>4.Number.isInteger()</h2><p>Number.isInteger()用来判断一个数值是否为整数。</p>
<p>JavaScript内部，整数和浮点数采用的是同样的存储方法，所以25和25.0被视为同一个值。</p>
<p>如果参数不是数值，Number.isInteger返回false。</p>
<p>注意，由于JavaScript采用IEEE 754标准，数值存储在64位双精度格式，数值精度最多可以达到53个二进制位（1个隐藏位与52个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</p>
<p>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE(5E-324)，即小于JavaScript能够分辨的最小值，会被自动转为0。这时，Number.isInteger也会误判。</p>
<p>如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。</p>
<h2 id="5-Number-EPSILON"><a href="#5-Number-EPSILON" class="headerlink" title="5.Number.EPSILON"></a>5.Number.EPSILON</h2><p>ES6在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示1与大于1的最小浮点数之间的差。</p>
<p>对于64位浮点数来说，大于1的最小浮点数相当于二进制的1.00..001，小数点后面有连续51个零。这个值减去1之后，就等于2的-52次方。</p>
<p>Number.EPSILON实际上是JavaScript能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不准确的。</p>
<p>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为2的-50次方（即Number.ESPILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<p>因此，Number.EPSILON的实质是一个可以接受的最小误差范围。</p>
<h2 id="6-安全整数和Number-isSafeInteger"><a href="#6-安全整数和Number-isSafeInteger" class="headerlink" title="6.安全整数和Number.isSafeInteger()"></a>6.安全整数和Number.isSafeInteger()</h2><p>JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<p>ES6引入Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<p>9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式存储。</p>
<h2 id="7-Math对象的扩展"><a href="#7-Math对象的扩展" class="headerlink" title="7.Math对象的扩展"></a>7.Math对象的扩展</h2><p>ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。</p>
<p><strong>Math.trunc()</strong></p>
<p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</p>
<p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</p>
<p>对于空值和无法截取整数的值，返回NaN。</p>
<p><strong>Math.sign()</strong></p>
<p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<pre><code>- 参数为正数，返回+1；
- 参数为负数，返回-1；
- 参数为0，返回0；
- 参数为-0，返回-0；
- 其他值，返回NaN。
</code></pre><p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</p>
<p><strong>Math.cbrt()</strong></p>
<p>Math.cbrt方法用于计算一个数的立方根。</p>
<p>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</p>
<p><strong>Math.clz32()</strong></p>
<p>JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。</p>
<p>0的二进制形式全为0，所以有32个前导0；1的二进制形式是0b1，只占1位，所以32位之中有31个前导0；1000的二进制形式是0b1111101000,一共有10位，所以32位之中有22个前导0。</p>
<p>clz32这个函数名就来自“count leading zero bits in 32-bit binary representation of a number”(计算一个数的32位二进制形式的前导0的个数)的缩写。</p>
<p>左移运算符（&lt;&lt;）与Math.clz32方法直接相关。</p>
<p>对于小数，Math.clz32方法只考虑整数部分。</p>
<p>对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</p>
<p><strong>Math.imul()</strong></p>
<p>Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</p>
<p>。。。。。。。。</p>
<p><strong>Math.fround()</strong></p>
<p>Math.fround()</p>
<p>Math.fround方法返回一个数的32位单精度浮点数形式。</p>
<p>对于32位单精度格式来说，数值精度是24个二进制位（1位隐藏位与23位有效位），所以对于-2^24至2^24之间的整数（不含两个端点），返回结果与参数本身一致。</p>
<p>如果参数的绝对值大于2^24，返回的结果便开始丢失精度。</p>
<p>Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>
<p>对于NaN和Infinity，此方法返回原值。对于其他类型的非数值，Math.fround方法会先将其转为数值，再返回单精度浮点数。</p>
<p><strong>Math.hypot()</strong></p>
<p>Math.hypot方法返回所有参数的平方和的平方根。</p>
<p>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。</p>
<h2 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h2><p>ES6新增了4个对数相关方法。</p>
<p><strong>（1）Math.expm1()</strong></p>
<p>Math.expm1(x)返回e^x -1，即Math.exp(x) - 1。</p>
<p><strong>（2）Math.log1p()</strong></p>
<p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p>
<p><strong>（3）Math.log10()</strong></p>
<p>Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。</p>
<p><strong>（4）Math.log2()</strong></p>
<p>Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。</p>
<h2 id="双曲函数方法"><a href="#双曲函数方法" class="headerlink" title="双曲函数方法"></a>双曲函数方法</h2><p>ES6新增了6个双曲函数方法。</p>
<pre><code>- Math.sin(x) 返回x的双曲正弦（hyperbolic sine）
- Math.cos(x) 返回x的双曲余弦（hyperbolic cosine）
- Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
- Math.asinh(x) 返回x的反双曲正弦（invese hyperbolic sine）
- Math.acosh(x) 返回x的反双曲余弦（invese hyperbolic cosine）
- Math.atanh(x) 返回x的饭双曲正切（inverse hyperbolic 
tangent）
</code></pre><h2 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8.指数运算符"></a>8.指数运算符</h2><p>ES2016新增了一个指数运算符（**）。</p>
<p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p>
<p>注意，在V8引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</p>
<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1.函数参数的默认值"></a>1.函数参数的默认值</h2><p><strong>基本用法</strong></p>
<p>ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<p>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。</p>
<p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<p>除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>参数变量是默认声明的，所以不能用let或const再次声明。</p>
<p>使用参数默认值时，函数不能有同名参数。</p>
<p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<p><strong>与解构赋值默认值结合使用</strong></p>
<p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<p><strong>参数默认值的位置</strong></p>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<p>有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p>
<p><strong>函数的length属性</strong></p>
<p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包含这个参数了。同理，后文的rest参数也不会计入length属性。</p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<p><strong>作用域</strong></p>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<p>参数y=x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</p>
<p>参数x=x形成一个单独作用域。实际执行的是let x =x，由于暂时性死区的原因，这行代码会报错”x 未定义”。</p>
<p>如果参数的默认值时一个函数，该函数的作用域也遵守这个规则。</p>
<p><strong>应用</strong></p>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<p>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<h2 id="2-rest参数"><a href="#2-rest参数" class="headerlink" title="2.rest参数"></a>2.rest参数</h2><p>ES6引入rest参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<p>利用rest参数，可以向该函数传入任意数目的参数。</p>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>
<p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<p>函数的length属性，不包括rest参数。</p>
<h2 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3.严格模式"></a>3.严格模式</h2><p>从ES5开始，函数内部可以设定为严格模式。</p>
<p>ES2016做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<h2 id="4-name属性"><a href="#4-name属性" class="headerlink" title="4.name属性"></a>4.name属性</h2><p>函数的name属性，返回该函数的函数名。</p>
<p>这个属性早就被浏览器广泛支持，但是直到ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名。</p>
<p>如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。</p>
<p>Function构造函数返回的函数实例，name属性的值为anonymous。</p>
<p>bind返回的函数，name属性值会加上bound前缀。</p>
<h2 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5.箭头函数"></a>5.箭头函数</h2><p><strong>基本用法</strong></p>
<p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<p>如果箭头函数的代码块部分多于一条语句，就需要使用大括号将它们括起来，并且使用return语句返回。</p>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<p>箭头函数可以与变量解构结合使用。</p>
<p>箭头函数使得表达更加简洁。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<p><strong>使用注意点</strong></p>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<p><strong>箭头函数导致this总是指向函数定义生效时所在的对象</strong></p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<p>长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数“绑定”this，很大程度上解决了这个困扰。</p>
<p><strong>嵌套的箭头函数</strong></p>
<p>箭头函数内部，还可以再使用箭头函数。</p>
<h2 id="6-双冒号运算符"><a href="#6-双冒号运算符" class="headerlink" title="6.双冒号运算符"></a>6.双冒号运算符</h2><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p>
<p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<h2 id="7-尾调用优化"><a href="#7-尾调用优化" class="headerlink" title="7.尾调用优化"></a>7.尾调用优化</h2><p><strong>什么是尾调用？</strong></p>
<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<p>以下三种情况，都不属于尾调用。</p>
<p>情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于return undefined；</p>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<p><strong>尾调用优化</strong></p>
<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”(call stack)。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息就不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<p>如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<p><strong>尾递归</strong></p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上万个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6是如此，第一次明确规定，所以ECMAScript的实现，都必须部署“尾调用优化”。这就是说，ES6中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<p><strong>递归函数的改写</strong></p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数factorial需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p>。。。。。。。。。。。。。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾递归优化”的语言（比如Lua，ES6），只需要知道循环可以用递归替代，而一旦使用递归，就最好使用尾递归。</p>
<p><strong>严格模式</strong></p>
<p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<pre><code>- func.arguments：返回调用时函数的参数。
- func.caller：返回调用当前函数的那个函数。
</code></pre><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<p><strong>尾递归优化的实现</strong></p>
<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>。。。。。。。。。。。。。。</p>
<h2 id="8-函数参数的尾逗号"><a href="#8-函数参数的尾逗号" class="headerlink" title="8.函数参数的尾逗号"></a>8.函数参数的尾逗号</h2><p>ES2017允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1.扩展运算符"></a>1.扩展运算符</h2><p><strong>含义</strong></p>
<p>扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p>该运算符主要用于函数调用。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<p>扩展运算符后面还可以放置表达式。</p>
<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<p><strong>替代函数的apply方法</strong></p>
<p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<p>由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p><strong>扩展运算符的应用</strong></p>
<p><strong>(1)复制数组</strong></p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<p><strong>（2）合并数组</strong></p>
<p>a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。</p>
<p><strong>（3）与解构赋值结合</strong></p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<p><strong>（4）字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<p>凡是涉及到操作四个字节的Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<p><strong>（5）实现了Iterator接口的对象</strong></p>
<p>任何Iterator接口的对象（参阅Iterator一章），都可以用扩展运算符转为真正的数组。</p>
<p>扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator。</p>
<p>对于那些没有部署Itrator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<p>没有部署Iterator接口，扩展运算符就会报错。这时，可以改写使用Array.from方法将arrayLike转为真正的数组。</p>
<p><strong>（6）Map和Set结构，Generator函数</strong></p>
<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>
<p>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<p>如果对没有Iterator接口的对象，使用扩展运算符，将会报错。</p>
<h2 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.Array.from()"></a>2.Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object)和可遍历(iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<p>只要是部署了iterator接口的数据结构，Array.from都能将其转为数组。</p>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
<p>。。。。。。。。。</p>
<h2 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3.Array.of()"></a>3.Array.of()</h2><p>Array.of方法用于将一组值，转换为数组。</p>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>
<p>只有当参数个数不小于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<p>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<h2 id="4-数组实例的copyWithin"><a href="#4-数组实例的copyWithin" class="headerlink" title="4.数组实例的copyWithin()"></a>4.数组实例的copyWithin()</h2><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<p>它接受三个参数。</p>
<pre><code>-target(必须)：从该位置开始替换数据。如果为负值，表示倒数。
-start(可选)：从该位置开始读取数据，默认为0.如果为负值，表示倒数。
-end(可选)：到该位置前停止读取数据，默认等于数组长度。如果为负
值，表示倒数。
</code></pre><p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<h2 id="5-数组实例的find-和findIndex"><a href="#5-数组实例的find-和findIndex" class="headerlink" title="5.数组实例的find()和findIndex()"></a>5.数组实例的find()和findIndex()</h2><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<p>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
<p>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p>
<h2 id="6-数组实例的fill"><a href="#6-数组实例的fill" class="headerlink" title="6.数组实例的fill()"></a>6.数组实例的fill()</h2><p>fill方法使用给定值，填充一个数组。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<h2 id="7-数组实例的entries-，keys-和values"><a href="#7-数组实例的entries-，keys-和values" class="headerlink" title="7.数组实例的entries()，keys()和values()"></a>7.数组实例的entries()，keys()和values()</h2><p>ES6提供三个新的方法–entries()，keys()和values()–用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。</p>
<h2 id="8-数组实例的includes"><a href="#8-数组实例的includes" class="headerlink" title="8.数组实例的includes()"></a>8.数组实例的includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。</p>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。</p>
<p>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。</p>
<pre><code>-Map 结构的has方法，是用来查找键名的，比如
Map.prototype.has(key)、WeakMap.prototype.has(key)、
Reflect.has(target, propertyKey)。

-Set 结构的has方法，是用来查找值的，比如Set.prototype.has
(value)、WeakSet.prototype.has(value)。
</code></pre><h2 id="9-数组实例的flat-，flatMap"><a href="#9-数组实例的flat-，flatMap" class="headerlink" title="9.数组实例的flat()，flatMap()"></a>9.数组实例的flat()，flatMap()</h2><p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<p>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p>
<p>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p>
<p>如果原数组有空位，flat()方法会跳过空位。</p>
<p>flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。</p>
<p>flatMap()只能展开一层数组。</p>
<p>flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p>
<p>flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。</p>
<h2 id="10-数组的空位"><a href="#10-数组的空位" class="headerlink" title="10.数组的空位"></a>10.数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。</p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<pre><code>-forEach(), filter(), reduce(), every() 和some()都会跳过空位。
-map()会跳过空位，但会保留这个值
-join()和toString()会将空位视为undefined，而undefined和
null会被处理成空字符串。
</code></pre><p>ES6 则是明确将空位转为undefined。</p>
<p>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</p>
<p>扩展运算符（…）也会将空位转为undefined。</p>
<p>copyWithin()会连空位一起拷贝。</p>
<p>fill()会将空位视为正常的数组位置。</p>
<p>for…of循环也会遍历空位。</p>
<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</p>
<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1.属性的简洁表示法"></a>1.属性的简洁表示法</h2><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<p>除了属性简写，方法也可以简写。</p>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<h2 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2.属性名表达式"></a>2.属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<h2 id="3-方法的name属性"><a href="#3-方法的name属性" class="headerlink" title="3.方法的name属性"></a>3.方法的name属性</h2><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。</p>
<p>有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。</p>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。</p>
<h2 id="4-Object-is"><a href="#4-Object-is" class="headerlink" title="4.Object.is()"></a>4.Object.is()</h2><p>ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6提出“Same-value equality”(同值相等)算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>
<h2 id="5-Object-assign"><a href="#5-Object-assign" class="headerlink" title="5.Object.assign()"></a>5.Object.assign()</h2><p><strong>基本用法</strong></p>
<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<p>如果只有一个参数，Object.assign会直接返回该参数。</p>
<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<p>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</p>
<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</p>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>
<p><strong>注意点</strong></p>
<p><strong>（1)浅拷贝</strong></p>
<p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<p><strong>（2）同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</p>
<p>一些函数库提供Object.assign的定制版本（比如 Lodash 的_.defaultsDeep方法），可以得到深拷贝的合并。</p>
<p><strong>(3)数组的处理</strong></p>
<p>Object.assign可以用来处理数组，但是会把数组视为对象。</p>
<p><strong>(4)取值函数的处理</strong></p>
<p>Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<p><strong>常见用途</strong></p>
<p>Object.assign方法有很多用途</p>
<p><strong>（1）为对象添加属性</strong></p>
<p><strong>(2)为对象添加方法</strong></p>
<p><strong>（3）克隆对象</strong></p>
<p><strong>（4）合并多个对象</strong></p>
<p><strong>（5）为属性指定默认值</strong></p>
<p>注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。</p>
<h2 id="6-属性的可枚举性和遍历"><a href="#6-属性的可枚举性和遍历" class="headerlink" title="6.属性的可枚举性和遍历"></a>6.属性的可枚举性和遍历</h2><p><strong>可枚举性</strong></p>
<p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p>
<p>描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略enumerable为false的属性。</p>
<pre><code>- for...in循环：只遍历对象自身的和继承的可枚举的属性。
- Object.keys()：返回对象自身的所有可枚举的属性的键名。
- JSON.stringify()：只串行化对象自身的可枚举的属性。
- Object.assign()：忽略enumerable为false的属性，只拷贝对
象自身的可枚举的属性。
</code></pre><p>这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for…in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for…in遍历到。</p>
<p>操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p>
<p><strong>属性的遍历</strong></p>
<p>ES6一共有5种方法可以遍历对象的属性。</p>
<p><strong>（1）for…in</strong></p>
<p>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>
<p><strong>（2）Objects.keys(obj)</strong></p>
<p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p>Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是Symbol或字符串，也不管是否可枚举。</p>
<p>以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<pre><code>-首先遍历所有数值键，按照数值升序排列。
-其次遍历所有字符串键，按照加入时间升序排列。
-最后遍历所有Symbol键，按照加入时间升序排列。
</code></pre><h2 id="7-Object-getOwnPropertyDescriptors"><a href="#7-Object-getOwnPropertyDescriptors" class="headerlink" title="7.Object.getOwnPropertyDescriptors()"></a>7.Object.getOwnPropertyDescriptors()</h2><p>前面说过，Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<p>Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</p>
<p>出于完整性的考虑，Object.getOwnPropertyDescriptors进入标准以后，以后还会新增Reflect.getOwnPropertyDescriptors方法。</p>
<h2 id="8-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#8-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="8.proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>8.<em>proto</em>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p>JavaScript语言的对象继承是通过原型链实现的。ES6提供了更多原型对象的操作方法。</p>
<p><strong><em>proto</em>属性</strong></p>
<p><em>proto</em>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性。</p>
<p>实现上，<strong>proto</strong>调用的是Object.prototype.<strong>proto</strong></p>
<p>如果一个对象本身部署了<em>proto</em>属性，该属性的值就是对象的原型。</p>
<p><strong>Object.setPrototypeOf()</strong></p>
<p>Object.setPrototypeOf方法的作用与<em>proto</em>相同，用来设置一个对象的prototype对象，返回参数对象本身。它是ES6正式推荐的设置原型对象的方法。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<p>由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。</p>
<p><strong>Object.getPrototypeOf()</strong></p>
<p>该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。</p>
<p>如果参数不是对象，会被自动转为对象。</p>
<h2 id="9-super关键字"><a href="#9-super关键字" class="headerlink" title="9.super关键字"></a>9.super关键字</h2><p>我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。</p>
<p>注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<p>上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。</p>
<h2 id="10-Object-keys-，Object-values-，Object-entries"><a href="#10-Object-keys-，Object-values-，Object-entries" class="headerlink" title="10.Object.keys()，Object.values()，Object.entries()"></a>10.Object.keys()，Object.values()，Object.entries()</h2><p><strong>Object.keys()</strong></p>
<p>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<p>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p>
<p><strong>Object.values()</strong></p>
<p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<p>Object.values只返回对象自身的可遍历属性。</p>
<p>。。。。。。。。。。</p>
<p><strong>Object.entries</strong></p>
<p>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<p>除了返回值不一样，该方法的行为与Object.values基本一致。</p>
<p>Object.entries的基本用途是遍历对象的属性。</p>
<h2 id="11-对象的扩展运算符"><a href="#11-对象的扩展运算符" class="headerlink" title="11.对象的扩展运算符"></a>11.对象的扩展运算符</h2><p>《数组的扩展》一章中，已经介绍过扩展运算符（…）。</p>
<p>ES2018 将这个运算符引入了对象。</p>
<p><strong>解构赋值</strong></p>
<p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。</p>
<p>解构赋值必须是最后一个参数，否则会报错。</p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<p><strong>扩展运算符</strong></p>
<p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<p>这等同于使用Object.assign方法。</p>
<p>扩展运算符可以用于合并两个对象。</p>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>
<p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>
<p>如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错。</p>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p>
<p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<p>注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<p>但是，Symbol 值可以显式转为字符串。</p>
<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<h2 id="2-作为属性名的Symbol"><a href="#2-作为属性名的Symbol" class="headerlink" title="2.作为属性名的Symbol"></a>2.作为属性名的Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<p>常量使用Symbol值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。</p>
<p>还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h2 id="3-实例：消除魔术字符串"><a href="#3-实例：消除魔术字符串" class="headerlink" title="3.实例：消除魔术字符串"></a>3.实例：消除魔术字符串</h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，尽量消除魔术字符串，改由含义清晰的变量代替。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<h2 id="4-属性名的遍历"><a href="#4-属性名的遍历" class="headerlink" title="4.属性名的遍历"></a>4.属性名的遍历</h2><p>Symbol作为属性名，该属性不会出现在for…in、 for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringfy()返回。但是，它也不是私有属性，有一个Object.geOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。</p>
<p>Object.getOwnProoertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。</p>
<p>另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。</p>
<p>由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些私有的、但又希望只用于内部的方法。</p>
<h2 id="5-Symbol-for-，Symbol-keyFor"><a href="#5-Symbol-for-，Symbol-keyFor" class="headerlink" title="5.Symbol.for()，Symbol.keyFor()"></a>5.Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。</p>
<p>Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。</p>
<p>需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。</p>
<p>iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>
<h2 id="6-实例：模块的Singleton模式"><a href="#6-实例：模块的Singleton模式" class="headerlink" title="6.实例：模块的Singleton模式"></a>6.实例：模块的Singleton模式</h2><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>
<p>很容易想到，可以把实例放到顶层对象global。</p>
<h2 id="7-内置的Symbol值"><a href="#7-内置的Symbol值" class="headerlink" title="7.内置的Symbol值"></a>7.内置的Symbol值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<p><strong>Symbol.hasInstance</strong></p>
<p>对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo             <a href="foo">Symbol.hasInstance</a>。</p>
<p><strong>Symbol.isConcatSpreadable</strong></p>
<p>对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。</p>
<p>数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。</p>
<p>类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。</p>
<p><strong>Symbol.species</strong></p>
<p>对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<p>总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>
<p><strong>Symbol.match</strong></p>
<p>对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<p><strong>Symbol.replace</strong></p>
<p>对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p>
<p>Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。</p>
<p><strong>Symbol.search</strong></p>
<p>对象的Symbol.search属性，指向一个方法，当该对象被String.prpototype.search方法调用时，会返回该方法的返回值。</p>
<p><strong>Symbol.split</strong></p>
<p>对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p>
<p><strong>Symbol.iterator</strong></p>
<p>对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p>
<p>对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，</p>
<p><strong>Symbol.toPrimitive</strong></p>
<p>对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p>Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<pre><code>- Number：该场合需要转为数值
- String：该场合需要转为字符串
- Default：该场合可以转为数值，也可以转为字符串
</code></pre><p><strong>Symbol.toStringTag</strong></p>
<p>对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。</p>
<p>ES6 新增内置对象的Symbol.toStringTag属性值如下。</p>
<pre><code>- JSON[Symbol.toStringTag]：&apos;JSON&apos;
- Math[Symbol.toStringTag]：&apos;Math&apos;
- Module 对象M[Symbol.toStringTag]：&apos;Module&apos;
- ArrayBuffer.prototype[Symbol.toStringTag]：&apos;ArrayBuffer&apos;
- DataView.prototype[Symbol.toStringTag]：&apos;DataView&apos;
- Map.prototype[Symbol.toStringTag]：&apos;Map&apos;
- Promise.prototype[Symbol.toStringTag]：&apos;Promise&apos;
- Set.prototype[Symbol.toStringTag]：&apos;Set&apos;
- %TypedArray%.prototype[Symbol.toStringTag]：&apos;Uint8Array&apos;等
- WeakMap.prototype[Symbol.toStringTag]：&apos;WeakMap&apos;
- WeakSet.prototype[Symbol.toStringTag]：&apos;WeakSet&apos;
- %MapIteratorPrototype%[Symbol.toStringTag]：&apos;Map Iterator&apos;
- %SetIteratorPrototype%[Symbol.toStringTag]：&apos;Set Iterator&apos;
- %StringIteratorPrototype%
[Symbol.toStringTag]：&apos;String Iterator&apos;
- Symbol.prototype[Symbol.toStringTag]：&apos;Symbol&apos;
- Generator.prototype[Symbol.toStringTag]：&apos;Generator&apos;
- GeneratorFunction.prototype
[Symbol.toStringTag]：&apos;GeneratorFunction&apos;
</code></pre><p><strong>Symbol.unscopables</strong></p>
<p>对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p>
<p>数组有 7 个属性，会被with命令排除。</p>
<h1 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h1><h2 id="1-Set"><a href="#1-Set" class="headerlink" title="1.Set"></a>1.Set</h2><p><strong>基本用法</strong></p>
<p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的没有重复的值。</p>
<p>Set本身是一个构造函数，用来生成Set数据结构。</p>
<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<p>// 去除数组的重复成员</p>
<p>[…new Set(array)]</p>
<p>向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。</p>
<p>另外，两个对象总是不相等的。</p>
<p><strong>Set实例的属性和方法</strong></p>
<p>Set 结构的实例有以下属性。</p>
<pre><code>- Set.prototype.constructor：构造函数，默认就是Set函数。
- Set.prototype.size：返回Set实例的成员总数。
</code></pre><p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<pre><code>- add(value)：添加某个值，返回Set结构本身。
- delete(value)：删除某个值，返回一个布尔值，表示删除是否成功
- has(value)：返回一个布尔值，表示该值是否为Set的成员。
- clear()：清除所有成员，没有返回值。
</code></pre><p><strong>遍历操作</strong></p>
<p>Set结构的示例有四个遍历方法，可以用于遍历成员。</p>
<pre><code>- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回键值对的遍历器
- forEach()：使用回调函数遍历每个成员
</code></pre><p>需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p><strong>（1）keys()， values()，entries()</strong></p>
<p>keys方法、values方法、entries方法返回的都是遍历器对象（）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。</p>
<p>entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。</p>
<p>这意味着，可以省略values方法，直接用for…of循环遍历Set。</p>
<p><strong>（2）forEach()</strong></p>
<p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>
<p>forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。</p>
<p><strong>（3）遍历的应用</strong></p>
<p>扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。</p>
<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<p>而且，数组的map和filter方法也可以间接用于 Set 了。</p>
<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。</p>
<h2 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2.WeakSet"></a>2.WeakSet</h2><p><strong>含义</strong></p>
<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p>
<p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p>
<p><strong>语法</strong></p>
<p>WeakSet是一个构造函数，可以使用new命令，创建 WeakSet 数据结构。</p>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<p>WeakSet结构有以下三个方法。</p>
<pre><code>- WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。
- WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。
- WeakSet.prototype.has(value)：返回一个布尔值，表示某个值
是否在WeakSet实例之中。
</code></pre><p>WeakSet 没有size属性，没有办法遍历它的成员。</p>
<p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h2><p><strong>含义和基本用法</strong></p>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。</p>
<p>我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<p>如果读取一个未知的键，则返回undefined。</p>
<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p>
<h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><p>Map结构的实例有以下属性和操作方法。</p>
<p><strong>（1）size属性</strong></p>
<p>size属性返回 Map 结构的成员总数。</p>
<p><strong>（2）set(key，value)</strong></p>
<p>set方法设置键名key对应的键值为value，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</p>
<p><strong>（3）get(key)</strong></p>
<p>get方法读取key对应的键值，如果找不到key，返回undefined。</p>
<p><strong>（4）has(key)</strong></p>
<p>has方法返回一个布尔值，表示某个键是否在当前Map对象之中。</p>
<p><strong>（5）delete(key)</strong></p>
<p>delete方法删除某个键，返回true。如果删除失败，返回false。</p>
<p><strong>（6）clear()</strong></p>
<p>clear方法清除所有成员，没有返回值。</p>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<pre><code>- keys()：返回键名的遍历器。
- values()：返回键值的遍历器。
- entries()：返回所有成员的遍历器。
- forEach()：遍历Map的所有成员。
</code></pre><p>需要特别注意的是，Map的遍历顺序就是插入顺序。</p>
<p>表示Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。</p>
<p>Map结构转为数组结构，比较快速的方法是使用扩展运算符（…）。</p>
<p>结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。</p>
<p>此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。</p>
<p>forEach方法还可以接受第二个参数，用来绑定this。</p>
<h2 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h2><p><strong>（1）Map转为数组</strong></p>
<p>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p>
<p><strong>（2）数组转为Map</strong></p>
<p>将数组传入Map构造函数，就可以转为Map。</p>
<p><strong>（3）Map转为对象</strong></p>
<p>如果所有Map的键都是字符串，它可以无损地转为对象。</p>
<p>如果有非字符串的键名，那么这个键名会被转为字符串，再作为对象的键名。</p>
<p><strong>（4）对象转为Map</strong></p>
<p><strong>（5）Map转为JSON</strong></p>
<p>Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。</p>
<p>另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。</p>
<p><strong>（6）JSON转为Map</strong></p>
<p>JSON转为Map，正常情况下，所有键名都是字符串。</p>
<p>但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是Map转为数组JSON的逆操作。</p>
<h2 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4.WeakMap"></a>4.WeakMap</h2><p><strong>含义</strong></p>
<p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。</p>
<p>WeakMap与Map的区别有两点。</p>
<p>首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</p>
<p>其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>
<p>WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的应用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。</p>
<p>WeakMap就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap里面的键名对象和所对应的键值对会自动消失，不会手动删除引用。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用WeakMap。一个典型应用场景是，在网页的DOM元素上添加数据，就可以使用WeakMap结构。当该DOM元素被清除，其所对应的WeakMap记录就会自动被移除。</p>
<p>也就是说，上面的DOM节点对象的引用计数是1，而不是2。这时，一旦清除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap保存的这个键值对，也会自动消失。</p>
<p>总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄露。</p>
<p>注意，WeakMap弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<p><strong>WeakMap的语法</strong></p>
<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<p><strong>WeakMap的示例</strong></p>
<p>WeakMap的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向WeakMap的键名了，导致无法证实那个键名是不是存在。</p>
<p>贺师俊老师提示，如果引用所指向的值占用特别多的内存，就可以通过Node的process.memoryUsage方法看出来。</p>
<p><strong>WeakMap的用途</strong></p>
<p>前文说过，WeakMap应用的典型场合就是DOM节点作为键名。</p>
<p>myElement是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是myElement。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄露风险。</p>
<p>WeakMap的另一个用处是部署私有属性。</p>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p>ES6原生提供Proxy构造函数，用来生成Proxy实例。</p>
<p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<p>作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。</p>
<p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果handler没有设置任何拦截，那就等同于直接通向原对象。</p>
<p>handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。</p>
<p>一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。</p>
<p>Proxy实例也可以作为其他对象的原型对象。</p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<p>对于可以设置、但没有设置拦截器的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<p>下面是Proxy支持的拦截操作一览，一共13种。</p>
<pre><code>- get(target,propKey,receiver)：拦截对象属性的读取，比如
proxy.foo和proxy[&apos;foo&apos;]。
- set(target,propKey,value,receiver)：拦截对象属性的设
置，比如propxy.foo = v或proxy[&apos;foo&apos;] = v，返回一个布尔值。
- has(target, propKey)：拦截propKey in proxy的操作，返回
布尔值。
- deleteProperty(target，propKey)：拦截delete proxy
[propKey]的操作，返回一个布尔值。
- ownKeys(target)：拦截Object.getOwnPropertyNames
(proxy)、Object.getOwnPropertySymbols(proxy)、
Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目
标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包
括目标对象自身的可遍历属性。
- getOwnPropertyDescriptor(target, propKey)：拦截
Object.getOwnPropertyDescriptor(proxy, propKey)，返回属
性的描述对象。
- defineProperty(target, propKey, propDesc)：拦截
Object.defineProperty(proxy, propKey, propDesc）、
Object.defineProperties(proxy, propDescs)，返回一个布尔值。
- preventExtensions(target)：拦截
Object.preventExtensions(proxy)，返回一个布尔值。
- getPrototypeOf(target)：拦截Object.getPrototypeOf
(proxy)，返回一个对象。
- isExtensible(target)：拦截Object.isExtensible
(proxy)，返回一个布尔值。
- setPrototypeOf(target, proto)：拦截
Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果
目标对象是函数，那么还有两种额外操作可以拦截。
- apply(target, object, args)：拦截 Proxy 实例作为函数调
用的操作，比如proxy(...args)、proxy.call
(object, ...args)、proxy.apply(...)。
- construct(target, args)：拦截 Proxy 实例作为构造函数调
用的操作，比如new proxy(...args)。
</code></pre><h2 id="2-Proxy实例的方法"><a href="#2-Proxy实例的方法" class="headerlink" title="2.Proxy实例的方法"></a>2.Proxy实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p>
<p><strong>get()</strong></p>
<p>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和proxy实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p>get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<p>如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</p>
<p>get方法可以继承。</p>
<p>利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。</p>
<p><strong>set()</strong></p>
<p>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和Proxy实例本身，其中最后一个参数可选。</p>
<p><strong>apply()</strong></p>
<p>apply方法拦截函数的调用、call和apply操作。</p>
<p>apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</p>
<p><strong>has()</strong></p>
<p>has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。</p>
<p>has方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<p><strong>construct()</strong></p>
<p>construct方法用于拦截new命令，</p>
<p>construct方法可以接受两个参数。</p>
<pre><code>- target：目标对象
- args：构造函数的参数对象
- newTarget：创造实例对象时，new命令作用的构造函数
</code></pre><p><strong>deleteProperty()</strong></p>
<p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<p><strong>defineProperty()</strong></p>
<p>defineProperty方法拦截了Object.defineProperty操作。</p>
<p><strong>getOwnPropertyDescriptor()</strong></p>
<p>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</p>
<p><strong>getPrototypeOf()</strong></p>
<p>getPrototypeOf方法主要用来拦截获取对象原型。</p>
<pre><code>- Object.prototype._proto_
- Object.prototype.isPrototypeOf()
- Object.getPrototypeOf()
- Reflect.getPrototypeOf()
- instanceof
</code></pre><p><strong>isExtensible()</strong></p>
<p>isExtensible方法拦截Object.isExtensible操作。</p>
<p><strong>ownKeys()</strong></p>
<p>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>
<pre><code>- Object.getOwnPropertyNames()
- Object.getOwnPropertySymbols()
- Object.keys()
- for...in循环
</code></pre><p><strong>preventExtensions()</strong></p>
<p>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p>
<p><strong>setPrototypeOf()</strong></p>
<p>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</p>
<h2 id="3-Proxy-revocable"><a href="#3-Proxy-revocable" class="headerlink" title="3.Proxy.revocable()"></a>3.Proxy.revocable()</h2><p>Proxy.revocable方法返回一个可取消的Proxy实例。</p>
<h2 id="4-this问题"><a href="#4-this问题" class="headerlink" title="4.this问题"></a>4.this问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。</p>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><p>。。。。。。。。。。。。。。。。</p>
<h1 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h1><h2 id="1-Promise的含义"><a href="#1-Promise的含义" class="headerlink" title="1.Promise的含义"></a>1.Promise的含义</h2><p>Pormise是异步编程的一种解决方案，比传统的解决方案–回调函数和事件–更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p>
<p>Promise对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为resolved(已定型)。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用Stream模式是比部署Promise更好的选择。</p>
<h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变成“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。、</p>
<p>Promise新建后就会立即执行。</p>
<p>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例。</p>
<p>注意，调用resolve或reject并不会终结Promise的参数函数的执行。</p>
<p>立即resolved的Promise是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<p>一般来说，调用resolve或reject以后，Promise的使命就完成了，后继操作应该放在then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p>
<h2 id="3-Promise-prototype-then"><a href="#3-Promise-prototype-then" class="headerlink" title="3.Promise.prototype.then()"></a>3.Promise.prototype.then()</h2><p>Promise实例具有then方法，也就是说，then方法是定义在原型对象Promsie.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<p>使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<h2 id="4-Promise-prototype-catch"><a href="#4-Promise-prototype-catch" class="headerlink" title="4.Promise.prototype.catch()"></a>4.Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<p>如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<p>比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。</p>
<p>如果Promise状态已经变成resolved，再抛出错误是无效的。</p>
<p>Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为Promise的状态一旦改变，就永久保持该状态，不会再变了。</p>
<p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>
<p>一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
<p>一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。</p>
<p>第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步地写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p>
<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<p>Promise内部的错误不会影响到Promise外部的代码，通俗的说法就是“promise 会吃掉错误”。</p>
<p>这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node有一个unhandleRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>
<p>unhandleRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，它可以用来了解发生错误的环境信息。</p>
<p>Node有计划在未来废除unhandleRejection事件。如果Promise内部有未捕获的错误，会直接终止进程，并且进程的退出码不为0。</p>
<p>Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>
<p>一般总是建议，Promise对象后面要跟catch方法，这样可以处理Promise内部发生的错误。catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</p>
<p>运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。</p>
<p>catch方法之中，还能再抛出错误。</p>
<h2 id="5-Promise-prototype-finally"><a href="#5-Promise-prototype-finally" class="headerlink" title="5.Promise.prototype.finally()"></a>5.Promise.prototype.finally()</h2><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。该方法是ES2018引入标准的。</p>
<pre><code>promise
.then(result =&gt; {...})
.catch(error =&gt; {...})
.finally(() =&gt; {...});
</code></pre><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<p>服务器使用Promise处理请求，然后使用finally方法关掉服务器。</p>
<p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的Promise状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于Promise的执行结果。</p>
<p>finally本质上是then方法的特例。</p>
<p>如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p>
<p>不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。</p>
<p>finally方法总是会返回原来的值。</p>
<h2 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6.Promise.all()"></a>6.Promise.all()</h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<pre><code>const p = Promise.all([p1, p2, p3]);
</code></pre><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<pre><code>const promises = [2,3,4,5,7,11,13].map(function (id) {
    return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);
});

Promise.all(promises).then(function (posts) {

}).catch(function(reason){

});
</code></pre><p>promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</p>
<p>注意，如果作为参数的Promise实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p>
<h2 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7.Promise.race()"></a>7.Promise.race()</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<pre><code>const p = Promise.race([p1, p2, p3]);
</code></pre><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，P的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
<p>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<p>如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。</p>
<h2 id="8-Promise-resolve"><a href="#8-Promise-resolve" class="headerlink" title="8.Promise.resolve()"></a>8.Promise.resolve()</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<pre><code>const jsPromise = Promise.resolve($.ajax(&apos;/
whatever.json&apos;));
</code></pre><p>上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</p>
<p>Promise.resolve等价于下面的写法。</p>
<pre><code>Promise.resolve(&apos;foo&apos;)
// 等价于
new Promise(resolve =&gt; resolve(&apos;foo&apos;))
</code></pre><p>Promise.resolve方法的参数分成四个情况。</p>
<p><strong>（1）参数是一个Promise实例</strong></p>
<p>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（2）参数是一个thenable对象</strong></p>
<p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p>
<p>Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p>
<p><strong>（3）参数不是具有then方法的对象，或根本就不是对象</strong></p>
<p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。</p>
<p>由于字符串Hello不属于异步操作（判断方法是字符串对象不具有then方法），返回Promise实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p>
<p><strong>（4）不带有任何参数</strong></p>
<p>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。</p>
<p>所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法</p>
<pre><code>const p = Promise.resolve();

p.then(function () {

});
</code></pre><p>上面代码的变量p就是一个Promise对象。</p>
<p>需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”(event loop)的结束时，而不是在下一轮“事件循环”的开始时。</p>
<pre><code>setTimeout(function () {
    console.log(&apos;three&apos;);
}, 0);

Promise.resolve().then(function () {
    console.log(&apos;two&apos;);
});

console.log(&apos;one&apos;);

// one
// two
// three
</code></pre><p>上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。</p>
<h2 id="9-Promise-reject"><a href="#9-Promise-reject" class="headerlink" title="9.Promise.reject()"></a>9.Promise.reject()</h2><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。</p>
<pre><code>const p = Promise.reject(&apos;出错了&apos;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))

p.then(null, function (s) {
    console.log(s)
});
// 出错了
</code></pre><p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>
<p>注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</p>
<pre><code>const thenable = {
    then(resolve, reject) {
        reject(&apos;出错了&apos;);
    }
};

Promise.reject(thenable)
.catch(e =&gt; {
    console.log(e === thenable)
})
// true
</code></pre><p>上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</p>
<h2 id="10-应用"><a href="#10-应用" class="headerlink" title="10.应用"></a>10.应用</h2><p><strong>加载图片</strong></p>
<p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p>
<pre><code>const preloadImage = function (path) {
    return new Promise(function (resolve, reject) {
        const image = new Image();
        image.onload = resolve;
        image.onerror = reject;
        image.src = path;
    });
};
</code></pre><p><strong>Generator函数与Promise的结合</strong></p>
<p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>
<h2 id="11-Promise-try"><a href="#11-Promise-try" class="headerlink" title="11.Promise.try()"></a>11.Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用Promise来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。</p>
<pre><code>Promise.resolve().then(f)
</code></pre><p>上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。</p>
<pre><code>const f = () =&gt; console.log(&apos;now&apos;);
Promise.resolve().then(f);
console.log(&apos;next&apos;);
// next
// now
</code></pre><p>上面代码中，函数f是同步的，但是用Promise包装了以后，就变成异步执行了。</p>
<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的API呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。</p>
<pre><code>const f = () =&gt; console.log(&apos;now&apos;);
(async () =&gt; f())();
console.log(&apos;next&apos;);
// now 
// next
</code></pre><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。</p>
<pre><code>（async () =&gt; f())()
.then(...)
</code></pre><p>需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</p>
<pre><code>（async () =&gt; f())()
.then(...)
.catch(...)
</code></pre><p>第二种写法是使用new Promise()。</p>
<pre><code>const f = () =&gt; console.log(&apos;now&apos;);
(
    () =&gt; new Promise(
        reolve =&gt; resolve(f())
    )
)();
console.log(&apos;next&apos;);
// now
// next
</code></pre><p>上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。</p>
<p>鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。</p>
<pre><code>const f = () =&gt; console.log(&apos;now&apos;);
Promise.try(f);
console.log(&apos;next&apos;);
// now
// next
</code></pre><p>事实上，Promsie.try存在已久，Promise库Bluebird、Q和when，早就提供了这个方法。</p>
<p>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p>
<pre><code>function getUsername(userId) {
    return database.users.get({id: userId})
    .then(function(user) {
        return user.name;
    });
}
</code></pre><p>上面代码中，database.users.get()返回一个Promise对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。<br>    database.users.get({id: userId})<br>    .then(…)<br>    .catch(…)</p>
<p>但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try…catch去捕获。</p>
<pre><code>try {
    database.users.get({id: userId})
    .then(...)
    .catch(...)
} catch (e) {
    // ...
}
</code></pre><p>上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。</p>
<pre><code>Promise.try(database.users.get({id: userId})
    .then(...)
    .catch(...)
</code></pre><p>事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p>
<h1 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h1><p>1.Iterator（遍历器）的概念</p>
<p>JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map,Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p>
<p>Iterator的遍历过程是这样的。</p>
<p>（1）创造一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>
<p>下面是一个模拟next方法返回值的例子。</p>
<pre><code>var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);

it.next() // { value: &quot;a&quot;, done: false }
it.next() // { value: &quot;b&quot;, done: false }
it.next() // { value: undefined, done: true }

function makeIterator(array) {
    var nextIndex = 0;
    return {
        next: function() {
            return nextIndex &lt; array.length ? 
                {value: array[nextIndex++], done: false} :
                {value: undefined, done: true};
        }
    };
}
</code></pre><p>上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[‘a’, ‘b’]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。</p>
<p>指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。</p>
<p>next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。</p>
<p>总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。</p>
<p>对于遍历器对象来说，done:false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。</p>
<pre><code>function makeIterator(array) {
    var nextIndex = 0;
    return {
        next: function() {
            return nextIndex &lt; array.length ?
                {value: array[nextIndex++]} :
                {done: true};
        }
    };
}
</code></pre><p>由于Iterator只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。</p>
<p>如果使用TypeScript的写法，遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。</p>
<pre><code>iterface Iterable {
    [Symbol.iterator]() : Iterator,
}

iterface Iterator {
    next(value?: any) : IterationResult,
}

iterface IterationResult {
    value: any,
    done: boolean,
}
</code></pre><h2 id="2-默认Iterator接口"><a href="#2-默认Iterator接口" class="headerlink" title="2.默认Iterator接口"></a>2.默认Iterator接口</h2><p>Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p>
<p>一种数据结构只要部署了Iterator接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>
<pre><code>const obj = {
    [Symbol.iterator]: function () {
        return {
            next: function() {
                return {
                    value: 1,
                    done: true
                };
            }
        };
    }
};
</code></pre><p>上面代码中，对象obj是可遍历的（iterable）,因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。</p>
<p>ES6的有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被for…of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备Iterator接口的数据结构如下。</p>
<pre><code>- Array
- Map
- Set
- String
- TypedArray
- 函数的argumnets对象
- NodeList对象
</code></pre><p>下面的例子是数组的Symbol.iterator属性。</p>
<pre><code>let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
let iter = arr[Symbol.iterator]();

iter.next() // { value: &apos;a&apos;, done: false}
iter.next()    // { value: &apos;b&apos;, done: false}
iter.next()    // { value: &apos;c&apos;, done: false}
iter.next()    // { value: undefined, done: true}
</code></pre><p>上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。</p>
<p>对于原生部署Iterator接口的数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。</p>
<p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。</p>
<p>一个对象如果要具备可被for…of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<p>对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的Iterator接口。</p>
<p>NodeList对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的Symbol.iterator属性，可以看到没有任何影响。</p>
<p>注意，普通对象部署数组的Symbol.iterator方法，并无效果。</p>
<p>如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p>
<p>有了遍历器接口，数据结构就可以用for…of循环遍历（详见下文），也可以使用while循环遍历。</p>
<p>。。。。。。。。。。</p>
<h2 id="3-调用Iterator接口的场合"><a href="#3-调用Iterator接口的场合" class="headerlink" title="3.调用Iterator接口的场合"></a>3.调用Iterator接口的场合</h2><p>有一些场合会默认调用Iterator接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。</p>
<p><strong>（1）解构赋值</strong></p>
<p>对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。</p>
<p><strong>（2）扩展运算符</strong></p>
<p>扩展运算符（…）也会调用默认的Iterator接口。</p>
<p>实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。</p>
<p><strong>（3）yield*</strong></p>
<p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<p><strong>（4）其他场合</strong></p>
<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<pre><code>- for...of
- Array.from()
- Map()，Set()，WeakMap()，WeakSet()(比如new Map
([&apos;a&apos;,1]), [&apos;b&apos;,2]] )
- Promise.all()
- Promise.race()
</code></pre><h2 id="4-字符串的Iterator接口"><a href="#4-字符串的Iterator接口" class="headerlink" title="4.字符串的Iterator接口"></a>4.字符串的Iterator接口</h2><p>字符串是一个类似数组的对象，也原生具有Iterator接口。</p>
<h2 id="5-Iterator接口与Generator函数"><a href="#5-Iterator接口与Generator函数" class="headerlink" title="5.Iterator接口与Generator函数"></a>5.Iterator接口与Generator函数</h2><p>Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。</p>
<h2 id="6-遍历器对象的return-，throw"><a href="#6-遍历器对象的return-，throw" class="headerlink" title="6.遍历器对象的return()，throw()"></a>6.遍历器对象的return()，throw()</h2><p>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。</p>
<p>return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。</p>
<h2 id="7-for…of循环"><a href="#7-for…of循环" class="headerlink" title="7.for…of循环"></a>7.for…of循环</h2><p>ES6借鉴C++、Java、C#和Python语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。</p>
<p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p>
<p>for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>
<pre><code>const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];

for(let v of arr) {
    console.log(v); // red green blue
}

const obj = {};
obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);

for(let v of obj) {
    console.log(v); // red green blue
}
</code></pre><p>上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for…of循环，产生了与arr完全一样的结果。</p>
<p>for…of循环可以代替数组实例的forEach方法。</p>
<p>JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。</p>
<p>for…in循环读取键名，for…of循环读取键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法。</p>
<p>for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for…in循环也不一样。</p>
<h2 id="Set和Map结构"><a href="#Set和Map结构" class="headerlink" title="Set和Map结构"></a>Set和Map结构</h2><p>Set和Map结构也原生具有Iterator接口，可以直接使用for…of循环。</p>
<p>。。。。。。。。。。。。</p>
<h2 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h2><p>以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。</p>
<pre><code>for (var index = 0; index &lt; myArray.length; index++) {
    console.log(myArray[index]);
}
</code></pre><p>这种写法比较麻烦，因此数组提供内置的forEach方法。</p>
<pre><code>myArray.forEach(function (value) {
    console.log(value);
});
</code></pre><p>这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。</p>
<p>for…in循环可以遍历数组的键名。</p>
<pre><code>for (var index in myArray) {
    console.log(myArray[index]);
}
</code></pre><p>for…in循环有几个缺点。</p>
<pre><code>- 数组的键名是数字，但是for...in循环时以字符串作为键
名“0”、“1”、“2”等等。

- for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚
至包括原型链上的键

- 某些情况下，for...in循环会以任意顺序遍历键名。
</code></pre><p>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p>for…in循环相比上面几种做法，有一些显著的优点。</p>
<pre><code>for (let value of myArray) {
    console.log(value);
}

- 有着同for...in一样的简洁语法，但是没有for...in那些缺点。
- 不同于forEach方法，它可以与break、continue和retrun配合使用。
- 提供了遍历所有数据结构的统一操作接口。
</code></pre><p>下面是一个使用break语句，跳出for…of循环的例子。</p>
<pre><code>for (var n of fibonacci) {
    if (n &gt; 1000)
        break;
    console.log(n);
}
</code></pre><p>上面的例子，会输出斐波那契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for…of循环。</p>
<h1 id="Generator函数的语法"><a href="#Generator函数的语法" class="headerlink" title="Generator函数的语法"></a>Generator函数的语法</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><strong>基本概念</strong></p>
<p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用</p>
<p>Generator函数有多种理解角度。语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>
<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
<p>形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<pre><code>function* helloWorldGenerator() {
    yield &apos;hello&apos;;
    yield &apos;world&apos;;
    retrun &apos;ending&apos;;
}

var hw = helloWorldGenerator();
</code></pre><p>上面代码定义了一个Generator函数helloWorldGenerator，它内部有yield表达式（hello和world），即该函数有三个状态：hello，world和return语句（结束执行）。</p>
<p>然后，Generator函数的调用方法与普通函数一样，也是在函数后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>
<p>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</p>
<p>总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<p>ES6没有规定，function关键字与函数名之间的星号，写在那个位置。这导致下面的写法都能通过。</p>
<h2 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h2><p>由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p>
<p>遍历器对象的next方法的运行逻辑如下。</p>
<p>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</p>
<p>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</p>
<p>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</p>
<p>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>
<p>yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（英语中，generator这个词是“生成器”的意思）。</p>
<p>Generator函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<p>另外需要注意，yield表达式只能用在Generator函数里面，用在其他地方都会报错。</p>
<p>forEach方法的参数是一个普通函数，但是在里面使用yield表达式。一种修改方法是改用for循环。</p>
<p>另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>
<p>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<h2 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h2><p>上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</p>
<pre><code>var myIterable = {};
myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};

[...myIterable] // [1, 2, 3]
</code></pre><p>上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被…运算符遍历了。</p>
<h2 id="2-next方法的参数"><a href="#2-next方法的参数" class="headerlink" title="2.next方法的参数"></a>2.next方法的参数</h2><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
<p>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</p>
<p>如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。</p>
<pre><code>function wrapper(generatorFunction) {
    return function (...args) {
        let generatorObject = generatorFunction(...args);
        generatorObject.next();
        return generatorObject;
    };
}

const wrapped = wrapper(function* () {
    console.log(`First input: ${yield}`);
return &apos;DONE&apos;;    
});

wrapped().next(&apos;hello&apos;)
// First input: hello!
</code></pre><p>上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。</p>
<h2 id="3-for…of循环"><a href="#3-for…of循环" class="headerlink" title="3.for…of循环"></a>3.for…of循环</h2><p>for…of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。</p>
<pre><code>function* foo() {
    yield 1;
    yield 2;
    yield 3;
    return 4;
}

for (let v of foo()) {
    console.log(v);
}
// 1 2 3 
</code></pre><p>上面代码使用for…of循环，依次显示5个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包含在for…of循环之中。</p>
<p>利用for…of循环，可以写出遍历任意对象（object）的方法。原生的JavaScript对象没有遍历接口，无法使用for…of循环，通过Generator函数为它加上这个接口，就可以用了。</p>
<p>。。。。。。。。。。。</p>
<h2 id="4-Generator-prototype-throw"><a href="#4-Generator-prototype-throw" class="headerlink" title="4.Generator.prototype.throw()"></a>4.Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。</p>
<p>。。。。。。。。。。。</p>
<h2 id="5-Generator-prototype-retrun"><a href="#5-Generator-prototype-retrun" class="headerlink" title="5.Generator.prototype.retrun()"></a>5.Generator.prototype.retrun()</h2><p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<pre><code>function* gen() {
    yield 1;
    yield 2;
    yield 3;
}

var g = gen();

g.next()    // { value: 1, done: false }
g.return(&apos;foo&apos;) // { value: &quot;foo&quot;, done: true }
g.next() // { value: undefined, done: true }
</code></pre><p>上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。</p>
<p>如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p>
<p>如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<p>调用retrun方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。</p>
<h2 id="6-next-、throw-、return-的共同点"><a href="#6-next-、throw-、return-的共同点" class="headerlink" title="6.next()、throw()、return()的共同点"></a>6.next()、throw()、return()的共同点</h2><p>next()、throw()、retrun()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式。</p>
<p>next()是将yield表达式替换成一个值。</p>
<pre><code>const g = function* (x, y) {
    let result = yield x + y;
    return result;
};

const gen = g(1, 2);
gen.next(); // Object {value: 3, done: false} 

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成let result = 1;
</code></pre><p>上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。</p>
<p>throw()是将yield表达式替换成一个throw语句。</p>
<pre><code>gen.throw(new Error(&apos;出错了&apos;)); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成let result = throw(new Error(&apos;出错了&apos;));
</code></pre><p>return()是将yield表达式替换成一个return语句。</p>
<pre><code>gen.return(2); // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
</code></pre><h2 id="7-yield-表达式"><a href="#7-yield-表达式" class="headerlink" title="7.yield* 表达式"></a>7.yield* 表达式</h2><p>如果在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。</p>
<p>这个就需要用到yield*表达式，用来在一个Generator函数里面执行另一个Generator函数。</p>
<p>从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。</p>
<h2 id="8-作为对象属性的Generator函数"><a href="#8-作为对象属性的Generator函数" class="headerlink" title="8.作为对象属性的Generator函数"></a>8.作为对象属性的Generator函数</h2><p>如果一个对象的属性是Generator函数，可以简写成下面的形式。</p>
<pre><code>let obj = {
    * myGeneratorMethod() {
        ...
    }
};
</code></pre><p>上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。</p>
<p>它的完整形式如下，与上面的写法是等价的。</p>
<pre><code>let obj = {
    myGeneratorMethod: function* () {
        // ...
    }
};
</code></pre><h2 id="9-Generator函数的this"><a href="#9-Generator函数的this" class="headerlink" title="9.Generator函数的this"></a>9.Generator函数的this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。</p>
<p>Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。</p>
<p>。。。。。。。。。。</p>
<h2 id="10-含义"><a href="#10-含义" class="headerlink" title="10.含义"></a>10.含义</h2><h2 id="Generator与状态机"><a href="#Generator与状态机" class="headerlink" title="Generator与状态机"></a>Generator与状态机</h2><p>Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。</p>
<p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>
<h2 id="Generator与协程"><a href="#Generator与协程" class="headerlink" title="Generator与协程"></a>Generator与协程</h2><p>。。。。。。。。。。。。。。。。。</p>
<h1 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h1><p>异步编程对JavaScript语言太重要。JavaScript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍Generator函数如何完成异步操作。</p>
<h2 id="1-传统方法"><a href="#1-传统方法" class="headerlink" title="1.传统方法"></a>1.传统方法</h2><p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<pre><code>- 回调函数
- 事件监听
- 发布/订阅
- Promise对象
</code></pre><p>Generator函数将JavaScript异步编程带入了一个全新的阶段。</p>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>所谓“异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是“重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<pre><code>fs.readFile(&apos;/etc/passwd&apos;, &apos;utf-8&apos;, function (err, data) {
    if (err) throw err;
    console.log(data);
});
</code></pre><p>上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么Node约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？</p>
<p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<pre><code>fs.readFile(fileA, &apos;utf-8&apos;, function (err, data) {
    fs.readFile(fileB, &apos;utf-8&apos;, function (err, data) {
        // ...
    });
});
</code></pre><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为“回调函数地狱”（callback hell）。</p>
<p>Promise对象就是为了解决这个问题二提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。</p>
<pre><code>var readFile = require(&apos;fs-readfile-promise&apos;);

readFile(fileA)
.then(function (data) {
    console.log(data.toString());
})
.then(function () {
    return readFile(fileB);
})
.then(function (data) {
    console.log(data.toString());
})
.catch(function (err) {
    console.log(err)
});
</code></pre><p>上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，Promise的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p>Promise的最大问题是代码冗余，原来的任务被Promise包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。</p>
<p>那么，有没有更好的写法呢？</p>
<h2 id="3-Generator函数"><a href="#3-Generator函数" class="headerlink" title="3.Generator函数"></a>3.Generator函数</h2><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做“协程”（coroutine）,意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<pre><code>- 第一步，协程A开始执行。
- 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。
- 第三步，（一段时间后）协程B交还执行权。
- 第四步，协程A恢复执行。
</code></pre><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<pre><code>function* asyncJob() {
    // ...其他代码
    var f = yield readFile(fileA);
    // ...其他代码
}
</code></pre><p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行都此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p>
<p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h2 id="协程的Generator函数实现"><a href="#协程的Generator函数实现" class="headerlink" title="协程的Generator函数实现"></a>协程的Generator函数实现</h2><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p>
<pre><code>function* gen(x) {
    var y = yield x + 2;
    return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
</code></pre><p>上面代码中，调用generator函数，会返回一个内部指针（即遍历器）g。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上列是执行到x + 2为止。</p>
<p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h2 id="Generator函数的数据交换和错误处理"><a href="#Generator函数的数据交换和错误处理" class="headerlink" title="Generator函数的数据交换和错误处理"></a>Generator函数的数据交换和错误处理</h2><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，向Generator函数体内输入数据。</p>
<pre><code>function* gen(x){
    var y = yield x + 2;
    return y;
}

var g = gen(1);
g.next()    // {value: 3, done: false}
g.next(2)    // {value: 2, done: true}
</code></pre><p>上面代码中，第一个next方法的value属性，返回表达式x + 2的值3。第二个next方法带有参数2,这个参数可以传入Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的value属性，返回的就是2（变量y的值）。</p>
<p>。。。。。。。。。</p>
<h2 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h2><p>下面看看如何使用Generator函数，执行一个真实的异步任务。</p>
<pre><code>var fetch = require(&apos;node-fetch&apos;);

function* gen(){
    var url = &apos;https://api.github.com/users/github&apos;;
    var result = yield fetch(url);
    console.log(result.bio);
}
</code></pre><p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p>执行这段代码的方法如下。</p>
<pre><code>var g = gen();
var result = g.next();

result.value.then(function(data){
    return data.json();
}).then(function(data){
    g.next(data);
});
</code></pre><p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next方法。</p>
<p>可以看到，虽然Generator函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h2 id="1-含义"><a href="#1-含义" class="headerlink" title="1.含义"></a>1.含义</h2><p>ES2017标准引入了async函数，使得异步操作变得更加方便。</p>
<p>async函数是什么？一句话，它就是Generator函数的语法糖。</p>
<p>前文有一个Generator函数，依次读取两个文件。</p>
<pre><code>const fs = require(&apos;fs&apos;);

const readFile = function (fileName) {
    return new Promsie(function (resolve, reject) {
        fs.readFile(fileName, function(error, data) {
            if (error) return reject(error);
            resolve(data);
        });
    });
};

const gen = function* () {
    const f1 = yield readFile(&apos;/etc/fstab&apos;);
    const f2 = yield readFile(&apos;/etc/shells&apos;);
    console.log(f1.toString());
    console.log(f2.toString());
};
</code></pre><p>写成async函数，就是下面这样。</p>
<pre><code>const asyncReadFile = async function () {
    const f1 = await readFile(&apos;/etc/fstab&apos;);
    const f2 = await readFile(&apos;/etc/shells&apos;);
    console.log(f1.toString());
    console.log(f2.toString());
};
</code></pre><p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数对Generator函数的改进，体现在以下四点。</p>
<p><strong>（1）内置执行器。</strong></p>
<p>Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</p>
<pre><code>asyncReadFile();
</code></pre><p>上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。</p>
<p><strong>（2）更好的语义。</strong></p>
<p>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p><strong>（3）更广的适用性。</strong></p>
<p>co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p><strong>（4）返回值是Promise。</strong></p>
<p>async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。</p>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangXiaofei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangXiaofei</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
